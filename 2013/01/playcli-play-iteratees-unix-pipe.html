<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="author" content="Gaëtan Renaudeau"/><meta name="description" content="PlayCLI is a new Scala library to work with UNIX commands and Play-Iteratees (a scala implementation of Iteratees facilitating the handling of data streams reactively)"/><meta name="keywords" content="iteratee, playframework, reactive, unix, library"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@greweb"/><meta name="twitter:title" content="PlayCLI: Play Iteratees + UNIX pipe"/><meta name="og:title" content="PlayCLI: Play Iteratees + UNIX pipe"/><meta name="twitter:description" content="PlayCLI is a new Scala library to work with UNIX commands and Play-Iteratees (a scala implementation of Iteratees facilitating the handling of data streams reactively)"/><meta name="twitter:creator" content="@greweb"/><title>@greweb - PlayCLI: Play Iteratees + UNIX pipe</title><link href="http://fonts.googleapis.com/css?family=Fredericka+the+Great|Arapey|Roboto:400,700,400italic" rel="stylesheet" type="text/css"/><link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/styles/default.min.css"/><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/highlight.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/javascript.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/cpp.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/glsl.min.js"></script><link rel="stylesheet" href="/style/main.css"/><meta name="next-head-count" content="22"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-381dbb3c33243b4920e6.js"></script><script src="/_next/static/chunks/webpack-17597d20e291f72b2439.js" defer=""></script><script src="/_next/static/chunks/framework-bdc1b4e5e48979e16d36.js" defer=""></script><script src="/_next/static/chunks/main-4ac108dd57980e4159e9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c981e0e3ce59f13eb8d0.js" defer=""></script><script src="/_next/static/chunks/5988-738c1ea5f97353b6463e.js" defer=""></script><script src="/_next/static/chunks/2242-e809902ac2d7a524d02b.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-18d367ef37e4735025ef.js" defer=""></script><script src="/_next/static/g5cBXMQf8InWNdasEbAj2/_buildManifest.js" defer=""></script><script src="/_next/static/g5cBXMQf8InWNdasEbAj2/_ssgManifest.js" defer=""></script><style id="__jsx-2519965637">.block.jsx-2519965637{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.block.jsx-2519965637 .right.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637{margin-top:10px;}.block.jsx-2519965637 .social.jsx-2519965637 a.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637 img.jsx-2519965637{height:20px;}</style><style id="__jsx-3621368397">.container.jsx-3621368397{min-height:100vh;padding:0 0.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><style id="__jsx-3469673304">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto, Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue, sans-serif;}*{box-sizing:border-box;}a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a:hover,a:active{-webkit-text-decoration:underline;text-decoration:underline;}</style></head><body><div id="__next"><div class="jsx-3621368397 container"><div id="container"><div id="main"><div id="content"><article><header><h1><a href="/">PlayCLI: Play Iteratees + UNIX pipe</a></h1><time class="date" dateTime="2013-01-30">2013-01-30</time><span class="tags"><a class="tag">iteratee</a><a class="tag">playframework</a><a class="tag">reactive</a><a class="tag">unix</a><a class="tag">library</a></span></header><div class="entry-content"><blockquote>
<p><strong>TL;DR.</strong> PlayCLI is a new <a href="http://scala-lang.org">Scala</a> library to work with UNIX commands and <a href="http://www.playframework.org/documentation/2.0/Iteratees">Play-Iteratees</a> (a scala implementation of Iteratees facilitating the handling of data streams reactively). Here’s an overview:</p>
</blockquote>
<iframe src="http://gre.github.io/playCLI-examples/embedder.html#index.html" frameborder="0" width="550" height="452"></iframe>

<h2 id="links">Links</h2>
<ul>
<li>  <a href="http://gre.github.io/playCLI-examples/api">The scala API</a>.</li>
<li>  <a href="http://github.com/gre/playCLI">PlayCLI source code (Github)</a>.</li>
<li>  <a href="http://github.com/gre/playCLI-examples">PlayCLI Examples application (Github)</a>.</li>
</ul>
<h3 id="sbt">SBT</h3>
<pre><code class="language-scala">&quot;fr.greweb&quot; %% &quot;playcli&quot; % &quot;0.1&quot;
</code></pre>
<!--more-->

<h2 id="why-playcli">Why PlayCLI</h2>
<p>After having made <a href="/2012/08/zound-a-playframework-2-audio-streaming-experiment-using-iteratees/">Zound</a> in a HackDay (an experiment to generate an audio stream with playframework iteratees and through the WAVE format), I figured out this was going to be hard to make it work with multiple audio format: <em>tell me if I’m wrong but</em>, there are not so much audio libraries in Java/Scala, or most of them does not support stream handling (and not reactively), and it was going to be crazy to re-implement everything in Scala (both in term of cost and performance).</p>
<p>Besides, <strong>UNIX has plenty of tools</strong> to do this and:</p>
<ol>
<li> they are <strong>complete</strong> and provide a lot of options</li>
<li> they are <strong>easy to use</strong> (see how Bash is powerful as a consequence)</li>
<li> Most of them <strong>support streams</strong> out of the box (via stdin / stdout)</li>
<li> They are very <strong>efficient</strong> (written in C / assembly)</li>
</ol>
<p>So why not re-use them from our reactive code?</p>
<h3 id="similarities-with-unix-pipes">Similarities with UNIX pipes</h3>
<blockquote>
<p>Take the expressivity of UNIX pipes, bring the power of Scala, mix it with Play Framework and you got a powerful framework for handling real-time and web streaming.</p>
</blockquote>
<p>Play Iteratees are an elegant &amp; powerful way to handle streams reactively, and I’ve actually always understood them like UNIX pipes, you have the same reactive code style: linearized declarative way of handling streams.</p>
<p><strong>Bash:</strong></p>
<pre><code class="language-bash">cat words.txt | grep $word &gt; result.txt
</code></pre>
<p><strong>Scala:</strong></p>
<pre><code class="language-scala">Enumerator.fromFile(&quot;words.txt&quot;) &amp;&gt;   
  splitByNl &amp;&gt; // split a stream of Array[Byte] into stream of String (not impl here)  
  Enumeratee.filter(_.containsSlice(word))  |&gt;&gt;&gt;   
  fileWriter // consume the steam while storing in a file (not impl here)
</code></pre>
<p>or if you prefer the “without symbol” version:</p>
<pre><code class="language-scala">Enumerator.fromFile(&quot;words.txt&quot;).  
  through splitByNl.  
  through Enumeratee.filter(_.containsSlice(word)).  
  run fileWriter
</code></pre>
<p>However, It’s biased to say Iteratees are only UNIX pipes, they are more than that, but I’m not going to extend on that subject, they are at least statically typed and safe (it’s more than just a stream of bytes, see <a href="http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/">this article</a>).</p>
<p>So if Iteratees are at least UNIX pipes, why can’t we use Unix pipes from iteratees?</p>
<p><strong>PlayCLI provides a bridge to use scala.sys.Process with play-iteratees.</strong></p>
<h2 id="more-about-playcli">More about PlayCLI</h2>
<p><em>(this is a copy of the API documentation)</em></p>
<h3 id="overview">Overview</h3>
<p>Depending on your needs, you can <strong>Enumerate / Pipe / Consume</strong> an UNIX command:</p>
<p><a href="http://gre.github.io/playCLI-examples/api/#enumerate(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumerator%5BArray%5BByte%5D%5D">CLI.enumerate</a> is a way to create a stream from a command which <strong>generates output</strong><br>(it creates an <a href="http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Enumerator">Enumerator</a>[Array[Byte]] )</p>
<p><a href="http://gre.github.io/playCLI-examples/api/#pipe(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumeratee%5BArray%5BByte%5D,Array%5BByte%5D%5D">CLI.pipe</a> is a way to pipe a command which <strong>consumes input and generates output</strong><br>(it creates an <a href="http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Enumeratee">Enumeratee</a>[Array[Byte],Array[Byte]])</p>
<p><a href="http://gre.github.io/playCLI-examples/api/#consume(command:scala.sys.process.ProcessBuilder,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Iteratee%5BArray%5BByte%5D,Int%5D">CLI.consume</a> creates a process which <strong>consumes a stream</strong> – useful for side effect commands<br>(it creates an <a href="http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Iteratee">Iteratee</a>[Array[Byte],Int])</p>
<h4 id="examples">Examples</h4>
<pre><code class="language-scala">import playcli._  
import scala.sys.process._  
  
// Some CLI use cases  
val tail = CLI.enumerate(&quot;tail -f /var/log/nginx/access.log&quot;)  
val grep = (word: String) =&gt; CLI.pipe(Seq(&quot;grep&quot;, word))  
val ffmpeg = CLI.pipe(&quot;ffmpeg -i pipe:0 ... pipe:1&quot;) // video processing  
val convert = CLI.pipe(&quot;convert - -colors 64 png:-&quot;) // color quantization  
  
// Some usage examples  
val sharedTail = Concurrent.broadcast(tail)  
Ok.stream(sharedTail).withHeaders(CONTENT_TYPE -&gt; &quot;text/plain&quot;) // Play framework  
  
val searchResult: Enumerator[String] = dictionaryEnumerator &amp;&gt; grep(&quot;able&quot;) &amp;&gt; aStringChunker  
  
Ok.stream(Enumerator.fromFile(&quot;image.jpg&quot;) &amp;&gt; convert).withHeaders(CONTENT_TYPE -&gt; &quot;image/png&quot;)  
  
Enumerator.fromFile(&quot;video.avi&quot;) &amp;&gt; ffmpeg &amp;&gt; ...
</code></pre>
<h3 id="process">Process</h3>
<p>CLI uses <a href="http://www.scala-lang.org/api/current/index.html#scala.sys.process.package">scala.sys.process</a><br>and create a Process instance for each UNIX command.</p>
<p>A CLI process is terminates when:</p>
<ul>
<li>  The command has end.</li>
<li>  stdin and stdout is terminated.</li>
<li>  <a href="http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Done$">Done</a> is reached (for <a href="http://gre.github.io/playCLI-examples/api/#enumerate(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumerator%5BArray%5BByte%5D%5D">enumerate</a> and <a href="#pipe(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumeratee%5BArray%5BByte%5D,Array%5BByte%5D%5D">pipe</a>).</li>
<li>  <a href="http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Input$$EOF$">EOF</a> is sent (for <a href="http://gre.github.io/playCLI-examples/api/#pipe(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumeratee%5BArray%5BByte%5D,Array%5BByte%5D%5D">pipe</a> and <a href="http://gre.github.io/playCLI-examples/api/#consume(command:scala.sys.process.ProcessBuilder,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Iteratee%5BArray%5BByte%5D,Int%5D">consume</a>).</li>
</ul>
<p>CLI still waits for the Process to terminate by asking the exit code (via <code>Process.exitCode()</code>).<br>If the process is never ending during this phase, it will be killed when <code>terminateTimeout</code> is reached.</p>
<p>PS: Thanks to implicits, you can simply give a String or a Seq to the CLI.* functions a <code>ProcessBuilder</code>.</p>
<h3 id="mutability">Mutability</h3>
<p><a href="http://gre.github.io/playCLI-examples/api/#enumerate(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumerator%5BArray%5BByte%5D%5D">enumerate</a> and <a href="http://gre.github.io/playCLI-examples/api/#pipe(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumeratee%5BArray%5BByte%5D,Array%5BByte%5D%5D">pipe</a> are <strong>immutable</strong>, in other words, re-usable<br>(each result can be stored in a val and applied multiple times).<br><strong>A new process is created for each re-use</strong>.</p>
<p><a href="http://gre.github.io/playCLI-examples/api/#consume(command:scala.sys.process.ProcessBuilder,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Iteratee%5BArray%5BByte%5D,Int%5D">consume</a> is <strong>mutable</strong>, it should not be used multiple times: it targets side effect command.</p>
<h3 id="logs">Logs</h3>
<p>A “CLI” logger (logback) is used to log different information in different log levels:</p>
<ul>
<li>  <strong>ERROR</strong> would mean a CLI error (not used yet).</li>
<li>  <strong>INFO</strong> used for the process’ stdout output of a <a href="http://gre.github.io/playCLI-examples/api/#consume(command:scala.sys.process.ProcessBuilder,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Iteratee%5BArray%5BByte%5D,Int%5D">CLI.consume</a>.</li>
<li>  <strong>DEBUG</strong> used for the process life cycle (process creation, process termination, exit code).</li>
<li>  <strong>WARN</strong> used for the process’ stderr output.</li>
<li>  <strong>TRACE</strong> used for low level information (IO read/write). </li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>I’m eager to see what you guys can do with such an API, it enables a lot of possibility, I’m especially thinking about multimedia purposes (using powerful commands like: ImageMagick, ffmpeg, sox,…).</p>
</div><footer><div class="jsx-2519965637 block"><img src="http://greweb.me/logo.svg" width="100" class="jsx-2519965637"/><div class="jsx-2519965637 right"><div class="jsx-2519965637 description">As a generative plotter artist, I use code to create art (creative coding), draw with fountain pens on robots (plotting), and explore the boundaries of abstract art using algorithms in pursuit of increasingly realistic imagery. I do not produce prints; instead, I create unique &#x27;plots&#x27; - physical works of art that are truly one-of-a-kind.</div><div class="jsx-2519965637 social"><a href="https://twitter.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitter.svg" class="jsx-2519965637"/></a><a href="https://instagram.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/instagram.svg" class="jsx-2519965637"/></a><a href="https://twitch.tv/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitch.svg" class="jsx-2519965637"/></a><a href="https://github.com/gre" class="jsx-2519965637"><img alt="" src="/icons/github.svg" class="jsx-2519965637"/></a><a href="https://opensea.io/greweb?tab=created" class="jsx-2519965637"><img alt="" src="/icons/eth.svg" class="jsx-2519965637"/></a><a href="https://fxhash.xyz/u/greweb" class="jsx-2519965637"><img alt="" src="/icons/tz.svg" class="jsx-2519965637"/></a><a href="https://greweb.itch.io" class="jsx-2519965637"><img alt="" src="/icons/iconmonstr-gamepad-3.svg" class="jsx-2519965637"/></a></div></div></div></footer></article></div></div></div><script>hljs.highlightAll();</script></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"2013-01-30-playcli-play-iteratees-unix-pipe","year":"2013","month":"01","day":"30","slug":"playcli-play-iteratees-unix-pipe","content":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eTL;DR.\u003c/strong\u003e PlayCLI is a new \u003ca href=\"http://scala-lang.org\"\u003eScala\u003c/a\u003e library to work with UNIX commands and \u003ca href=\"http://www.playframework.org/documentation/2.0/Iteratees\"\u003ePlay-Iteratees\u003c/a\u003e (a scala implementation of Iteratees facilitating the handling of data streams reactively). Here’s an overview:\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ciframe src=\"http://gre.github.io/playCLI-examples/embedder.html#index.html\" frameborder=\"0\" width=\"550\" height=\"452\"\u003e\u003c/iframe\u003e\n\n\u003ch2 id=\"links\"\u003eLinks\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e  \u003ca href=\"http://gre.github.io/playCLI-examples/api\"\u003eThe scala API\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e  \u003ca href=\"http://github.com/gre/playCLI\"\u003ePlayCLI source code (Github)\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e  \u003ca href=\"http://github.com/gre/playCLI-examples\"\u003ePlayCLI Examples application (Github)\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"sbt\"\u003eSBT\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-scala\"\u003e\u0026quot;fr.greweb\u0026quot; %% \u0026quot;playcli\u0026quot; % \u0026quot;0.1\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!--more--\u003e\n\n\u003ch2 id=\"why-playcli\"\u003eWhy PlayCLI\u003c/h2\u003e\n\u003cp\u003eAfter having made \u003ca href=\"/2012/08/zound-a-playframework-2-audio-streaming-experiment-using-iteratees/\"\u003eZound\u003c/a\u003e in a HackDay (an experiment to generate an audio stream with playframework iteratees and through the WAVE format), I figured out this was going to be hard to make it work with multiple audio format: \u003cem\u003etell me if I’m wrong but\u003c/em\u003e, there are not so much audio libraries in Java/Scala, or most of them does not support stream handling (and not reactively), and it was going to be crazy to re-implement everything in Scala (both in term of cost and performance).\u003c/p\u003e\n\u003cp\u003eBesides, \u003cstrong\u003eUNIX has plenty of tools\u003c/strong\u003e to do this and:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e they are \u003cstrong\u003ecomplete\u003c/strong\u003e and provide a lot of options\u003c/li\u003e\n\u003cli\u003e they are \u003cstrong\u003eeasy to use\u003c/strong\u003e (see how Bash is powerful as a consequence)\u003c/li\u003e\n\u003cli\u003e Most of them \u003cstrong\u003esupport streams\u003c/strong\u003e out of the box (via stdin / stdout)\u003c/li\u003e\n\u003cli\u003e They are very \u003cstrong\u003eefficient\u003c/strong\u003e (written in C / assembly)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSo why not re-use them from our reactive code?\u003c/p\u003e\n\u003ch3 id=\"similarities-with-unix-pipes\"\u003eSimilarities with UNIX pipes\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTake the expressivity of UNIX pipes, bring the power of Scala, mix it with Play Framework and you got a powerful framework for handling real-time and web streaming.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePlay Iteratees are an elegant \u0026amp; powerful way to handle streams reactively, and I’ve actually always understood them like UNIX pipes, you have the same reactive code style: linearized declarative way of handling streams.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBash:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecat words.txt | grep $word \u0026gt; result.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eScala:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-scala\"\u003eEnumerator.fromFile(\u0026quot;words.txt\u0026quot;) \u0026amp;\u0026gt;   \n  splitByNl \u0026amp;\u0026gt; // split a stream of Array[Byte] into stream of String (not impl here)  \n  Enumeratee.filter(_.containsSlice(word))  |\u0026gt;\u0026gt;\u0026gt;   \n  fileWriter // consume the steam while storing in a file (not impl here)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor if you prefer the “without symbol” version:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-scala\"\u003eEnumerator.fromFile(\u0026quot;words.txt\u0026quot;).  \n  through splitByNl.  \n  through Enumeratee.filter(_.containsSlice(word)).  \n  run fileWriter\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, It’s biased to say Iteratees are only UNIX pipes, they are more than that, but I’m not going to extend on that subject, they are at least statically typed and safe (it’s more than just a stream of bytes, see \u003ca href=\"http://mandubian.com/2012/08/27/understanding-play2-iteratees-for-normal-humans/\"\u003ethis article\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eSo if Iteratees are at least UNIX pipes, why can’t we use Unix pipes from iteratees?\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePlayCLI provides a bridge to use scala.sys.Process with play-iteratees.\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"more-about-playcli\"\u003eMore about PlayCLI\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003e(this is a copy of the API documentation)\u003c/em\u003e\u003c/p\u003e\n\u003ch3 id=\"overview\"\u003eOverview\u003c/h3\u003e\n\u003cp\u003eDepending on your needs, you can \u003cstrong\u003eEnumerate / Pipe / Consume\u003c/strong\u003e an UNIX command:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/playCLI-examples/api/#enumerate(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumerator%5BArray%5BByte%5D%5D\"\u003eCLI.enumerate\u003c/a\u003e is a way to create a stream from a command which \u003cstrong\u003egenerates output\u003c/strong\u003e\u003cbr\u003e(it creates an \u003ca href=\"http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Enumerator\"\u003eEnumerator\u003c/a\u003e[Array[Byte]] )\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/playCLI-examples/api/#pipe(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumeratee%5BArray%5BByte%5D,Array%5BByte%5D%5D\"\u003eCLI.pipe\u003c/a\u003e is a way to pipe a command which \u003cstrong\u003econsumes input and generates output\u003c/strong\u003e\u003cbr\u003e(it creates an \u003ca href=\"http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Enumeratee\"\u003eEnumeratee\u003c/a\u003e[Array[Byte],Array[Byte]])\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/playCLI-examples/api/#consume(command:scala.sys.process.ProcessBuilder,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Iteratee%5BArray%5BByte%5D,Int%5D\"\u003eCLI.consume\u003c/a\u003e creates a process which \u003cstrong\u003econsumes a stream\u003c/strong\u003e – useful for side effect commands\u003cbr\u003e(it creates an \u003ca href=\"http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Iteratee\"\u003eIteratee\u003c/a\u003e[Array[Byte],Int])\u003c/p\u003e\n\u003ch4 id=\"examples\"\u003eExamples\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-scala\"\u003eimport playcli._  \nimport scala.sys.process._  \n  \n// Some CLI use cases  \nval tail = CLI.enumerate(\u0026quot;tail -f /var/log/nginx/access.log\u0026quot;)  \nval grep = (word: String) =\u0026gt; CLI.pipe(Seq(\u0026quot;grep\u0026quot;, word))  \nval ffmpeg = CLI.pipe(\u0026quot;ffmpeg -i pipe:0 ... pipe:1\u0026quot;) // video processing  \nval convert = CLI.pipe(\u0026quot;convert - -colors 64 png:-\u0026quot;) // color quantization  \n  \n// Some usage examples  \nval sharedTail = Concurrent.broadcast(tail)  \nOk.stream(sharedTail).withHeaders(CONTENT_TYPE -\u0026gt; \u0026quot;text/plain\u0026quot;) // Play framework  \n  \nval searchResult: Enumerator[String] = dictionaryEnumerator \u0026amp;\u0026gt; grep(\u0026quot;able\u0026quot;) \u0026amp;\u0026gt; aStringChunker  \n  \nOk.stream(Enumerator.fromFile(\u0026quot;image.jpg\u0026quot;) \u0026amp;\u0026gt; convert).withHeaders(CONTENT_TYPE -\u0026gt; \u0026quot;image/png\u0026quot;)  \n  \nEnumerator.fromFile(\u0026quot;video.avi\u0026quot;) \u0026amp;\u0026gt; ffmpeg \u0026amp;\u0026gt; ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"process\"\u003eProcess\u003c/h3\u003e\n\u003cp\u003eCLI uses \u003ca href=\"http://www.scala-lang.org/api/current/index.html#scala.sys.process.package\"\u003escala.sys.process\u003c/a\u003e\u003cbr\u003eand create a Process instance for each UNIX command.\u003c/p\u003e\n\u003cp\u003eA CLI process is terminates when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e  The command has end.\u003c/li\u003e\n\u003cli\u003e  stdin and stdout is terminated.\u003c/li\u003e\n\u003cli\u003e  \u003ca href=\"http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Done$\"\u003eDone\u003c/a\u003e is reached (for \u003ca href=\"http://gre.github.io/playCLI-examples/api/#enumerate(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumerator%5BArray%5BByte%5D%5D\"\u003eenumerate\u003c/a\u003e and \u003ca href=\"#pipe(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumeratee%5BArray%5BByte%5D,Array%5BByte%5D%5D\"\u003epipe\u003c/a\u003e).\u003c/li\u003e\n\u003cli\u003e  \u003ca href=\"http://www.playframework.org/documentation/api/2.1-RC1/scala/index.html#play.api.libs.iteratee.Input$$EOF$\"\u003eEOF\u003c/a\u003e is sent (for \u003ca href=\"http://gre.github.io/playCLI-examples/api/#pipe(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumeratee%5BArray%5BByte%5D,Array%5BByte%5D%5D\"\u003epipe\u003c/a\u003e and \u003ca href=\"http://gre.github.io/playCLI-examples/api/#consume(command:scala.sys.process.ProcessBuilder,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Iteratee%5BArray%5BByte%5D,Int%5D\"\u003econsume\u003c/a\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCLI still waits for the Process to terminate by asking the exit code (via \u003ccode\u003eProcess.exitCode()\u003c/code\u003e).\u003cbr\u003eIf the process is never ending during this phase, it will be killed when \u003ccode\u003eterminateTimeout\u003c/code\u003e is reached.\u003c/p\u003e\n\u003cp\u003ePS: Thanks to implicits, you can simply give a String or a Seq to the CLI.* functions a \u003ccode\u003eProcessBuilder\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"mutability\"\u003eMutability\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/playCLI-examples/api/#enumerate(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumerator%5BArray%5BByte%5D%5D\"\u003eenumerate\u003c/a\u003e and \u003ca href=\"http://gre.github.io/playCLI-examples/api/#pipe(command:scala.sys.process.ProcessBuilder,chunkSize:Int,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Enumeratee%5BArray%5BByte%5D,Array%5BByte%5D%5D\"\u003epipe\u003c/a\u003e are \u003cstrong\u003eimmutable\u003c/strong\u003e, in other words, re-usable\u003cbr\u003e(each result can be stored in a val and applied multiple times).\u003cbr\u003e\u003cstrong\u003eA new process is created for each re-use\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/playCLI-examples/api/#consume(command:scala.sys.process.ProcessBuilder,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Iteratee%5BArray%5BByte%5D,Int%5D\"\u003econsume\u003c/a\u003e is \u003cstrong\u003emutable\u003c/strong\u003e, it should not be used multiple times: it targets side effect command.\u003c/p\u003e\n\u003ch3 id=\"logs\"\u003eLogs\u003c/h3\u003e\n\u003cp\u003eA “CLI” logger (logback) is used to log different information in different log levels:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e  \u003cstrong\u003eERROR\u003c/strong\u003e would mean a CLI error (not used yet).\u003c/li\u003e\n\u003cli\u003e  \u003cstrong\u003eINFO\u003c/strong\u003e used for the process’ stdout output of a \u003ca href=\"http://gre.github.io/playCLI-examples/api/#consume(command:scala.sys.process.ProcessBuilder,terminateTimeout:Long)(implicitec:scala.concurrent.ExecutionContext):play.api.libs.iteratee.Iteratee%5BArray%5BByte%5D,Int%5D\"\u003eCLI.consume\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e  \u003cstrong\u003eDEBUG\u003c/strong\u003e used for the process life cycle (process creation, process termination, exit code).\u003c/li\u003e\n\u003cli\u003e  \u003cstrong\u003eWARN\u003c/strong\u003e used for the process’ stderr output.\u003c/li\u003e\n\u003cli\u003e  \u003cstrong\u003eTRACE\u003c/strong\u003e used for low level information (IO read/write). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eI’m eager to see what you guys can do with such an API, it enables a lot of possibility, I’m especially thinking about multimedia purposes (using powerful commands like: ImageMagick, ffmpeg, sox,…).\u003c/p\u003e\n","data":{"title":"PlayCLI: Play Iteratees + UNIX pipe","description":"PlayCLI is a new Scala library to work with UNIX commands and Play-Iteratees (a scala implementation of Iteratees facilitating the handling of data streams reactively)","author":"Gaetan","layout":"post","permalink":"/2013/01/playcli-play-iteratees-unix-pipe/","tags":["iteratee","playframework","reactive","unix","library"]}},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2013","month":"01","slug":"playcli-play-iteratees-unix-pipe"},"buildId":"g5cBXMQf8InWNdasEbAj2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>