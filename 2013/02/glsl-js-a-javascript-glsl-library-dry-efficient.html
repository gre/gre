<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="author" content="Gaëtan Renaudeau"/><meta name="description" content="WebGL is super powerful and efficient. This library abuses this power for efficient 2D."/><meta name="keywords" content="gamedev, javascript, library, GLSL, WebGL"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@greweb"/><meta name="twitter:title" content="glsl.js, a Javascript + GLSL library = DRY &amp; efficient"/><meta name="og:title" content="glsl.js, a Javascript + GLSL library = DRY &amp; efficient"/><meta name="twitter:description" content="WebGL is super powerful and efficient. This library abuses this power for efficient 2D."/><meta name="twitter:creator" content="@greweb"/><meta name="og:image" content="http://greweb.me//images/2013/02/glsl_mario.jpg"/><meta name="twitter:image" content="http://greweb.me//images/2013/02/glsl_mario.jpg"/><link rel="image_src" href="http://greweb.me//images/2013/02/glsl_mario.jpg"/><title>@greweb - glsl.js, a Javascript + GLSL library = DRY &amp; efficient</title><link href="http://fonts.googleapis.com/css?family=Fredericka+the+Great|Arapey|Roboto:400,700,400italic" rel="stylesheet" type="text/css"/><link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/styles/default.min.css"/><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/highlight.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/javascript.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/cpp.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/glsl.min.js"></script><link rel="stylesheet" href="/style/main.css"/><meta name="next-head-count" content="25"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-682ed58dee9e3e5c50ef.js" defer=""></script><script src="/_next/static/chunks/framework-c93ed74a065331c4bd75.js" defer=""></script><script src="/_next/static/chunks/main-005750ed97c879f2d59b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-092526a60f8cb7d1b3d6.js" defer=""></script><script src="/_next/static/chunks/988-83f401159b53b3fa4628.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-0f67605ef98ac8184736.js" defer=""></script><script src="/_next/static/DxmiPwyvbaK9NSDP222P8/_buildManifest.js" defer=""></script><script src="/_next/static/DxmiPwyvbaK9NSDP222P8/_ssgManifest.js" defer=""></script><style id="__jsx-2519965637">.block.jsx-2519965637{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.block.jsx-2519965637 .right.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637{margin-top:10px;}.block.jsx-2519965637 .social.jsx-2519965637 a.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637 img.jsx-2519965637{height:20px;}</style><style id="__jsx-3621368397">.container.jsx-3621368397{min-height:100vh;padding:0 0.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><style id="__jsx-3469673304">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto, Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue, sans-serif;}*{box-sizing:border-box;}a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a:hover,a:active{-webkit-text-decoration:underline;text-decoration:underline;}</style></head><body><div id="__next"><div class="jsx-3621368397 container"><div id="container"><div id="main"><div id="content"><article><header><h1><a href="/">glsl.js, a Javascript + GLSL library = DRY &amp; efficient</a></h1><time class="date" dateTime="2013-02-11">2013-02-11</time><span class="tags"><a class="tag">gamedev</a><a class="tag">javascript</a><a class="tag">library</a><a class="tag">GLSL</a><a class="tag">WebGL</a></span></header><div class="entry-content"><p><a href="http://gre.github.io/glsl.js/examples/balls"><img src="/images/2013/02/glsl_mario.jpg" alt="glsl_mario"></a></p>
<p><strong>TL;DR. WebGL is super powerful and efficient. This library abuses this power for efficient 2D.</strong></p>
<p>glsl.js is a subset of a WebGL library which focuses on making the GLSL (OpenGL Shading Language) easy and accessible for vizualisation and game purposes (2D or 3D).</p>
<ul>
<li><strong><a href="http://gre.github.io/glsl.js/examples/balls">Bouncing balls example video tutorial</a></strong></li>
<li><a href="http://gre.github.io/glsl.js/examples">Open other examples</a></li>
<li><a href="http://gre.github.io/glsl.js/docs">API Documentation</a></li>
<li><a href="http://github.com/gre/glsl.js">Fork me on Github</a></li>
<li><a href="http://gre.github.io/glsl.js/test">Unit tests</a></li>
</ul>
<p><a href="http://gre.github.io/glsl.js/examples/pong/"><img src="/images/2013/02/glsl_pong.jpg" alt="glsl_pong"></a></p>
<h2 id="why">Why?</h2>
<p><strong>WebGL is a very low level and stateful API</strong>. Actually the WebGL API <strong>is</strong> the OpenGL API.</p>
<p>I wanted to make a graphic library where you wouldn’t have to know about this API but still have access to the powerful OpenGL Shading Language called GLSL.</p>
<p>Do you know <a href="http://glsl.heroku.com">glsl.heroku.com</a>? It’s a cool platform for demoscene where you can experiment some nice effects in GLSL. My library extends this concept of rendering in one whole fragment shader (which takes the plain canvas) but also provides a way to inject your own Javascript variables.</p>
<h3 id="dry">DRY</h3>
<p><strong>WebGL is not DRY at all</strong>, you always have to repeat yourself both on the GLSL and on the Javascript part (especially for synchronizing variables).<br>Worse than that, you have to know in your Javascript code what are the GLSL types of every variable to synchronize.</p>
<p>How boring is that:</p>
<pre><code class="language-javascript">// Synchronizing the new values of 2 variables in pure WebGL.

var myInt = 1;
var myIntLocation = gl.getUniformLocation(program, &quot;myInt&quot;);
myInt;
gl.uniform1i(myFloatLocation, myInt); // 1i means one integer

var myVector2 = { x: 1.3, y: 2.4 };
var myVector2Location = gl.getUniformLocation(program, &quot;myVector2&quot;);
gl.uniform2f(myVector2Location, myVector2.x, myVector2.y); // 2f means float[2]
</code></pre>
<p><strong>glsl.js</strong> provides a DRY and simple way to synchronize Javascript variables.</p>
<p>First, the library will handle for you the UniformLocations.</p>
<p>More important, and unlike the WebGL API and many WebGL libraries, <strong>you will never have to define the type of your variables from the Javascript with glsl.js!</strong> You just define it once in your shader!</p>
<p>How it works behind is the framework will statically parse your GLSL and infer types to use for the synchronization. The right <code>gl.uniform*</code> function is called by Javascript reflection.</p>
<p>It now simply becomes:</p>
<pre><code class="language-javascript">// Set the values of 2 variables in glsl.js
this.set(&quot;myInt&quot;, 1);
this.set(&quot;myVector2&quot;, { x: 1.3, y: 2.4 });
// ... see also this.sync() and this.syncAll()
</code></pre>
<!--more-->

<p>More technically, <strong>glsl.js</strong> is a subset* of a WebGL library which focus on <strong>making the GLSL (OpenGL Shading Language) easy and accessible</strong> for vizualisation and game purposes (2D or 3D).</p>
<blockquote>
<p>* Subset, because we only focus on using a <em>fragment shader</em> (the <em>vertex shader</em> is static and take the full canvas size), But don’t worry, you have a long way to go with just one <em>fragment shader</em>.</p>
</blockquote>
<p>The concept is to split the <strong>rendering part in a GLSL fragment</strong> from the <strong>logic part in Javascript</strong> of your app/game. Both part are linked by <strong>a set of variables</strong> (the state of your app/game).</p>
<p><img src="https://f.cloud.github.com/assets/211411/133026/5ed79ff8-709b-11e2-85dd-60332f74dc31.png" alt="schema"></p>
<p><strong>glsl.js</strong> aims to abstract every GL functions so you don’t have to learn any OpenGL API.<br>What you only need to care about is the logic in Javascript and the rendering in GLSL.</p>
<p>By design, <strong>you can’t mix logic and render part</strong>, this approach really helps to focus on essential things separately.</p>
<h3 id="efficiency">Efficiency</h3>
<p>Basically, this design is efficient because the Javascript logic will take some CPU while the rendering will take the graphic card.</p>
<p>Today, WebGL is widely supported on modern desktop browsers. It’s not yet the case on mobile and tablet.</p>
<p>However, using Chrome Beta, I’m able to run my HTML5 game at 60fps on my Nexus 4, which is quite promising for the future.</p>
<iframe width="640" height="360" src="http://www.youtube.com/embed/EzTCdjpdTfk?feature=player_embedded" frameborder="0" allowfullscreen></iframe>

<p><em>Enough talking, let’s see some examples now…</em></p>
<h3 id="hello-world-example"><a href="#hello-world-example"></a>Hello World Example</h3>
<p>Here is an Hello World example. For more examples, see <a href="http://gre.github.io/glsl.js/examples">/examples</a>.</p>
<pre><code class="language-html">&lt;canvas id=&quot;viewport&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;
&lt;script id=&quot;fragment&quot; type=&quot;x-shader/x-fragment&quot;&gt;
  #ifdef GL_ES
  precision mediump float;
  #endif
  uniform float time;
  uniform vec2 resolution;
  void main (void) {
    vec2 p = ( gl_FragCoord.xy / resolution.xy );
    gl_FragColor = vec4(p.x, p.y, (1.+cos(time))/2., 1.0);
  }
&lt;/script&gt;
&lt;script src=&quot;../../glsl.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var glsl = Glsl({
    canvas: document.getElementById(&quot;viewport&quot;),
    fragment: document.getElementById(&quot;fragment&quot;).textContent,
    variables: {
      time: 0, // The time in ms
    },
    update: function (time, delta) {
      this.set(&quot;time&quot;, time);
    },
  }).start();
&lt;/script&gt;
</code></pre>
<p><a href="http://gre.github.io/glsl.js/examples/helloworld"><img src="https://f.cloud.github.com/assets/211411/132729/e702c2b4-7090-11e2-8904-49e904e6c5a2.png" alt="screenshot"></a></p>
<h3 id="glsl-opengl-shading-language"><a href="#glsl-opengl-shading-language"></a>GLSL: OpenGL Shading Language</h3>
<blockquote>
<p>GLSL is a high-level shading language based on the syntax of the C programming language. (Wikipedia)</p>
</blockquote>
<p>GLSL gives a very different way of thinking the rendering: basically, in a main function, you have to <strong>set the color (<code>gl_FragColor</code>) of a pixel for a given position (<code>gl_FragCoord</code>)</strong>.</p>
<p>As a nice side effect, GLSL is vectorial by design: it can be stretch to any dimension.</p>
<p>GLSL is efficient because it is compiled to the graphic card.</p>
<p>GLSL provides an interesting collection of <strong>types</strong> (e.g. <code>int</code>, <code>float</code>, <code>vec2</code>, <code>vec3</code>, <code>mat3</code>, <code>sampler2D</code>,… and also arrays of these types) and <strong>functions</strong> (e.g. <code>cos</code>, <code>smoothstep</code>, …).</p>
<p><a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">Here is a good reference for this</a>.</p>
<p>You can also deeply explore the awesome collection of <a href="http://glsl.heroku.com/">glsl.heroku.com</a>. Any of glsl.heroku.com examples are compatible with <strong>glsl.js</strong> if you add some required variables (*time*, <em>mouse</em>, …).</p>
<h3 id="appgame-logic"><a href="#appgame-logic"></a>App/Game Logic</h3>
<p>You must give to Glsl a <code>canvas</code> (DOM element of a canvas), a <code>fragment</code> (the GLSL fragment code), the <code>variables</code> set, and the <code>update</code> function.</p>
<p>Then you can start/stop the rendering via method (<code>.start()</code> and <code>.stop()</code>).</p>
<p>The <code>update</code> function is called as soon as possible by the library. It is called in a <code>requestAnimationFrame</code> context.</p>
<p>You must define all variables shared by both logic and render part in a Javascript object <code>{varname: value}</code>.<br>Variables must match your GLSL uniform variables. Every time you update your variables and you want to synchronize them with the GLSL you have to manually call the <code>sync</code> function by giving all variables name to synchronize.</p>
<p><strong>Exemple:</strong></p>
<pre><code class="language-javascript">Glsl({
  canvas: canvas,
  fragment: fragCode,
  variables: {
    time: , // The time in seconds
    random1:
  },
  update: function (time, delta) {
    this.set(&quot;time&quot;, time);
    this.set(&quot;random1&quot;, Math.random());
  }
}).start();
</code></pre>
<p><strong>Note:</strong> <em>under the hood, a type environment of uniform variables is inferred by parsing your GLSL code.</em></p>
<h3 id="using-arrays"><a href="#using-arrays"></a>Using arrays</h3>
<p>Hopefully, GLSL also supports arrays. You can actually bind a Javascript array to a GLSL uniform variable.</p>
<p><strong>Example:</strong></p>
<p>In GLSL,</p>
<pre><code class="language-glsl">uniform float tenfloats[10];
</code></pre>
<p>In Javascript,</p>
<pre><code class="language-javascript">var glsl = Glsl({
  ...
  variable: {
    tenfloats: new Float32Array(10)
  },
  update: function () {
    this.tenfloats[3] = Math.random();
    this.sync(&quot;tenfloats&quot;);
  }
}).start();
</code></pre>
<p>Alternatively, you can still use a classical javascript Array (but native Javascript arrays are prefered because more efficient).</p>
<p>Use <code>Int32Array</code> for <code>int[]</code> and <code>bool[]</code>.</p>
<p>Vector arrays are also possible. In Javascript, you will have to give a linearized array.<br>For instance,<br>a <code>vec2[2]</code> will be <code>[vec2(1.0, 2.0), vec2(3.0, 4.0)]</code> if <code>Float32Array(1.0, 2.0, 3.0, 4.0)</code> is used.</p>
<h3 id="using-objects"><a href="#using-objects"></a>Using objects</h3>
<p>Even more interesting now, you can synchronize a whole object into the GLSL world. This is very interesting for Object-Oriented approach.</p>
<p><strong>Example:</strong></p>
<p>In GLSL,</p>
<pre><code class="language-glsl">struct Circle {
  vec2 center;
  float radius;
}
uniform Circle c1;
bool inCircle (vec2 p, Circle c) {
  vec2 ratio = resolution/resolution.x;
  return distance(p*ratio, c.center*ratio) &lt; c.radius;
}
void main (void) {
  vec2 p = ( gl_FragCoord.xy / resolution.xy );
  if (inCircle(p, c1))
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
  else
    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
}
</code></pre>
<p>In Javascript,</p>
<pre><code class="language-javascript">function Circle (x, y, radius) {
  this.center = { x: x, y: y };
  this.radius = radius;
  this.originalRadius = radius; // not visible by GLSL
}
Circle.prototype.update = function () {
  this.radius = this.originalRadius Math.sin(Date.now()/100);
}
var c1 = new Circle(0.5, 0.5, 0.1);
Glsl({
  ...
  variable: {
    c1: c1
  },
  update: function (time, delta) {
    c1.update();
    this.sync(&quot;c1&quot;);
  }
}).start();
</code></pre>
<p>structs inside structs are also supported:</p>
<pre><code class="language-glsl">struct Circle {
  vec2 center;
  float radius;
}
struct Player {
  Circle circle;
  bool visible;
}
</code></pre>
<h3 id="using-arrays-of-objects"><a href="#using-arrays-of-objects"></a>Using Arrays of Objects</h3>
<p>The two previous chapters can be assemble!</p>
<p>Yes man, Array of JS object is possible!</p>
<pre><code class="language-glsl">uniform Circle circles[2];
// circles[0].radius
// …
</code></pre>
<pre><code class="language-javascript">Glsl({
  ...
  variable: {
    circles: [ new Circle(0.1, 0.1, 0.2), new Circle(0.2, 0.3, 0.2) ]
  },
  ...
}).start();
</code></pre>
<h3 id="using-images"><a href="#using-images"></a>Using images</h3>
<p>GLSL:</p>
<pre><code class="language-glsl">uniform sampler2D img;
</code></pre>
<p>Javascript:</p>
<pre><code class="language-javascript">var image = new Image();
img.src = &quot;foo.png&quot;;
var glsl = Glsl({
  ...
  variable: {
    img: image
  }
});
img.onload = function () {
  glsl.start();
}
</code></pre>
<p>Note: Using an image loader library can be a good idea.</p>
<p>In GLSL, you will need to use the texture lookup functions to access the image color for a given coordinate. E.g. <code>texture2D(img, coord)</code>. (see the <a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">specs</a>).</p>
<h4 id="see-also">See also</h4>
<p><a href="http://gre.github.io/glsl.js/examples/mario_sprites/">The mario_sprites example</a></p>
<h3 id="using-another-canvas"><a href="#using-another-canvas"></a>Using another canvas</h3>
<p><a href="http://gre.github.io/glsl.js/examples/canvas-text/"><img src="/images/2013/02/hello_world_text_glsl_js.png" alt="hello_world_text_glsl_js"></a></p>
<h3 id="using">Using</h3>
<p><a href="http://gre.github.io/glsl.js/examples/video/"><img src="/images/2013/02/glsl_js_video.png" alt="glsl_js_video"></a></p>
<h2 id="see-also-1">See also</h2>
<iframe width="480" height="360" src="http://www.youtube.com/embed/kxBkfy_8JEs" frameborder="0" allowfullscreen=""></iframe>
</div><footer><div class="jsx-2519965637 block"><img src="http://greweb.me/profile.jpg" width="100" class="jsx-2519965637"/><div class="jsx-2519965637 right"><div class="jsx-2519965637 description">creative coder experimenting with GLSL shaders, Rust, and fountain pens robot plots. infinite noise explorer.</div><div class="jsx-2519965637 social"><a href="https://twitter.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitter.svg" class="jsx-2519965637"/></a><a href="https://instagram.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/instagram.svg" class="jsx-2519965637"/></a><a href="https://github.com/gre" class="jsx-2519965637"><img alt="" src="/icons/github.svg" class="jsx-2519965637"/></a><a href="https://twitch.tv/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitch.svg" class="jsx-2519965637"/></a><a href="https://greweb.itch.io" class="jsx-2519965637"><img alt="" src="/icons/iconmonstr-gamepad-3.svg" class="jsx-2519965637"/></a><a href="https://hic.link/greweb" class="jsx-2519965637"><img alt="" src="/icons/hic.svg" class="jsx-2519965637"/></a></div></div></div></footer></article></div></div></div><script>hljs.highlightAll();</script></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"2013-02-11-glsl-js-a-javascript-glsl-library-dry-efficient","year":"2013","month":"02","day":"11","slug":"glsl-js-a-javascript-glsl-library-dry-efficient","content":"\u003cp\u003e\u003ca href=\"http://gre.github.io/glsl.js/examples/balls\"\u003e\u003cimg src=\"/images/2013/02/glsl_mario.jpg\" alt=\"glsl_mario\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTL;DR. WebGL is super powerful and efficient. This library abuses this power for efficient 2D.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eglsl.js is a subset of a WebGL library which focuses on making the GLSL (OpenGL Shading Language) easy and accessible for vizualisation and game purposes (2D or 3D).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"http://gre.github.io/glsl.js/examples/balls\"\u003eBouncing balls example video tutorial\u003c/a\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://gre.github.io/glsl.js/examples\"\u003eOpen other examples\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://gre.github.io/glsl.js/docs\"\u003eAPI Documentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://github.com/gre/glsl.js\"\u003eFork me on Github\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://gre.github.io/glsl.js/test\"\u003eUnit tests\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/glsl.js/examples/pong/\"\u003e\u003cimg src=\"/images/2013/02/glsl_pong.jpg\" alt=\"glsl_pong\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"why\"\u003eWhy?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eWebGL is a very low level and stateful API\u003c/strong\u003e. Actually the WebGL API \u003cstrong\u003eis\u003c/strong\u003e the OpenGL API.\u003c/p\u003e\n\u003cp\u003eI wanted to make a graphic library where you wouldn’t have to know about this API but still have access to the powerful OpenGL Shading Language called GLSL.\u003c/p\u003e\n\u003cp\u003eDo you know \u003ca href=\"http://glsl.heroku.com\"\u003eglsl.heroku.com\u003c/a\u003e? It’s a cool platform for demoscene where you can experiment some nice effects in GLSL. My library extends this concept of rendering in one whole fragment shader (which takes the plain canvas) but also provides a way to inject your own Javascript variables.\u003c/p\u003e\n\u003ch3 id=\"dry\"\u003eDRY\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eWebGL is not DRY at all\u003c/strong\u003e, you always have to repeat yourself both on the GLSL and on the Javascript part (especially for synchronizing variables).\u003cbr\u003eWorse than that, you have to know in your Javascript code what are the GLSL types of every variable to synchronize.\u003c/p\u003e\n\u003cp\u003eHow boring is that:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Synchronizing the new values of 2 variables in pure WebGL.\n\nvar myInt = 1;\nvar myIntLocation = gl.getUniformLocation(program, \u0026quot;myInt\u0026quot;);\nmyInt;\ngl.uniform1i(myFloatLocation, myInt); // 1i means one integer\n\nvar myVector2 = { x: 1.3, y: 2.4 };\nvar myVector2Location = gl.getUniformLocation(program, \u0026quot;myVector2\u0026quot;);\ngl.uniform2f(myVector2Location, myVector2.x, myVector2.y); // 2f means float[2]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eglsl.js\u003c/strong\u003e provides a DRY and simple way to synchronize Javascript variables.\u003c/p\u003e\n\u003cp\u003eFirst, the library will handle for you the UniformLocations.\u003c/p\u003e\n\u003cp\u003eMore important, and unlike the WebGL API and many WebGL libraries, \u003cstrong\u003eyou will never have to define the type of your variables from the Javascript with glsl.js!\u003c/strong\u003e You just define it once in your shader!\u003c/p\u003e\n\u003cp\u003eHow it works behind is the framework will statically parse your GLSL and infer types to use for the synchronization. The right \u003ccode\u003egl.uniform*\u003c/code\u003e function is called by Javascript reflection.\u003c/p\u003e\n\u003cp\u003eIt now simply becomes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Set the values of 2 variables in glsl.js\nthis.set(\u0026quot;myInt\u0026quot;, 1);\nthis.set(\u0026quot;myVector2\u0026quot;, { x: 1.3, y: 2.4 });\n// ... see also this.sync() and this.syncAll()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!--more--\u003e\n\n\u003cp\u003eMore technically, \u003cstrong\u003eglsl.js\u003c/strong\u003e is a subset* of a WebGL library which focus on \u003cstrong\u003emaking the GLSL (OpenGL Shading Language) easy and accessible\u003c/strong\u003e for vizualisation and game purposes (2D or 3D).\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e* Subset, because we only focus on using a \u003cem\u003efragment shader\u003c/em\u003e (the \u003cem\u003evertex shader\u003c/em\u003e is static and take the full canvas size), But don’t worry, you have a long way to go with just one \u003cem\u003efragment shader\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe concept is to split the \u003cstrong\u003erendering part in a GLSL fragment\u003c/strong\u003e from the \u003cstrong\u003elogic part in Javascript\u003c/strong\u003e of your app/game. Both part are linked by \u003cstrong\u003ea set of variables\u003c/strong\u003e (the state of your app/game).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://f.cloud.github.com/assets/211411/133026/5ed79ff8-709b-11e2-85dd-60332f74dc31.png\" alt=\"schema\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eglsl.js\u003c/strong\u003e aims to abstract every GL functions so you don’t have to learn any OpenGL API.\u003cbr\u003eWhat you only need to care about is the logic in Javascript and the rendering in GLSL.\u003c/p\u003e\n\u003cp\u003eBy design, \u003cstrong\u003eyou can’t mix logic and render part\u003c/strong\u003e, this approach really helps to focus on essential things separately.\u003c/p\u003e\n\u003ch3 id=\"efficiency\"\u003eEfficiency\u003c/h3\u003e\n\u003cp\u003eBasically, this design is efficient because the Javascript logic will take some CPU while the rendering will take the graphic card.\u003c/p\u003e\n\u003cp\u003eToday, WebGL is widely supported on modern desktop browsers. It’s not yet the case on mobile and tablet.\u003c/p\u003e\n\u003cp\u003eHowever, using Chrome Beta, I’m able to run my HTML5 game at 60fps on my Nexus 4, which is quite promising for the future.\u003c/p\u003e\n\u003ciframe width=\"640\" height=\"360\" src=\"http://www.youtube.com/embed/EzTCdjpdTfk?feature=player_embedded\" frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e\n\n\u003cp\u003e\u003cem\u003eEnough talking, let’s see some examples now…\u003c/em\u003e\u003c/p\u003e\n\u003ch3 id=\"hello-world-example\"\u003e\u003ca href=\"#hello-world-example\"\u003e\u003c/a\u003eHello World Example\u003c/h3\u003e\n\u003cp\u003eHere is an Hello World example. For more examples, see \u003ca href=\"http://gre.github.io/glsl.js/examples\"\u003e/examples\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;canvas id=\u0026quot;viewport\u0026quot; width=\u0026quot;600\u0026quot; height=\u0026quot;400\u0026quot;\u0026gt;\u0026lt;/canvas\u0026gt;\n\u0026lt;script id=\u0026quot;fragment\u0026quot; type=\u0026quot;x-shader/x-fragment\u0026quot;\u0026gt;\n  #ifdef GL_ES\n  precision mediump float;\n  #endif\n  uniform float time;\n  uniform vec2 resolution;\n  void main (void) {\n    vec2 p = ( gl_FragCoord.xy / resolution.xy );\n    gl_FragColor = vec4(p.x, p.y, (1.+cos(time))/2., 1.0);\n  }\n\u0026lt;/script\u0026gt;\n\u0026lt;script src=\u0026quot;../../glsl.js\u0026quot; type=\u0026quot;text/javascript\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt;\n  var glsl = Glsl({\n    canvas: document.getElementById(\u0026quot;viewport\u0026quot;),\n    fragment: document.getElementById(\u0026quot;fragment\u0026quot;).textContent,\n    variables: {\n      time: 0, // The time in ms\n    },\n    update: function (time, delta) {\n      this.set(\u0026quot;time\u0026quot;, time);\n    },\n  }).start();\n\u0026lt;/script\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/glsl.js/examples/helloworld\"\u003e\u003cimg src=\"https://f.cloud.github.com/assets/211411/132729/e702c2b4-7090-11e2-8904-49e904e6c5a2.png\" alt=\"screenshot\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"glsl-opengl-shading-language\"\u003e\u003ca href=\"#glsl-opengl-shading-language\"\u003e\u003c/a\u003eGLSL: OpenGL Shading Language\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGLSL is a high-level shading language based on the syntax of the C programming language. (Wikipedia)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eGLSL gives a very different way of thinking the rendering: basically, in a main function, you have to \u003cstrong\u003eset the color (\u003ccode\u003egl_FragColor\u003c/code\u003e) of a pixel for a given position (\u003ccode\u003egl_FragCoord\u003c/code\u003e)\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eAs a nice side effect, GLSL is vectorial by design: it can be stretch to any dimension.\u003c/p\u003e\n\u003cp\u003eGLSL is efficient because it is compiled to the graphic card.\u003c/p\u003e\n\u003cp\u003eGLSL provides an interesting collection of \u003cstrong\u003etypes\u003c/strong\u003e (e.g. \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003evec2\u003c/code\u003e, \u003ccode\u003evec3\u003c/code\u003e, \u003ccode\u003emat3\u003c/code\u003e, \u003ccode\u003esampler2D\u003c/code\u003e,… and also arrays of these types) and \u003cstrong\u003efunctions\u003c/strong\u003e (e.g. \u003ccode\u003ecos\u003c/code\u003e, \u003ccode\u003esmoothstep\u003c/code\u003e, …).\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\"\u003eHere is a good reference for this\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eYou can also deeply explore the awesome collection of \u003ca href=\"http://glsl.heroku.com/\"\u003eglsl.heroku.com\u003c/a\u003e. Any of glsl.heroku.com examples are compatible with \u003cstrong\u003eglsl.js\u003c/strong\u003e if you add some required variables (*time*, \u003cem\u003emouse\u003c/em\u003e, …).\u003c/p\u003e\n\u003ch3 id=\"appgame-logic\"\u003e\u003ca href=\"#appgame-logic\"\u003e\u003c/a\u003eApp/Game Logic\u003c/h3\u003e\n\u003cp\u003eYou must give to Glsl a \u003ccode\u003ecanvas\u003c/code\u003e (DOM element of a canvas), a \u003ccode\u003efragment\u003c/code\u003e (the GLSL fragment code), the \u003ccode\u003evariables\u003c/code\u003e set, and the \u003ccode\u003eupdate\u003c/code\u003e function.\u003c/p\u003e\n\u003cp\u003eThen you can start/stop the rendering via method (\u003ccode\u003e.start()\u003c/code\u003e and \u003ccode\u003e.stop()\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eupdate\u003c/code\u003e function is called as soon as possible by the library. It is called in a \u003ccode\u003erequestAnimationFrame\u003c/code\u003e context.\u003c/p\u003e\n\u003cp\u003eYou must define all variables shared by both logic and render part in a Javascript object \u003ccode\u003e{varname: value}\u003c/code\u003e.\u003cbr\u003eVariables must match your GLSL uniform variables. Every time you update your variables and you want to synchronize them with the GLSL you have to manually call the \u003ccode\u003esync\u003c/code\u003e function by giving all variables name to synchronize.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExemple:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eGlsl({\n  canvas: canvas,\n  fragment: fragCode,\n  variables: {\n    time: , // The time in seconds\n    random1:\n  },\n  update: function (time, delta) {\n    this.set(\u0026quot;time\u0026quot;, time);\n    this.set(\u0026quot;random1\u0026quot;, Math.random());\n  }\n}).start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e \u003cem\u003eunder the hood, a type environment of uniform variables is inferred by parsing your GLSL code.\u003c/em\u003e\u003c/p\u003e\n\u003ch3 id=\"using-arrays\"\u003e\u003ca href=\"#using-arrays\"\u003e\u003c/a\u003eUsing arrays\u003c/h3\u003e\n\u003cp\u003eHopefully, GLSL also supports arrays. You can actually bind a Javascript array to a GLSL uniform variable.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn GLSL,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003euniform float tenfloats[10];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn Javascript,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003evar glsl = Glsl({\n  ...\n  variable: {\n    tenfloats: new Float32Array(10)\n  },\n  update: function () {\n    this.tenfloats[3] = Math.random();\n    this.sync(\u0026quot;tenfloats\u0026quot;);\n  }\n}).start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlternatively, you can still use a classical javascript Array (but native Javascript arrays are prefered because more efficient).\u003c/p\u003e\n\u003cp\u003eUse \u003ccode\u003eInt32Array\u003c/code\u003e for \u003ccode\u003eint[]\u003c/code\u003e and \u003ccode\u003ebool[]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eVector arrays are also possible. In Javascript, you will have to give a linearized array.\u003cbr\u003eFor instance,\u003cbr\u003ea \u003ccode\u003evec2[2]\u003c/code\u003e will be \u003ccode\u003e[vec2(1.0, 2.0), vec2(3.0, 4.0)]\u003c/code\u003e if \u003ccode\u003eFloat32Array(1.0, 2.0, 3.0, 4.0)\u003c/code\u003e is used.\u003c/p\u003e\n\u003ch3 id=\"using-objects\"\u003e\u003ca href=\"#using-objects\"\u003e\u003c/a\u003eUsing objects\u003c/h3\u003e\n\u003cp\u003eEven more interesting now, you can synchronize a whole object into the GLSL world. This is very interesting for Object-Oriented approach.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eExample:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn GLSL,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003estruct Circle {\n  vec2 center;\n  float radius;\n}\nuniform Circle c1;\nbool inCircle (vec2 p, Circle c) {\n  vec2 ratio = resolution/resolution.x;\n  return distance(p*ratio, c.center*ratio) \u0026lt; c.radius;\n}\nvoid main (void) {\n  vec2 p = ( gl_FragCoord.xy / resolution.xy );\n  if (inCircle(p, c1))\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n  else\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn Javascript,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction Circle (x, y, radius) {\n  this.center = { x: x, y: y };\n  this.radius = radius;\n  this.originalRadius = radius; // not visible by GLSL\n}\nCircle.prototype.update = function () {\n  this.radius = this.originalRadius Math.sin(Date.now()/100);\n}\nvar c1 = new Circle(0.5, 0.5, 0.1);\nGlsl({\n  ...\n  variable: {\n    c1: c1\n  },\n  update: function (time, delta) {\n    c1.update();\n    this.sync(\u0026quot;c1\u0026quot;);\n  }\n}).start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003estructs inside structs are also supported:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003estruct Circle {\n  vec2 center;\n  float radius;\n}\nstruct Player {\n  Circle circle;\n  bool visible;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"using-arrays-of-objects\"\u003e\u003ca href=\"#using-arrays-of-objects\"\u003e\u003c/a\u003eUsing Arrays of Objects\u003c/h3\u003e\n\u003cp\u003eThe two previous chapters can be assemble!\u003c/p\u003e\n\u003cp\u003eYes man, Array of JS object is possible!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003euniform Circle circles[2];\n// circles[0].radius\n// …\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eGlsl({\n  ...\n  variable: {\n    circles: [ new Circle(0.1, 0.1, 0.2), new Circle(0.2, 0.3, 0.2) ]\n  },\n  ...\n}).start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"using-images\"\u003e\u003ca href=\"#using-images\"\u003e\u003c/a\u003eUsing images\u003c/h3\u003e\n\u003cp\u003eGLSL:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003euniform sampler2D img;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJavascript:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003evar image = new Image();\nimg.src = \u0026quot;foo.png\u0026quot;;\nvar glsl = Glsl({\n  ...\n  variable: {\n    img: image\n  }\n});\nimg.onload = function () {\n  glsl.start();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote: Using an image loader library can be a good idea.\u003c/p\u003e\n\u003cp\u003eIn GLSL, you will need to use the texture lookup functions to access the image color for a given coordinate. E.g. \u003ccode\u003etexture2D(img, coord)\u003c/code\u003e. (see the \u003ca href=\"http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\"\u003especs\u003c/a\u003e).\u003c/p\u003e\n\u003ch4 id=\"see-also\"\u003eSee also\u003c/h4\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/glsl.js/examples/mario_sprites/\"\u003eThe mario_sprites example\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"using-another-canvas\"\u003e\u003ca href=\"#using-another-canvas\"\u003e\u003c/a\u003eUsing another canvas\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/glsl.js/examples/canvas-text/\"\u003e\u003cimg src=\"/images/2013/02/hello_world_text_glsl_js.png\" alt=\"hello_world_text_glsl_js\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"using\"\u003eUsing\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/glsl.js/examples/video/\"\u003e\u003cimg src=\"/images/2013/02/glsl_js_video.png\" alt=\"glsl_js_video\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"see-also-1\"\u003eSee also\u003c/h2\u003e\n\u003ciframe width=\"480\" height=\"360\" src=\"http://www.youtube.com/embed/kxBkfy_8JEs\" frameborder=\"0\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\n","data":{"title":"glsl.js, a Javascript + GLSL library = DRY \u0026 efficient","description":"WebGL is super powerful and efficient. This library abuses this power for efficient 2D.","thumbnail":"/images/2013/02/glsl_mario.jpg","author":"Gaetan","layout":"post","permalink":"/2013/02/glsl-js-a-javascript-glsl-library-dry-efficient/","tags":["gamedev","javascript","library","GLSL","WebGL"]}},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2013","month":"02","slug":"glsl-js-a-javascript-glsl-library-dry-efficient"},"buildId":"DxmiPwyvbaK9NSDP222P8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>