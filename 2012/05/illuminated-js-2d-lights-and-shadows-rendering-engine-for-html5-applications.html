<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="author" content="Gaëtan Renaudeau"/><meta name="description" content="Illuminated.js is designed to add some awesome effects to your existing applications. Adding a cool atmosphere for your applications and games can make the difference!"/><meta name="keywords" content="gamedev, canvas, javascript, library"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@greweb"/><meta name="twitter:title" content="Illuminated.js – 2D lights and shadows rendering engine for HTML5 applications"/><meta name="og:title" content="Illuminated.js – 2D lights and shadows rendering engine for HTML5 applications"/><meta name="twitter:description" content="Illuminated.js is designed to add some awesome effects to your existing applications. Adding a cool atmosphere for your applications and games can make the difference!"/><meta name="twitter:creator" content="@greweb"/><meta name="og:image" content="http://greweb.me//images/2012/05/illuminatedjs.jpg"/><meta name="twitter:image" content="http://greweb.me//images/2012/05/illuminatedjs.jpg"/><link rel="image_src" href="http://greweb.me//images/2012/05/illuminatedjs.jpg"/><title>@greweb - Illuminated.js – 2D lights and shadows rendering engine for HTML5 applications</title><link href="http://fonts.googleapis.com/css?family=Fredericka+the+Great|Arapey|Roboto:400,700,400italic" rel="stylesheet" type="text/css"/><link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/styles/default.min.css"/><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/highlight.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/javascript.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/cpp.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/glsl.min.js"></script><link rel="stylesheet" href="/style/main.css"/><meta name="next-head-count" content="25"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-381dbb3c33243b4920e6.js"></script><script src="/_next/static/chunks/webpack-17597d20e291f72b2439.js" defer=""></script><script src="/_next/static/chunks/framework-bdc1b4e5e48979e16d36.js" defer=""></script><script src="/_next/static/chunks/main-4ac108dd57980e4159e9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c981e0e3ce59f13eb8d0.js" defer=""></script><script src="/_next/static/chunks/5988-738c1ea5f97353b6463e.js" defer=""></script><script src="/_next/static/chunks/2242-4500be184fa490ea9cf2.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-18d367ef37e4735025ef.js" defer=""></script><script src="/_next/static/B95JjZeGO005JTlGuGHVX/_buildManifest.js" defer=""></script><script src="/_next/static/B95JjZeGO005JTlGuGHVX/_ssgManifest.js" defer=""></script><style id="__jsx-2519965637">.block.jsx-2519965637{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.block.jsx-2519965637 .right.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637{margin-top:10px;}.block.jsx-2519965637 .social.jsx-2519965637 a.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637 img.jsx-2519965637{height:20px;}</style><style id="__jsx-3621368397">.container.jsx-3621368397{min-height:100vh;padding:0 0.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><style id="__jsx-3469673304">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto, Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue, sans-serif;}*{box-sizing:border-box;}a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a:hover,a:active{-webkit-text-decoration:underline;text-decoration:underline;}</style></head><body><div id="__next"><div class="jsx-3621368397 container"><div id="container"><div id="main"><div id="content"><article><header><h1><a href="/">Illuminated.js – 2D lights and shadows rendering engine for HTML5 applications</a></h1><time class="date" dateTime="2012-05-10">2012-05-10</time><span class="tags"><a class="tag">gamedev</a><a class="tag">canvas</a><a class="tag">javascript</a><a class="tag">library</a></span></header><div class="entry-content"><p><a href="http://bit.ly/LZ2dq1"><img src="/images/2012/05/illuminatedjs.jpg" alt=""></a></p>
<p><a href="http://bit.ly/LZ2dq1">Click on the image to open it!</a></p>
<h2 id="wow-whats-this">Wow! what’s this?</h2>
<p>It’s a <strong>2D scene</strong> containing 2 <strong>lights</strong> and 13 different <strong>objects</strong> rendered in <strong>real-time</strong> by a <strong>Javascript library</strong> I made called <strong>Illuminated.js</strong>.</p>
<p>The library is designed to add some <strong>awesome effects to your existing applications</strong>. Adding <strong>a cool atmosphere for your applications and games</strong> can make the difference!</p>
<p><strong><a href="http://gre.github.io/illuminated.js">Try the editor</a></strong> and <strong><a href="http://github.com/gre/illuminated.js">Get the source code</a></strong>.</p>
<p>In this article, we will introduce the basic usages of <em>Illuminated.js</em> and APIs, and then explain how the engine works step-by-step.</p>
<ul>
<li><a href="/2012/05/illuminated-js-2d-lights-and-shadows-rendering-engine-for-html5-applications/#gettingstarted">API – Getting started</a></li>
<li><a href="/2012/05/illuminated-js-2d-lights-and-shadows-rendering-engine-for-html5-applications/#underthehood">Technical notes – how does it work?</a></li>
</ul>
<!--more-->

<h2 id="how-can-i-use-it">How can I use it?</h2>
<p>The library uses <a href="http://en.wikipedia.org/wiki/Canvas_element">HTML5 Canvas</a> to draw lights and shadows – so you can simply drop it straight into your existing Canvas applications: you just need to add some code in your render function and maintaining a binding between your application logic and the <em>Illuminated.js</em> objects.<br>Not using canvas? No worries! In theory, if you have an existing application or game made in full DOM, you could use <em>Illuminated.js</em> behind this, playing with z-index.</p>
<h2 id="-getting-started"><a id="gettingstarted"></a> Getting started</h2>
<h3 id="basic-concepts">Basic concepts</h3>
<p>All the classes of the package live in <code>window.illuminated</code>.</p>
<p>A <strong>Light</strong> describes a light emit source.<br>An <strong>OpaqueObject</strong> specifies an 2D object used by a Lighting.<br>A <strong>Lighting</strong> defines the lighting of a light through a set of opaque objects, each object stops the light and casts shadows.<br>A <strong>DarkMask</strong> defines a dark layer which hides dark area not lighted by a set of lights. It should be drown on the top-layer to hide objects which are far from the light. This effect produces a better atmosphere and is perfect for game where light are essential (where hiding invisible area is part of the difficulty).</p>
<h3 id="example-of-a-basic-scene-rendering">Example of a basic scene rendering</h3>
<p><a href="http://gre.github.io/illuminated.js/gettingstarted.html"><br>Click here to open this example.<br><img src="/images/2012/05/gettingstarted.jpg" alt="">
</a></p>
<h2 id="lights-and-objects">Lights and Objects</h2>
<h3 id="vec2">Vec2</h3>
<pre><code class="language-javascript">new Vec2(x, y);
</code></pre>
<p>Vec2 represents a 2d position or a 2d vector. It is used everywhere in <em>Illuminated.js</em>.</p>
<p>Vec2 is inspired from Box2d’s Vec2 except that in <em>Illuminated.js</em> a Vec2 vector is immutable. It means every methods create a new Vec2 instance and you can safely use a same Vec2 instance everywhere because the immutability guarantees the non-modification of properties.</p>
<h3 id="lights">Lights</h3>
<p>For now, we have only implemented one kind of light: a <strong>Lamp</strong> which is basically a radial gradient. A Lamp can also be “oriented”, it means lighting more far in a given direction.</p>
<h4 id="lamp">Lamp</h4>
<pre><code class="language-javascript">new Lamp();

new Lamp({ position: new Vec2(12, 34) });
</code></pre>
<p>every parameters:</p>
<pre><code class="language-javascript">new Lamp({
  position: new Vec2(12, 34),
  distance: 100,
  diffuse: 0.8,
  color: &#39;rgba(250,220,150,0.8)&#39;,
  radius: ,
  samples: 1,
  angle: ,
  roughness:
})
</code></pre>
<p>It defines a <strong>Lamp</strong> placed at a <strong>position</strong>, with a maximum emiting <strong>distance</strong>, a <strong>diffuse</strong> parameters to define the light penetration in objects.<br>The <strong>radius</strong> defines the size of the light. Bigger the size is, Higher shadows are smoothed. The <strong>samples</strong> is an important parameters to define the quality of this smooth.<br>The <strong>angle</strong> and <strong>roughness</strong> parameters are used for oriented lamp: angle defines the orientation while roughness defines the roughness of the effect.</p>
<h3 id="light-methods">Light methods</h3>
<p>You can easily create your own Light type by implementing its methods.</p>
<h4 id="maskctx">.mask(ctx)</h4>
<p>Render a mask representing the visibility (used by DarkMask).</p>
<h4 id="renderctx">.render(ctx)</h4>
<p>Render the light (without any shadows).</p>
<h4 id="bounds">.bounds()</h4>
<p>Return the Rectangle bound of the light representing where the light emission limit. <code>{ topleft: vec2, bottomright: vec2 }</code></p>
<h4 id="foreachsamplefn">.forEachSample(fn)</h4>
<p>Apply a function fn for each light sample position. By default it’s called once with the light position.</p>
<h3 id="opaque-objects">Opaque Objects</h3>
<p>In <em>Illuminated.js</em>, an object which cast shadows is called an opaque object. That’s why every types inherits OpaqueObject.</p>
<p>DiscObject and PolygonObject are the two available primitive objects.</p>
<h4 id="discobject">DiscObject</h4>
<p>A “DiscObject” is basically a 2D circlar object. You must define its center <strong>position</strong> and its <strong>radius</strong>:</p>
<pre><code class="language-javascript">new DiscObject({ position: new Vec2(80, 50), radius: 20 });
</code></pre>
<h4 id="polygonobject">PolygonObject</h4>
<p>PolygonObject also has some derivated classes you can use: <strong>RectangleObject</strong>, <strong>LineObject</strong>.</p>
<p>You can instanciate these different objects like this:</p>
<pre><code class="language-javascript">new PolygonObject([ new Vec2(, ), new Vec2(10, 10), ... ]) // an array of points
new RectangleObject(topleft, bottomright) // topleft and bottomright positions of the rectangle
new LineObject(a, b) // an object defined by the line from a to b.
</code></pre>
<h3 id="opaqueobject-methods">OpaqueObject methods</h3>
<p>You can easily create your own object type by implementing OpaqueObject methods.</p>
<h4 id="bounds-1">.bounds()</h4>
<p>Return the Rectangle bound of the object. <code>{ topleft: vec2, bottomright: vec2 }</code></p>
<h4 id="containspoint">.contains(point)</h4>
<p>Return <code>true</code> if the object contains a <strong>point</strong>.</p>
<h4 id="pathctx">.path(ctx)</h4>
<p>Build the path of the object shape in a 2d context <strong>ctx</strong>.</p>
<h4 id="castctx-origin-bounds">.cast(ctx, origin, bounds)</h4>
<p>Fill every shadows with <strong>ctx</strong> projected by the <strong>origin</strong> point in the object and in a given <strong>bounds</strong>.</p>
<h2 id="lighting-and-darkmask">Lighting and DarkMask</h2>
<p>Previous defined classes was representing datas we will now use to perform lightings and masks.</p>
<h3 id="lighting">Lighting</h3>
<p>A Lighting defines the lighting of one light through a set of opaque objects.</p>
<pre><code class="language-javascript">new Lighting({ light: light, objects: [ object1, object2, ... ] })
</code></pre>
<h4 id="computewidth-height">.compute(width, height)</h4>
<p>will compute shadows casting.</p>
<h4 id="castctx">.cast(ctx)</h4>
<p>will draw black shadows on the <strong>ctx</strong> canvas 2d context.<br>You usually don’t have to use it if you use <code>render()</code>.</p>
<h4 id="renderctx-1">.render(ctx)</h4>
<p>will draw the light with its shadows on <strong>ctx</strong> canvas 2d context.</p>
<h3 id="darkmask">DarkMask</h3>
<p>A DarkMask defines a dark layer which hides dark area not lighted by a set of lights.</p>
<pre><code class="language-javascript">new DarkMask({ lights: [light1, light2, ...], color: &#39;rgba(0,0,0,0.9)&#39; })
</code></pre>
<h4 id="computewidth-height-1">.compute(width, height)</h4>
<p>will compute the dark mask.</p>
<h4 id="renderctx-2">.render(ctx)</h4>
<p>will draw the computed dark mask on <strong>ctx</strong> canvas 2d context.</p>
<h3 id="about-compute-and-render">about compute and render</h3>
<p>Both Lighting and DarkMask objects have <code>compute()</code> and <code>render()</code> methods.</p>
<p>We think that <strong>you</strong> know the best when to recompute the lights because it’s closely link to the application you are making (we will not check at each time if something has changed, you know it).<br>Call the <code>compute()</code> method when something has changed in your scene so we can recompute lights and shadows.</p>
<h2 id="-how-does-it-work-under-the-hood"><a id="underthehood"></a> How does it work under the hood?</h2>
<p><em>Illuminated.js</em> divides its work into several layers.</p>
<h3 id="real-time-example">Real-time example</h3>
<iframe src="http://gre.github.io/illuminated.js/howdoesitwork.html" border="0" height="2700" width="450"></iframe>

<h3 id="the-art-of-composing-layers">The art of composing layers</h3>
<p>The layers are all stored in a Canvas which allows us to cache it. The light is drawn using a Canvas Radial Gradient in a cache canvas only once. This is interesting because canvas gradient are processor intensive<br>At the end, layers are combine on the global canvas with <code>drawImage</code>.<br>But the library lets you reuse these layers to combine them the way you want.</p>
<p>Canvas’ <code>globalCompositeOperation</code> is very useful to compose layers together.<br>For instance, in the following example, the “Light shadow casting” layer is combined with the “Light rendering” layer to generate the “Light rendering with shadows” layer. The composition mode used is “destination-out” which remove the color of the destination image where the source image has color.</p>
<pre><code class="language-javascript">light.render(ctx);
ctx.globalCompositeOperation = &quot;destination-out&quot;;
this.cast(ctx);
</code></pre>
<p>Another very useful composite operation is <code>&quot;lighter&quot;</code> which adds color values. It is used to combine two lightings.</p>
<h3 id="how-shadows-are-projected">How shadows are projected</h3>
<p>Some rendering engine use <a href="http://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray tracing</a> to render a scene, a concept very close to physics which trace from a light source a lot of rays with different paths which will collide with object and will be subject of absorption/diffraction/reflexion in accordance with the object properties…<br>Ray casting is a very <strong>realistic</strong> rendering solution <strong>but consuming</strong> (you need a lot of rays to avoid noises in the result image).<br><em>Illuminated.js</em> doesn’t use ray tracing because it aims to be efficient for a real-time usage. It uses some heuristics for casting shadows.</p>
<h4 id="lets-see-how-shadows-are-projected-for-a-polygon-object">Let’s see how shadows are projected for a polygon object.</h4>
<p>We have a scene with a light and a triangle.</p>
<p><img src="/images/2012/05/step11.jpg" alt=""></p>
<p>We select each edge of the polygon which is visible by the light (and in the light bounds).</p>
<p><img src="/images/2012/05/step21.jpg" alt=""></p>
<p>For every selected edge, we project it to generate a polygon area.</p>
<blockquote>
<p><strong>N.B.</strong> In the current implementation, we generate an hexagon projection to ensure it goes outside of the light bounds because a quadrilateral didn’t garantee it, if a light is very close to it. The projecting vector used is enough big to work for most case, but it’s still an heuristic.</p>
</blockquote>
<p><img src="/images/2012/05/step31.jpg" alt=""></p>
<p>We draw black color in this polygon area. Some improvments can be made by not drawing black in the shape / ajusting the opacity of the color.</p>
<p><img src="/images/2012/05/step4.jpg" alt=""></p>
<p>For casting blured shadows, we repeat this algorithm for each “samples” of the light. Samples are distribute around the light with a <a href="http://blog.marmakoide.org/?p=1">“spiral algorithm”</a>.</p>
<p><img src="/images/2012/05/sampling.jpg" alt=""></p>
<pre><code class="language-javascript">var GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));
Lamp.prototype.forEachSample = function (f) {
  for (var s = 0; s &lt; this.samples; ++s) {
    var a = s * GOLDEN_ANGLE;
    var r = Math.sqrt(s / this.samples) * this.radius;
    var delta = new Vec2(Math.cos(a) * r, Math.sin(a) * r);
    f(this.position.add(delta));
  }
};
</code></pre>
<h2 id="to-be-continued">To be continued…</h2>
<p>The current version of <em>Illuminated.js</em> needs more work, I’m aware of some bugs and some parts I need to improve:</p>
<ul>
<li>Implementing new kinds of lights like “Spot”, “Neon”, …</li>
<li>The dark mask doesn’t follow the Lamp orientation.</li>
<li>The shadow casting of Circle objects are not projected nicely, I need to compute <a href="http://en.wikipedia.org/wiki/Tangent_lines_to_circles">tangent lines to the circle</a>.</li>
<li>Shadows go sometimes wrong especially when having objects behind objects</li>
<li>The shadow sampling implementation is a bit hacky and wrong (changing the samples parameter changes the shadow opacity…)</li>
</ul>
<h2 id="get-involved">Get involved</h2>
<p><a href="http://gre.github.io/illuminated.js">Try the editor</a> and <a href="http://github.com/gre/illuminated.js">Get the source code</a>.</p>
<p>This article is translated to <a href="http://science.webhostinggeeks.com/masina-za-renderovanje">Serbo-Croatian</a> language by Jovana Milutinovich from Webhostinggeeks.com.</p>
</div><footer><div class="jsx-2519965637 block"><img src="http://greweb.me/logo.svg" width="100" class="jsx-2519965637"/><div class="jsx-2519965637 right"><div class="jsx-2519965637 description">generative artist who uses code to make art, explores the frontier of abstract art with algorithms pushing forward to more realistic scenery. Explore physical art via &#x27;Plotting&#x27;, which consist of drawing with fountain pens on robot. I don&#x27;t do prints, I do plots: Every physical outcome is truly unique!</div><div class="jsx-2519965637 social"><a href="https://twitter.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitter.svg" class="jsx-2519965637"/></a><a href="https://instagram.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/instagram.svg" class="jsx-2519965637"/></a><a href="https://twitch.tv/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitch.svg" class="jsx-2519965637"/></a><a href="https://github.com/gre" class="jsx-2519965637"><img alt="" src="/icons/github.svg" class="jsx-2519965637"/></a><a href="https://opensea.io/greweb?tab=created" class="jsx-2519965637"><img alt="" src="/icons/eth.svg" class="jsx-2519965637"/></a><a href="https://objkt.com/profile/tz1cgQAQfECg5bPASYTMyJ9QJQjSUi8rfL67" class="jsx-2519965637"><img alt="" src="/icons/tz.svg" class="jsx-2519965637"/></a><a href="https://fxhash.xyz/u/greweb" class="jsx-2519965637"><img alt="" src="/icons/tz.svg" class="jsx-2519965637"/></a><a href="https://greweb.itch.io" class="jsx-2519965637"><img alt="" src="/icons/iconmonstr-gamepad-3.svg" class="jsx-2519965637"/></a></div></div></div></footer></article></div></div></div><script>hljs.highlightAll();</script></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"2012-05-10-illuminated-js-2d-lights-and-shadows-rendering-engine-for-html5-applications","year":"2012","month":"05","day":"10","slug":"illuminated-js-2d-lights-and-shadows-rendering-engine-for-html5-applications","content":"\u003cp\u003e\u003ca href=\"http://bit.ly/LZ2dq1\"\u003e\u003cimg src=\"/images/2012/05/illuminatedjs.jpg\" alt=\"\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://bit.ly/LZ2dq1\"\u003eClick on the image to open it!\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"wow-whats-this\"\u003eWow! what’s this?\u003c/h2\u003e\n\u003cp\u003eIt’s a \u003cstrong\u003e2D scene\u003c/strong\u003e containing 2 \u003cstrong\u003elights\u003c/strong\u003e and 13 different \u003cstrong\u003eobjects\u003c/strong\u003e rendered in \u003cstrong\u003ereal-time\u003c/strong\u003e by a \u003cstrong\u003eJavascript library\u003c/strong\u003e I made called \u003cstrong\u003eIlluminated.js\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eThe library is designed to add some \u003cstrong\u003eawesome effects to your existing applications\u003c/strong\u003e. Adding \u003cstrong\u003ea cool atmosphere for your applications and games\u003c/strong\u003e can make the difference!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://gre.github.io/illuminated.js\"\u003eTry the editor\u003c/a\u003e\u003c/strong\u003e and \u003cstrong\u003e\u003ca href=\"http://github.com/gre/illuminated.js\"\u003eGet the source code\u003c/a\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn this article, we will introduce the basic usages of \u003cem\u003eIlluminated.js\u003c/em\u003e and APIs, and then explain how the engine works step-by-step.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/2012/05/illuminated-js-2d-lights-and-shadows-rendering-engine-for-html5-applications/#gettingstarted\"\u003eAPI – Getting started\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/2012/05/illuminated-js-2d-lights-and-shadows-rendering-engine-for-html5-applications/#underthehood\"\u003eTechnical notes – how does it work?\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!--more--\u003e\n\n\u003ch2 id=\"how-can-i-use-it\"\u003eHow can I use it?\u003c/h2\u003e\n\u003cp\u003eThe library uses \u003ca href=\"http://en.wikipedia.org/wiki/Canvas_element\"\u003eHTML5 Canvas\u003c/a\u003e to draw lights and shadows – so you can simply drop it straight into your existing Canvas applications: you just need to add some code in your render function and maintaining a binding between your application logic and the \u003cem\u003eIlluminated.js\u003c/em\u003e objects.\u003cbr\u003eNot using canvas? No worries! In theory, if you have an existing application or game made in full DOM, you could use \u003cem\u003eIlluminated.js\u003c/em\u003e behind this, playing with z-index.\u003c/p\u003e\n\u003ch2 id=\"-getting-started\"\u003e\u003ca id=\"gettingstarted\"\u003e\u003c/a\u003e Getting started\u003c/h2\u003e\n\u003ch3 id=\"basic-concepts\"\u003eBasic concepts\u003c/h3\u003e\n\u003cp\u003eAll the classes of the package live in \u003ccode\u003ewindow.illuminated\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA \u003cstrong\u003eLight\u003c/strong\u003e describes a light emit source.\u003cbr\u003eAn \u003cstrong\u003eOpaqueObject\u003c/strong\u003e specifies an 2D object used by a Lighting.\u003cbr\u003eA \u003cstrong\u003eLighting\u003c/strong\u003e defines the lighting of a light through a set of opaque objects, each object stops the light and casts shadows.\u003cbr\u003eA \u003cstrong\u003eDarkMask\u003c/strong\u003e defines a dark layer which hides dark area not lighted by a set of lights. It should be drown on the top-layer to hide objects which are far from the light. This effect produces a better atmosphere and is perfect for game where light are essential (where hiding invisible area is part of the difficulty).\u003c/p\u003e\n\u003ch3 id=\"example-of-a-basic-scene-rendering\"\u003eExample of a basic scene rendering\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/illuminated.js/gettingstarted.html\"\u003e\u003cbr\u003eClick here to open this example.\u003cbr\u003e\u003cimg src=\"/images/2012/05/gettingstarted.jpg\" alt=\"\"\u003e\n\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"lights-and-objects\"\u003eLights and Objects\u003c/h2\u003e\n\u003ch3 id=\"vec2\"\u003eVec2\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003enew Vec2(x, y);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVec2 represents a 2d position or a 2d vector. It is used everywhere in \u003cem\u003eIlluminated.js\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eVec2 is inspired from Box2d’s Vec2 except that in \u003cem\u003eIlluminated.js\u003c/em\u003e a Vec2 vector is immutable. It means every methods create a new Vec2 instance and you can safely use a same Vec2 instance everywhere because the immutability guarantees the non-modification of properties.\u003c/p\u003e\n\u003ch3 id=\"lights\"\u003eLights\u003c/h3\u003e\n\u003cp\u003eFor now, we have only implemented one kind of light: a \u003cstrong\u003eLamp\u003c/strong\u003e which is basically a radial gradient. A Lamp can also be “oriented”, it means lighting more far in a given direction.\u003c/p\u003e\n\u003ch4 id=\"lamp\"\u003eLamp\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003enew Lamp();\n\nnew Lamp({ position: new Vec2(12, 34) });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eevery parameters:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003enew Lamp({\n  position: new Vec2(12, 34),\n  distance: 100,\n  diffuse: 0.8,\n  color: \u0026#39;rgba(250,220,150,0.8)\u0026#39;,\n  radius: ,\n  samples: 1,\n  angle: ,\n  roughness:\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt defines a \u003cstrong\u003eLamp\u003c/strong\u003e placed at a \u003cstrong\u003eposition\u003c/strong\u003e, with a maximum emiting \u003cstrong\u003edistance\u003c/strong\u003e, a \u003cstrong\u003ediffuse\u003c/strong\u003e parameters to define the light penetration in objects.\u003cbr\u003eThe \u003cstrong\u003eradius\u003c/strong\u003e defines the size of the light. Bigger the size is, Higher shadows are smoothed. The \u003cstrong\u003esamples\u003c/strong\u003e is an important parameters to define the quality of this smooth.\u003cbr\u003eThe \u003cstrong\u003eangle\u003c/strong\u003e and \u003cstrong\u003eroughness\u003c/strong\u003e parameters are used for oriented lamp: angle defines the orientation while roughness defines the roughness of the effect.\u003c/p\u003e\n\u003ch3 id=\"light-methods\"\u003eLight methods\u003c/h3\u003e\n\u003cp\u003eYou can easily create your own Light type by implementing its methods.\u003c/p\u003e\n\u003ch4 id=\"maskctx\"\u003e.mask(ctx)\u003c/h4\u003e\n\u003cp\u003eRender a mask representing the visibility (used by DarkMask).\u003c/p\u003e\n\u003ch4 id=\"renderctx\"\u003e.render(ctx)\u003c/h4\u003e\n\u003cp\u003eRender the light (without any shadows).\u003c/p\u003e\n\u003ch4 id=\"bounds\"\u003e.bounds()\u003c/h4\u003e\n\u003cp\u003eReturn the Rectangle bound of the light representing where the light emission limit. \u003ccode\u003e{ topleft: vec2, bottomright: vec2 }\u003c/code\u003e\u003c/p\u003e\n\u003ch4 id=\"foreachsamplefn\"\u003e.forEachSample(fn)\u003c/h4\u003e\n\u003cp\u003eApply a function fn for each light sample position. By default it’s called once with the light position.\u003c/p\u003e\n\u003ch3 id=\"opaque-objects\"\u003eOpaque Objects\u003c/h3\u003e\n\u003cp\u003eIn \u003cem\u003eIlluminated.js\u003c/em\u003e, an object which cast shadows is called an opaque object. That’s why every types inherits OpaqueObject.\u003c/p\u003e\n\u003cp\u003eDiscObject and PolygonObject are the two available primitive objects.\u003c/p\u003e\n\u003ch4 id=\"discobject\"\u003eDiscObject\u003c/h4\u003e\n\u003cp\u003eA “DiscObject” is basically a 2D circlar object. You must define its center \u003cstrong\u003eposition\u003c/strong\u003e and its \u003cstrong\u003eradius\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003enew DiscObject({ position: new Vec2(80, 50), radius: 20 });\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"polygonobject\"\u003ePolygonObject\u003c/h4\u003e\n\u003cp\u003ePolygonObject also has some derivated classes you can use: \u003cstrong\u003eRectangleObject\u003c/strong\u003e, \u003cstrong\u003eLineObject\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eYou can instanciate these different objects like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003enew PolygonObject([ new Vec2(, ), new Vec2(10, 10), ... ]) // an array of points\nnew RectangleObject(topleft, bottomright) // topleft and bottomright positions of the rectangle\nnew LineObject(a, b) // an object defined by the line from a to b.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"opaqueobject-methods\"\u003eOpaqueObject methods\u003c/h3\u003e\n\u003cp\u003eYou can easily create your own object type by implementing OpaqueObject methods.\u003c/p\u003e\n\u003ch4 id=\"bounds-1\"\u003e.bounds()\u003c/h4\u003e\n\u003cp\u003eReturn the Rectangle bound of the object. \u003ccode\u003e{ topleft: vec2, bottomright: vec2 }\u003c/code\u003e\u003c/p\u003e\n\u003ch4 id=\"containspoint\"\u003e.contains(point)\u003c/h4\u003e\n\u003cp\u003eReturn \u003ccode\u003etrue\u003c/code\u003e if the object contains a \u003cstrong\u003epoint\u003c/strong\u003e.\u003c/p\u003e\n\u003ch4 id=\"pathctx\"\u003e.path(ctx)\u003c/h4\u003e\n\u003cp\u003eBuild the path of the object shape in a 2d context \u003cstrong\u003ectx\u003c/strong\u003e.\u003c/p\u003e\n\u003ch4 id=\"castctx-origin-bounds\"\u003e.cast(ctx, origin, bounds)\u003c/h4\u003e\n\u003cp\u003eFill every shadows with \u003cstrong\u003ectx\u003c/strong\u003e projected by the \u003cstrong\u003eorigin\u003c/strong\u003e point in the object and in a given \u003cstrong\u003ebounds\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"lighting-and-darkmask\"\u003eLighting and DarkMask\u003c/h2\u003e\n\u003cp\u003ePrevious defined classes was representing datas we will now use to perform lightings and masks.\u003c/p\u003e\n\u003ch3 id=\"lighting\"\u003eLighting\u003c/h3\u003e\n\u003cp\u003eA Lighting defines the lighting of one light through a set of opaque objects.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003enew Lighting({ light: light, objects: [ object1, object2, ... ] })\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"computewidth-height\"\u003e.compute(width, height)\u003c/h4\u003e\n\u003cp\u003ewill compute shadows casting.\u003c/p\u003e\n\u003ch4 id=\"castctx\"\u003e.cast(ctx)\u003c/h4\u003e\n\u003cp\u003ewill draw black shadows on the \u003cstrong\u003ectx\u003c/strong\u003e canvas 2d context.\u003cbr\u003eYou usually don’t have to use it if you use \u003ccode\u003erender()\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"renderctx-1\"\u003e.render(ctx)\u003c/h4\u003e\n\u003cp\u003ewill draw the light with its shadows on \u003cstrong\u003ectx\u003c/strong\u003e canvas 2d context.\u003c/p\u003e\n\u003ch3 id=\"darkmask\"\u003eDarkMask\u003c/h3\u003e\n\u003cp\u003eA DarkMask defines a dark layer which hides dark area not lighted by a set of lights.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003enew DarkMask({ lights: [light1, light2, ...], color: \u0026#39;rgba(0,0,0,0.9)\u0026#39; })\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"computewidth-height-1\"\u003e.compute(width, height)\u003c/h4\u003e\n\u003cp\u003ewill compute the dark mask.\u003c/p\u003e\n\u003ch4 id=\"renderctx-2\"\u003e.render(ctx)\u003c/h4\u003e\n\u003cp\u003ewill draw the computed dark mask on \u003cstrong\u003ectx\u003c/strong\u003e canvas 2d context.\u003c/p\u003e\n\u003ch3 id=\"about-compute-and-render\"\u003eabout compute and render\u003c/h3\u003e\n\u003cp\u003eBoth Lighting and DarkMask objects have \u003ccode\u003ecompute()\u003c/code\u003e and \u003ccode\u003erender()\u003c/code\u003e methods.\u003c/p\u003e\n\u003cp\u003eWe think that \u003cstrong\u003eyou\u003c/strong\u003e know the best when to recompute the lights because it’s closely link to the application you are making (we will not check at each time if something has changed, you know it).\u003cbr\u003eCall the \u003ccode\u003ecompute()\u003c/code\u003e method when something has changed in your scene so we can recompute lights and shadows.\u003c/p\u003e\n\u003ch2 id=\"-how-does-it-work-under-the-hood\"\u003e\u003ca id=\"underthehood\"\u003e\u003c/a\u003e How does it work under the hood?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eIlluminated.js\u003c/em\u003e divides its work into several layers.\u003c/p\u003e\n\u003ch3 id=\"real-time-example\"\u003eReal-time example\u003c/h3\u003e\n\u003ciframe src=\"http://gre.github.io/illuminated.js/howdoesitwork.html\" border=\"0\" height=\"2700\" width=\"450\"\u003e\u003c/iframe\u003e\n\n\u003ch3 id=\"the-art-of-composing-layers\"\u003eThe art of composing layers\u003c/h3\u003e\n\u003cp\u003eThe layers are all stored in a Canvas which allows us to cache it. The light is drawn using a Canvas Radial Gradient in a cache canvas only once. This is interesting because canvas gradient are processor intensive\u003cbr\u003eAt the end, layers are combine on the global canvas with \u003ccode\u003edrawImage\u003c/code\u003e.\u003cbr\u003eBut the library lets you reuse these layers to combine them the way you want.\u003c/p\u003e\n\u003cp\u003eCanvas’ \u003ccode\u003eglobalCompositeOperation\u003c/code\u003e is very useful to compose layers together.\u003cbr\u003eFor instance, in the following example, the “Light shadow casting” layer is combined with the “Light rendering” layer to generate the “Light rendering with shadows” layer. The composition mode used is “destination-out” which remove the color of the destination image where the source image has color.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003elight.render(ctx);\nctx.globalCompositeOperation = \u0026quot;destination-out\u0026quot;;\nthis.cast(ctx);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnother very useful composite operation is \u003ccode\u003e\u0026quot;lighter\u0026quot;\u003c/code\u003e which adds color values. It is used to combine two lightings.\u003c/p\u003e\n\u003ch3 id=\"how-shadows-are-projected\"\u003eHow shadows are projected\u003c/h3\u003e\n\u003cp\u003eSome rendering engine use \u003ca href=\"http://en.wikipedia.org/wiki/Ray_tracing_(graphics)\"\u003eray tracing\u003c/a\u003e to render a scene, a concept very close to physics which trace from a light source a lot of rays with different paths which will collide with object and will be subject of absorption/diffraction/reflexion in accordance with the object properties…\u003cbr\u003eRay casting is a very \u003cstrong\u003erealistic\u003c/strong\u003e rendering solution \u003cstrong\u003ebut consuming\u003c/strong\u003e (you need a lot of rays to avoid noises in the result image).\u003cbr\u003e\u003cem\u003eIlluminated.js\u003c/em\u003e doesn’t use ray tracing because it aims to be efficient for a real-time usage. It uses some heuristics for casting shadows.\u003c/p\u003e\n\u003ch4 id=\"lets-see-how-shadows-are-projected-for-a-polygon-object\"\u003eLet’s see how shadows are projected for a polygon object.\u003c/h4\u003e\n\u003cp\u003eWe have a scene with a light and a triangle.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2012/05/step11.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eWe select each edge of the polygon which is visible by the light (and in the light bounds).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2012/05/step21.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eFor every selected edge, we project it to generate a polygon area.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eN.B.\u003c/strong\u003e In the current implementation, we generate an hexagon projection to ensure it goes outside of the light bounds because a quadrilateral didn’t garantee it, if a light is very close to it. The projecting vector used is enough big to work for most case, but it’s still an heuristic.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"/images/2012/05/step31.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eWe draw black color in this polygon area. Some improvments can be made by not drawing black in the shape / ajusting the opacity of the color.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2012/05/step4.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eFor casting blured shadows, we repeat this algorithm for each “samples” of the light. Samples are distribute around the light with a \u003ca href=\"http://blog.marmakoide.org/?p=1\"\u003e“spiral algorithm”\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2012/05/sampling.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003evar GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));\nLamp.prototype.forEachSample = function (f) {\n  for (var s = 0; s \u0026lt; this.samples; ++s) {\n    var a = s * GOLDEN_ANGLE;\n    var r = Math.sqrt(s / this.samples) * this.radius;\n    var delta = new Vec2(Math.cos(a) * r, Math.sin(a) * r);\n    f(this.position.add(delta));\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"to-be-continued\"\u003eTo be continued…\u003c/h2\u003e\n\u003cp\u003eThe current version of \u003cem\u003eIlluminated.js\u003c/em\u003e needs more work, I’m aware of some bugs and some parts I need to improve:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eImplementing new kinds of lights like “Spot”, “Neon”, …\u003c/li\u003e\n\u003cli\u003eThe dark mask doesn’t follow the Lamp orientation.\u003c/li\u003e\n\u003cli\u003eThe shadow casting of Circle objects are not projected nicely, I need to compute \u003ca href=\"http://en.wikipedia.org/wiki/Tangent_lines_to_circles\"\u003etangent lines to the circle\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eShadows go sometimes wrong especially when having objects behind objects\u003c/li\u003e\n\u003cli\u003eThe shadow sampling implementation is a bit hacky and wrong (changing the samples parameter changes the shadow opacity…)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"get-involved\"\u003eGet involved\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://gre.github.io/illuminated.js\"\u003eTry the editor\u003c/a\u003e and \u003ca href=\"http://github.com/gre/illuminated.js\"\u003eGet the source code\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis article is translated to \u003ca href=\"http://science.webhostinggeeks.com/masina-za-renderovanje\"\u003eSerbo-Croatian\u003c/a\u003e language by Jovana Milutinovich from Webhostinggeeks.com.\u003c/p\u003e\n","data":{"title":"Illuminated.js – 2D lights and shadows rendering engine for HTML5 applications","description":"Illuminated.js is designed to add some awesome effects to your existing applications. Adding a cool atmosphere for your applications and games can make the difference!","thumbnail":"/images/2012/05/illuminatedjs.jpg","author":"Gaetan","layout":"post","permalink":"/2012/05/illuminated-js-2d-lights-and-shadows-rendering-engine-for-html5-applications/","tags":["gamedev","canvas","javascript","library"]}},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2012","month":"05","slug":"illuminated-js-2d-lights-and-shadows-rendering-engine-for-html5-applications"},"buildId":"B95JjZeGO005JTlGuGHVX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>