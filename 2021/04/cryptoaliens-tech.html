<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="author" content="Gaëtan Renaudeau"/><meta name="description" content="Technical aspects of CryptoAliens digital creatures generated with Ethereum blockchain blocks. They can be minted on ethblock.at by anyone, which establishes a limited set of CryptoAliens species."/><meta name="keywords" content="NFT, shaders"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@greweb"/><meta name="twitter:title" content="CryptoAliens: Genesis, a technical look"/><meta name="og:title" content="CryptoAliens: Genesis, a technical look"/><meta name="twitter:description" content="Technical aspects of CryptoAliens digital creatures generated with Ethereum blockchain blocks. They can be minted on ethblock.at by anyone, which establishes a limited set of CryptoAliens species."/><meta name="twitter:creator" content="@greweb"/><meta name="og:image" content="http://greweb.me//images/posts/cryptoaliens/026_px.png"/><meta name="twitter:image" content="http://greweb.me//images/posts/cryptoaliens/026_px.png"/><link rel="image_src" href="http://greweb.me//images/posts/cryptoaliens/026_px.png"/><title>@greweb - CryptoAliens: Genesis, a technical look</title><link href="http://fonts.googleapis.com/css?family=Fredericka+the+Great|Arapey|Roboto:400,700,400italic" rel="stylesheet" type="text/css"/><link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/styles/default.min.css"/><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/highlight.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/javascript.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/cpp.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/glsl.min.js"></script><link rel="stylesheet" href="/style/main.css"/><meta name="next-head-count" content="25"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-c914a1e31212c00c738a.js" defer=""></script><script src="/_next/static/chunks/framework-bdc1b4e5e48979e16d36.js" defer=""></script><script src="/_next/static/chunks/main-3b0c517193ca5150f81f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c981e0e3ce59f13eb8d0.js" defer=""></script><script src="/_next/static/chunks/5988-738c1ea5f97353b6463e.js" defer=""></script><script src="/_next/static/chunks/2242-eb3b6e81e9125c246631.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-476d7e87469cc8a40c59.js" defer=""></script><script src="/_next/static/hFDiHNZ0j540JSd1Mm1FP/_buildManifest.js" defer=""></script><script src="/_next/static/hFDiHNZ0j540JSd1Mm1FP/_ssgManifest.js" defer=""></script><style id="__jsx-2519965637">.block.jsx-2519965637{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.block.jsx-2519965637 .right.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637{margin-top:10px;}.block.jsx-2519965637 .social.jsx-2519965637 a.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637 img.jsx-2519965637{height:20px;}</style><style id="__jsx-3621368397">.container.jsx-3621368397{min-height:100vh;padding:0 0.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><style id="__jsx-3469673304">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto, Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue, sans-serif;}*{box-sizing:border-box;}a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a:hover,a:active{-webkit-text-decoration:underline;text-decoration:underline;}</style></head><body><div id="__next"><div class="jsx-3621368397 container"><div id="container"><div id="main"><div id="content"><article><header><h1><a href="/">CryptoAliens: Genesis, a technical look</a></h1><time class="date" dateTime="2021-04-09">2021-04-09</time><span class="tags"><a class="tag">NFT</a><a class="tag">shaders</a></span></header><div class="entry-content"><blockquote>
<p>See also <a href="/2021/04/cryptoaliens">CryptoAliens: Genesis</a> main article.</p>
</blockquote>
<p>This article explains how <a href="/2021/04/cryptoaliens">CryptoAliens: Genesis (ethblock.art)</a> works in technical depth.</p>
<p><img src="/images/posts/cryptoaliens/032_px.png" width="50%" /><img src="/images/posts/cryptoaliens/036_px.png" width="50%" /></p>
<p>First of all, I would like to point out the <a href="https://github.com/gre/gre/tree/master/blockarts/CryptoAliens">source code is available here on Github</a>.</p>
<p>This whole idea was kicked off on <a href="https://twitch.tv/greweb">Twitch</a>. A recording is <a href="https://www.youtube.com/watch?v=WUzOlLq0IAo">available on Youtube</a>. Apart from the many glitches this 3 hours session had remained to be solved, the main part of this was implemented that night. Indeed I had to work countlessly on polishing the shaders, lighting and post-processing. I also spent a lot of time using the block data in a meaningful way because it&#39;s what <a href="https://ethblock.art">EthBlock.art</a> really is about.</p>
<h2 id="ethblockart-revolutionary-idea">EthBlock.art revolutionary idea</h2>
<p>Before going further into the technical details of CryptoAliens, I would like to point out how revolutionary this EthBlock.art idea is.</p>
<p>The project aims to create a virtuous ecosystem of &quot;deterministic art&quot;, code visualization of Ethereum blocks. Everything is data: from the ethereum block of transactions, to the code that visualize it, and to the NFTs minted/traded using Ethereum transactions (that themselves are into Ethereum blocks).</p>
<p><strong>This is a virtuous ecosystem, similar to <a href="https://en.wikipedia.org/wiki/Value_chain">Supply Chain Transformation concepts</a>: each actor in this ecosystem add value and get retributed for it, as I tried to explain in this schema:</strong></p>
<p><img src="/images/posts/cryptoaliens/ethblockart.png" alt=""></p>
<p><code>CryptoAliens: Genesis</code> is one possible BlockStyle that I&#39;ve designed, as a creative coder. It tries to visualize what happened in the Ethereum Block and will take mods into account to try to be as good as possible to deliver interesting possibilities to BlockArt minters.</p>
<h2 id="ok-so-how-is-it-implemented-technically">Ok, so how is it implemented technically?</h2>
<p>Indeed WebGL.</p>
<p>More precisely, it is implemented with <a href="https://github.com/gre/gl-react"><code>gl-react</code></a> which is convenient to write and compose <a href="https://www.khronos.org/opengl/wiki/Fragment_Shader"><em>GLSL Fragment Shaders</em></a>.</p>
<p><strong>here is the big picture of the pipeline:</strong></p>
<p><video src="/images/posts/cryptoaliens/graph.mp4" width="100%" controls autoplay muted loop></video></p>
<p>There are 2 main shaders: Mandelglitch (for skin texturing) and Scene (the main raymarching shader). Each of them take a bunch of parameters. <code>mod1..4</code> are values from the creator. The rest are inferred from the Block information, they are split into multiple parameters for convenience.</p>
<p>The parameters <code>s1..9</code> are coming directly from <code>mersenne-twister</code> library, a <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">PRNG</a> used to get a wide and deterministic variety of shapes, initialized with the block hash. That said, as pointed in the previous section, the main features of the shape are determined by Ethereum block information itself (number of transactions, timestamp, transfers, gas used,...).</p>
<p>On top of these, some other parameters are controling key elements they come from more block information (heavy, head, bonesK, arms info,...).</p>
<p>The technique implemented on the main Scene shader is <a href="https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm">raymarching distance functions</a>. The shapes at stake are mostly segments that are merged with a smooth union. There are many loops involved which made it challenging to optimize.
There may be issues on some mobile phone even tho it works on mine thanks to a &quot;pixelated&quot; version. (downscaling the pixels helped)</p>
<p>Because of an heavy usage of this technique, the main scene was really challenging to optimize, it actually runs something like 5 FPS. My choice was to not animate it directly (you can see on the rendering graph that actually the buffer don&#39;t need to refresh, except when a &quot;mod&quot; is changed). However, thanks to intermediary framebuffers we can do 60 FPS animation at the postprocessing level. This is what the final user will get as the mods are static.</p>
<h3 id="canvas-2d-to-draw-texts">Canvas 2D to draw texts</h3>
<p>A Canvas 2D element is used to draw the text that will appear on top of everything.</p>
<pre><code class="language-js">/// canvas used to draw in postprocessing ///
function FrameText({ blockNumber, dateText, width, height, kg, bones }) {
  const onCanvasRef = (canvas) =&gt; {
    if (!canvas) return;
    const ctx = canvas.getContext(&quot;2d&quot;);
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    const pad = Math.round(w * 0.01);
    const padX = Math.round(w * 0.02);
    const fontS = Math.floor(0.19 * w) / 10;
    const fontSize = `${fontS}px`;
    ctx.save();
    ctx.fillStyle = &quot;#000&quot;;
    ctx.fillRect(0, 0, w, h);
    ctx.font = &quot;bold &quot; + fontSize + &quot; monospace&quot;;
    ctx.textBaseline = &quot;top&quot;;
    ctx.fillStyle = &quot;#fff&quot;;
    ctx.fillText(`CryptoAliens specimen #${blockNumber}`, padX, pad);
    ctx.textBaseline = &quot;bottom&quot;;
    ctx.textAlign = &quot;right&quot;;
    ctx.font = fontSize + &quot; monospace&quot;;
    ctx.fillText(
      `born ${dateText}, ${kg} kg, ${bones} bones`,
      w - padX,
      h - pad
    );
    ctx.restore();
  };
  return (
    &lt;canvas
      ref={onCanvasRef}
      width={String(width * 2)}
      height={String(height * 2)}
    /&gt;
  );
}
const FrameTextCached = React.memo(FrameText);
</code></pre>
<h3 id="how-is-mandelglitch-used">How is Mandelglitch used?</h3>
<p>As said, <a href="https://ethblock.art/create/17">Mandelglitch BlockStyle</a> is re-used in this CryptoAliens BlockStyle. This really is the power of gl-react: it makes such composability really easy to do, the same way you can compose React components.</p>
<p>You can see in the <a href="https://www.youtube.com/watch?v=WUzOlLq0IAo">Youtube recording</a> the way I have implemented it initially: it is just a simple import of Mandelglitch.js (literally the BlockStyle as-is) that I can just send as a uniform sampler2D.</p>
<pre><code>&lt;Node
  shader={sceneShaders.scene}
  uniforms={{
    t: &lt;Mandelglitch block={block} mod1={mod1} mod2={mod2} mod3={mod3} /&gt;,
  ...
</code></pre>
<p>after that, it was simpler to embed Mandelglitch in the BlockStyle.</p>
<p>The way Mandelglitch texturing is used however is that I will only use the &quot;red&quot; component and remap it to CryptoAliens&#39; own palette, in order to have a better control of the coloring.</p>
<h3 id="code-organisation">Code organisation</h3>
<p>React and Gl-React allows to organize the code relatively easily. First of all each pass in the rendering scene is a component, then shaders are organized in the <code>Shaders.create</code> usage. I&#39;ve tried to collocate them (still in same one big file to simplify the upload to EthBlock.art).</p>
<p>I find it pretty convenient to externalize piece of the logic into &quot;hooks&quot; function. Example:</p>
<pre><code class="language-js">const CustomStyle = (props) =&gt; {
  // prettier-ignore
  const { block, attributesRef, mod1, mod2, mod3, mod4, highQuality, width, height } = props;
  // prettier-ignore
  const { kg, bones, theme, background, s1, s2, s3, s4, s5, s6, s7, s8, heavy, head, bonesK, armsLen, armsSpread, armsCenter, armsEndW, dateText, blockNumber } =
    useBlockDerivedData(block, mod1, mod2, mod3, mod4);

  useAttributesSync(attributesRef, kg, bones, theme);

  return (
    &lt;LiveTV
      text={
        &lt;FrameTextCached ... /&gt;
      }
      ...
    &gt;
      &lt;NearestCopy width={w} height={h}&gt;
        &lt;Scene
          t={&lt;MandelglitchCached ... /&gt;}
          ...
        /&gt;
      &lt;/NearestCopy&gt;
    &lt;/LiveTV&gt;
  );
};
</code></pre>
<p><code>useBlockDerivedData</code> internally uses <code>useMemo</code> in order to cache the computation of block data interpretation.</p>
<p>In order to make <strong>only</strong> one part of the tree to actively re-render, i&#39;ve used a local <code>useTime</code> that would re-render only that part (the LiveTV final shader). It&#39;s implementation is trivial:</p>
<pre><code class="language-js">function useTime() {
  const [time, setTime] = useState(0);
  useEffect(() =&gt; {
    let startT;
    let h;
    function loop(t) {
      h = requestAnimationFrame(loop);
      if (!startT) startT = t;
      setTime((t - startT) / 1000);
    }
    h = requestAnimationFrame(loop);
    return () =&gt; cancelAnimationFrame(h);
  }, []);
  return time;
}
</code></pre>
<h2 id="arms-joints-rotation-glsl-random-and-determinism">Arms joints rotation, GLSL random and determinism</h2>
<p>Ok, this is a hard topic. But it&#39;s extremely important that every BlockArt reliably produce the same result with the same block data, regardless of the computer used.</p>
<p>That last &quot;regardless of computer used&quot; part has challenged me at the last minute! JavaScript doesn&#39;t have this problem because it&#39;s stable between implementations (computers, engines). However, <strong>this is not the case with OpenGL / GLSL</strong>: every computer, every hardware (GPU) or possibly the &quot;backend&quot; implementation for WebGL (<a href="https://github.com/google/angle">ANGLE</a> have different backends) can differ when it comes to float precision and primitive results.</p>
<p>In my shader, I was using the classical <code>random</code> function that is documented at <a href="https://thebookofshaders.com/10/">https://thebookofshaders.com/10/</a></p>
<pre><code class="language-cpp">float random (vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}
</code></pre>
<p>It works very well when you need a nice 2D distributed noise for basic effects <strong>but it is very bad if you strongly rely on a stable &amp; consistent noise to generate different shapes</strong>.</p>
<p>Empirically, I can observe that <code>sin()</code> yields different results on different computers.</p>
<p>This was impacting me badly because I was able to see very various shapes:</p>
<p><img src="/images/posts/cryptoaliens/rand1.png" width="33%"/><img src="/images/posts/cryptoaliens/rand2.png" width="33%"/><img src="/images/posts/cryptoaliens/rand3.png" width="33%"/></p>
<p>What I need to varies a bit here is just the angle at each joint of the arms. This is very important for the uniqueness of the creature. The problem is that if each value changes a tiny bit, the whole thing diverge VERY QUICKLY, as the rotation angle will accumulate.</p>
<p>Worse than that, I had a bad pattern to accumulate randomness like this:</p>
<pre><code class="language-cpp">float ss1 = s1;
for (int i = 0; i &lt; armsLen; i++) {
  ss1 = random(ss1);
  ...
}
</code></pre>
<p>Actually I don&#39;t need that, first of all it&#39;s probably not good for performance, secondly I can just afford taking the fractional part of a simple polynomial:</p>
<pre><code class="language-cpp">float arm (inout vec3 p, float index, float w, float h) {
  float s = sdSegment(p, h, w);
  float base1 = 305.53 * s1 + 77.21 * index;
  float base2 = 403.53 * s2 + 69.71 * index;
  for (int i = 0; i &lt; armsLen; i++) {
    float fi = float(i);
    float ss1 = fract(base1 + 9.412 * fi);
    float ss2 = fract(base2 + 8.823 * fi);
    pR(p.xy, 8. * s4 * (ss2-.5));
    pR(p.xz, 6. * s5 * (ss1-.5));
    s = fOpUnionSoft(bonesK, s, sdSegment(p, h, w));
    h *= .9;
    w *= .9;
    p.y -= 1.2 * h;
  }
  s = fOpUnionSoft(bonesK + 0.2 * s5, s, length(p) - armsEndW);
  return s;
}
</code></pre>
<p>Note that here it&#39;s very arbitrary numbers, the point is to obtain variety and unpredictability in the results. <code>fract</code> is a very simple operation (take the fractional part of the number). Indeed i&#39;m still prone to approximation, but the risk is limited by the fact i don&#39;t go too high in values here. Worse case scenario is it varies a bit the rotation but it should be so tiny that it won&#39;t be visible.</p>
<p>As said before and as seen in this code, the number will be used to do rotations (that <code>pR</code> is transforming <code>p</code> with some rotations). I use <code>s4</code> and <code>s5</code> values to give the magnitude of rotations.</p>
<p><strong>Let&#39;s look at a few cases:</strong></p>
<p>If both s4 and s5 are very near 0.0, it will be straight arms (it&#39;s a rare case therefore).</p>
<p><img src="/images/posts/cryptoaliens/042_px.png" width="50%"/><img src="/images/posts/cryptoaliens/033_px.png" width="50%"/></p>
<p>If one of the s4 or s5 are 0.0, it will be only happening on one &quot;plan&quot;, or slightly diverging spirals, which I assume also to be rare cases:</p>
<p><img src="/images/posts/cryptoaliens/017_px.png" width="50%"/><img src="/images/posts/cryptoaliens/020_px.png" width="50%"/></p>
<p>Otherwise, most of the times, it will be relatively random:</p>
<p><img src="/images/posts/cryptoaliens/029_px.png" width="50%"/><img src="/images/posts/cryptoaliens/032_px.png" width="50%"/>
<img src="/images/posts/cryptoaliens/028_px.png" width="50%"/><img src="/images/posts/cryptoaliens/026_px.png" width="50%"/></p>
<h2 id="going-128px-last-minute-decision-hard-tradeoff">going 128px. Last minute decision, hard tradeoff</h2>
<p>Due to concerns on the &quot;deterministic rendering&quot; from Ethblock.art folks, I had to make a choice regarding the fact it was too slow on mobile... I&#39;ve decided to switch to 128x128 rendering for ALL platforms so it&#39;s consistent.</p>
<p>All the images on that article were done on 1024x1024 which is slow on computer and not even working on my mobile phone. (OnePlus)</p>
<p>It&#39;s hard to have efficient raymarching today when you have many items.</p>
<p><strong>Ultimately, I like how it finally looks, there were some minimalism / cell shaded styles,.. now it embraces Pixel Art even more!</strong></p>
<p><img src="/images/posts/cryptoaliens/r02.png" width="50%" /><img src="/images/posts/cryptoaliens/r01.png" width="50%" /></p>
<p>It&#39;s also always possible to make higher quality version of these rendering and I&#39;m excited to experiment more of these in future.</p>
<hr>
<p>My name is Gaëtan Renaudeau, and I&#39;m a noise explorer. <strong>feel free to ping me on Twitter <a href="https://twitter.com/greweb">@greweb</a></strong></p>
</div><footer><div class="jsx-2519965637 block"><img src="http://greweb.me/logo.svg" width="100" class="jsx-2519965637"/><div class="jsx-2519965637 right"><div class="jsx-2519965637 description">As a generative plotter artist, I use code to generate art (creative coding) and physically create it with pen plotters, which is itself a generative process – each physical plot is a unique variant. I love dualities, like digital vs analog physical, abstract vs figurative, orthogonal vs polar, photo vs noise,...</div><div class="jsx-2519965637 social"><a href="https://discord.gg/DQBajxzn" class="jsx-2519965637"><img alt="" src="/icons/discord.svg" class="jsx-2519965637"/></a><a href="https://twitter.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitter.svg" class="jsx-2519965637"/></a><a href="https://instagram.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/instagram.svg" class="jsx-2519965637"/></a><a href="https://twitch.tv/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitch.svg" class="jsx-2519965637"/></a><a href="https://github.com/gre" class="jsx-2519965637"><img alt="" src="/icons/github.svg" class="jsx-2519965637"/></a><a href="https://youtube.com/@greweb" class="jsx-2519965637"><img alt="" src="/icons/youtube.svg" class="jsx-2519965637"/></a><a href="https://opensea.io/greweb?tab=created" class="jsx-2519965637"><img alt="" src="/icons/eth.svg" class="jsx-2519965637"/></a><a href="https://fxhash.xyz/u/greweb" class="jsx-2519965637"><img alt="" src="/icons/tz.svg" class="jsx-2519965637"/></a><a href="https://greweb.itch.io" class="jsx-2519965637"><img alt="" src="/icons/iconmonstr-gamepad-3.svg" class="jsx-2519965637"/></a></div></div></div></footer></article></div></div></div><script>hljs.highlightAll();</script></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"2021-04-09-cryptoaliens-tech","year":"2021","month":"04","day":"09","slug":"cryptoaliens-tech","content":"\u003cblockquote\u003e\n\u003cp\u003eSee also \u003ca href=\"/2021/04/cryptoaliens\"\u003eCryptoAliens: Genesis\u003c/a\u003e main article.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis article explains how \u003ca href=\"/2021/04/cryptoaliens\"\u003eCryptoAliens: Genesis (ethblock.art)\u003c/a\u003e works in technical depth.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/cryptoaliens/032_px.png\" width=\"50%\" /\u003e\u003cimg src=\"/images/posts/cryptoaliens/036_px.png\" width=\"50%\" /\u003e\u003c/p\u003e\n\u003cp\u003eFirst of all, I would like to point out the \u003ca href=\"https://github.com/gre/gre/tree/master/blockarts/CryptoAliens\"\u003esource code is available here on Github\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis whole idea was kicked off on \u003ca href=\"https://twitch.tv/greweb\"\u003eTwitch\u003c/a\u003e. A recording is \u003ca href=\"https://www.youtube.com/watch?v=WUzOlLq0IAo\"\u003eavailable on Youtube\u003c/a\u003e. Apart from the many glitches this 3 hours session had remained to be solved, the main part of this was implemented that night. Indeed I had to work countlessly on polishing the shaders, lighting and post-processing. I also spent a lot of time using the block data in a meaningful way because it\u0026#39;s what \u003ca href=\"https://ethblock.art\"\u003eEthBlock.art\u003c/a\u003e really is about.\u003c/p\u003e\n\u003ch2 id=\"ethblockart-revolutionary-idea\"\u003eEthBlock.art revolutionary idea\u003c/h2\u003e\n\u003cp\u003eBefore going further into the technical details of CryptoAliens, I would like to point out how revolutionary this EthBlock.art idea is.\u003c/p\u003e\n\u003cp\u003eThe project aims to create a virtuous ecosystem of \u0026quot;deterministic art\u0026quot;, code visualization of Ethereum blocks. Everything is data: from the ethereum block of transactions, to the code that visualize it, and to the NFTs minted/traded using Ethereum transactions (that themselves are into Ethereum blocks).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a virtuous ecosystem, similar to \u003ca href=\"https://en.wikipedia.org/wiki/Value_chain\"\u003eSupply Chain Transformation concepts\u003c/a\u003e: each actor in this ecosystem add value and get retributed for it, as I tried to explain in this schema:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/cryptoaliens/ethblockart.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCryptoAliens: Genesis\u003c/code\u003e is one possible BlockStyle that I\u0026#39;ve designed, as a creative coder. It tries to visualize what happened in the Ethereum Block and will take mods into account to try to be as good as possible to deliver interesting possibilities to BlockArt minters.\u003c/p\u003e\n\u003ch2 id=\"ok-so-how-is-it-implemented-technically\"\u003eOk, so how is it implemented technically?\u003c/h2\u003e\n\u003cp\u003eIndeed WebGL.\u003c/p\u003e\n\u003cp\u003eMore precisely, it is implemented with \u003ca href=\"https://github.com/gre/gl-react\"\u003e\u003ccode\u003egl-react\u003c/code\u003e\u003c/a\u003e which is convenient to write and compose \u003ca href=\"https://www.khronos.org/opengl/wiki/Fragment_Shader\"\u003e\u003cem\u003eGLSL Fragment Shaders\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ehere is the big picture of the pipeline:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cvideo src=\"/images/posts/cryptoaliens/graph.mp4\" width=\"100%\" controls autoplay muted loop\u003e\u003c/video\u003e\u003c/p\u003e\n\u003cp\u003eThere are 2 main shaders: Mandelglitch (for skin texturing) and Scene (the main raymarching shader). Each of them take a bunch of parameters. \u003ccode\u003emod1..4\u003c/code\u003e are values from the creator. The rest are inferred from the Block information, they are split into multiple parameters for convenience.\u003c/p\u003e\n\u003cp\u003eThe parameters \u003ccode\u003es1..9\u003c/code\u003e are coming directly from \u003ccode\u003emersenne-twister\u003c/code\u003e library, a \u003ca href=\"https://en.wikipedia.org/wiki/Pseudorandom_number_generator\"\u003ePRNG\u003c/a\u003e used to get a wide and deterministic variety of shapes, initialized with the block hash. That said, as pointed in the previous section, the main features of the shape are determined by Ethereum block information itself (number of transactions, timestamp, transfers, gas used,...).\u003c/p\u003e\n\u003cp\u003eOn top of these, some other parameters are controling key elements they come from more block information (heavy, head, bonesK, arms info,...).\u003c/p\u003e\n\u003cp\u003eThe technique implemented on the main Scene shader is \u003ca href=\"https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\"\u003eraymarching distance functions\u003c/a\u003e. The shapes at stake are mostly segments that are merged with a smooth union. There are many loops involved which made it challenging to optimize.\nThere may be issues on some mobile phone even tho it works on mine thanks to a \u0026quot;pixelated\u0026quot; version. (downscaling the pixels helped)\u003c/p\u003e\n\u003cp\u003eBecause of an heavy usage of this technique, the main scene was really challenging to optimize, it actually runs something like 5 FPS. My choice was to not animate it directly (you can see on the rendering graph that actually the buffer don\u0026#39;t need to refresh, except when a \u0026quot;mod\u0026quot; is changed). However, thanks to intermediary framebuffers we can do 60 FPS animation at the postprocessing level. This is what the final user will get as the mods are static.\u003c/p\u003e\n\u003ch3 id=\"canvas-2d-to-draw-texts\"\u003eCanvas 2D to draw texts\u003c/h3\u003e\n\u003cp\u003eA Canvas 2D element is used to draw the text that will appear on top of everything.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e/// canvas used to draw in postprocessing ///\nfunction FrameText({ blockNumber, dateText, width, height, kg, bones }) {\n  const onCanvasRef = (canvas) =\u0026gt; {\n    if (!canvas) return;\n    const ctx = canvas.getContext(\u0026quot;2d\u0026quot;);\n    const w = ctx.canvas.width;\n    const h = ctx.canvas.height;\n    const pad = Math.round(w * 0.01);\n    const padX = Math.round(w * 0.02);\n    const fontS = Math.floor(0.19 * w) / 10;\n    const fontSize = `${fontS}px`;\n    ctx.save();\n    ctx.fillStyle = \u0026quot;#000\u0026quot;;\n    ctx.fillRect(0, 0, w, h);\n    ctx.font = \u0026quot;bold \u0026quot; + fontSize + \u0026quot; monospace\u0026quot;;\n    ctx.textBaseline = \u0026quot;top\u0026quot;;\n    ctx.fillStyle = \u0026quot;#fff\u0026quot;;\n    ctx.fillText(`CryptoAliens specimen #${blockNumber}`, padX, pad);\n    ctx.textBaseline = \u0026quot;bottom\u0026quot;;\n    ctx.textAlign = \u0026quot;right\u0026quot;;\n    ctx.font = fontSize + \u0026quot; monospace\u0026quot;;\n    ctx.fillText(\n      `born ${dateText}, ${kg} kg, ${bones} bones`,\n      w - padX,\n      h - pad\n    );\n    ctx.restore();\n  };\n  return (\n    \u0026lt;canvas\n      ref={onCanvasRef}\n      width={String(width * 2)}\n      height={String(height * 2)}\n    /\u0026gt;\n  );\n}\nconst FrameTextCached = React.memo(FrameText);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"how-is-mandelglitch-used\"\u003eHow is Mandelglitch used?\u003c/h3\u003e\n\u003cp\u003eAs said, \u003ca href=\"https://ethblock.art/create/17\"\u003eMandelglitch BlockStyle\u003c/a\u003e is re-used in this CryptoAliens BlockStyle. This really is the power of gl-react: it makes such composability really easy to do, the same way you can compose React components.\u003c/p\u003e\n\u003cp\u003eYou can see in the \u003ca href=\"https://www.youtube.com/watch?v=WUzOlLq0IAo\"\u003eYoutube recording\u003c/a\u003e the way I have implemented it initially: it is just a simple import of Mandelglitch.js (literally the BlockStyle as-is) that I can just send as a uniform sampler2D.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;Node\n  shader={sceneShaders.scene}\n  uniforms={{\n    t: \u0026lt;Mandelglitch block={block} mod1={mod1} mod2={mod2} mod3={mod3} /\u0026gt;,\n  ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eafter that, it was simpler to embed Mandelglitch in the BlockStyle.\u003c/p\u003e\n\u003cp\u003eThe way Mandelglitch texturing is used however is that I will only use the \u0026quot;red\u0026quot; component and remap it to CryptoAliens\u0026#39; own palette, in order to have a better control of the coloring.\u003c/p\u003e\n\u003ch3 id=\"code-organisation\"\u003eCode organisation\u003c/h3\u003e\n\u003cp\u003eReact and Gl-React allows to organize the code relatively easily. First of all each pass in the rendering scene is a component, then shaders are organized in the \u003ccode\u003eShaders.create\u003c/code\u003e usage. I\u0026#39;ve tried to collocate them (still in same one big file to simplify the upload to EthBlock.art).\u003c/p\u003e\n\u003cp\u003eI find it pretty convenient to externalize piece of the logic into \u0026quot;hooks\u0026quot; function. Example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst CustomStyle = (props) =\u0026gt; {\n  // prettier-ignore\n  const { block, attributesRef, mod1, mod2, mod3, mod4, highQuality, width, height } = props;\n  // prettier-ignore\n  const { kg, bones, theme, background, s1, s2, s3, s4, s5, s6, s7, s8, heavy, head, bonesK, armsLen, armsSpread, armsCenter, armsEndW, dateText, blockNumber } =\n    useBlockDerivedData(block, mod1, mod2, mod3, mod4);\n\n  useAttributesSync(attributesRef, kg, bones, theme);\n\n  return (\n    \u0026lt;LiveTV\n      text={\n        \u0026lt;FrameTextCached ... /\u0026gt;\n      }\n      ...\n    \u0026gt;\n      \u0026lt;NearestCopy width={w} height={h}\u0026gt;\n        \u0026lt;Scene\n          t={\u0026lt;MandelglitchCached ... /\u0026gt;}\n          ...\n        /\u0026gt;\n      \u0026lt;/NearestCopy\u0026gt;\n    \u0026lt;/LiveTV\u0026gt;\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003euseBlockDerivedData\u003c/code\u003e internally uses \u003ccode\u003euseMemo\u003c/code\u003e in order to cache the computation of block data interpretation.\u003c/p\u003e\n\u003cp\u003eIn order to make \u003cstrong\u003eonly\u003c/strong\u003e one part of the tree to actively re-render, i\u0026#39;ve used a local \u003ccode\u003euseTime\u003c/code\u003e that would re-render only that part (the LiveTV final shader). It\u0026#39;s implementation is trivial:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction useTime() {\n  const [time, setTime] = useState(0);\n  useEffect(() =\u0026gt; {\n    let startT;\n    let h;\n    function loop(t) {\n      h = requestAnimationFrame(loop);\n      if (!startT) startT = t;\n      setTime((t - startT) / 1000);\n    }\n    h = requestAnimationFrame(loop);\n    return () =\u0026gt; cancelAnimationFrame(h);\n  }, []);\n  return time;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"arms-joints-rotation-glsl-random-and-determinism\"\u003eArms joints rotation, GLSL random and determinism\u003c/h2\u003e\n\u003cp\u003eOk, this is a hard topic. But it\u0026#39;s extremely important that every BlockArt reliably produce the same result with the same block data, regardless of the computer used.\u003c/p\u003e\n\u003cp\u003eThat last \u0026quot;regardless of computer used\u0026quot; part has challenged me at the last minute! JavaScript doesn\u0026#39;t have this problem because it\u0026#39;s stable between implementations (computers, engines). However, \u003cstrong\u003ethis is not the case with OpenGL / GLSL\u003c/strong\u003e: every computer, every hardware (GPU) or possibly the \u0026quot;backend\u0026quot; implementation for WebGL (\u003ca href=\"https://github.com/google/angle\"\u003eANGLE\u003c/a\u003e have different backends) can differ when it comes to float precision and primitive results.\u003c/p\u003e\n\u003cp\u003eIn my shader, I was using the classical \u003ccode\u003erandom\u003c/code\u003e function that is documented at \u003ca href=\"https://thebookofshaders.com/10/\"\u003ehttps://thebookofshaders.com/10/\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003efloat random (vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt works very well when you need a nice 2D distributed noise for basic effects \u003cstrong\u003ebut it is very bad if you strongly rely on a stable \u0026amp; consistent noise to generate different shapes\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eEmpirically, I can observe that \u003ccode\u003esin()\u003c/code\u003e yields different results on different computers.\u003c/p\u003e\n\u003cp\u003eThis was impacting me badly because I was able to see very various shapes:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/cryptoaliens/rand1.png\" width=\"33%\"/\u003e\u003cimg src=\"/images/posts/cryptoaliens/rand2.png\" width=\"33%\"/\u003e\u003cimg src=\"/images/posts/cryptoaliens/rand3.png\" width=\"33%\"/\u003e\u003c/p\u003e\n\u003cp\u003eWhat I need to varies a bit here is just the angle at each joint of the arms. This is very important for the uniqueness of the creature. The problem is that if each value changes a tiny bit, the whole thing diverge VERY QUICKLY, as the rotation angle will accumulate.\u003c/p\u003e\n\u003cp\u003eWorse than that, I had a bad pattern to accumulate randomness like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003efloat ss1 = s1;\nfor (int i = 0; i \u0026lt; armsLen; i++) {\n  ss1 = random(ss1);\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eActually I don\u0026#39;t need that, first of all it\u0026#39;s probably not good for performance, secondly I can just afford taking the fractional part of a simple polynomial:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-cpp\"\u003efloat arm (inout vec3 p, float index, float w, float h) {\n  float s = sdSegment(p, h, w);\n  float base1 = 305.53 * s1 + 77.21 * index;\n  float base2 = 403.53 * s2 + 69.71 * index;\n  for (int i = 0; i \u0026lt; armsLen; i++) {\n    float fi = float(i);\n    float ss1 = fract(base1 + 9.412 * fi);\n    float ss2 = fract(base2 + 8.823 * fi);\n    pR(p.xy, 8. * s4 * (ss2-.5));\n    pR(p.xz, 6. * s5 * (ss1-.5));\n    s = fOpUnionSoft(bonesK, s, sdSegment(p, h, w));\n    h *= .9;\n    w *= .9;\n    p.y -= 1.2 * h;\n  }\n  s = fOpUnionSoft(bonesK + 0.2 * s5, s, length(p) - armsEndW);\n  return s;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that here it\u0026#39;s very arbitrary numbers, the point is to obtain variety and unpredictability in the results. \u003ccode\u003efract\u003c/code\u003e is a very simple operation (take the fractional part of the number). Indeed i\u0026#39;m still prone to approximation, but the risk is limited by the fact i don\u0026#39;t go too high in values here. Worse case scenario is it varies a bit the rotation but it should be so tiny that it won\u0026#39;t be visible.\u003c/p\u003e\n\u003cp\u003eAs said before and as seen in this code, the number will be used to do rotations (that \u003ccode\u003epR\u003c/code\u003e is transforming \u003ccode\u003ep\u003c/code\u003e with some rotations). I use \u003ccode\u003es4\u003c/code\u003e and \u003ccode\u003es5\u003c/code\u003e values to give the magnitude of rotations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLet\u0026#39;s look at a few cases:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIf both s4 and s5 are very near 0.0, it will be straight arms (it\u0026#39;s a rare case therefore).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/cryptoaliens/042_px.png\" width=\"50%\"/\u003e\u003cimg src=\"/images/posts/cryptoaliens/033_px.png\" width=\"50%\"/\u003e\u003c/p\u003e\n\u003cp\u003eIf one of the s4 or s5 are 0.0, it will be only happening on one \u0026quot;plan\u0026quot;, or slightly diverging spirals, which I assume also to be rare cases:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/cryptoaliens/017_px.png\" width=\"50%\"/\u003e\u003cimg src=\"/images/posts/cryptoaliens/020_px.png\" width=\"50%\"/\u003e\u003c/p\u003e\n\u003cp\u003eOtherwise, most of the times, it will be relatively random:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/cryptoaliens/029_px.png\" width=\"50%\"/\u003e\u003cimg src=\"/images/posts/cryptoaliens/032_px.png\" width=\"50%\"/\u003e\n\u003cimg src=\"/images/posts/cryptoaliens/028_px.png\" width=\"50%\"/\u003e\u003cimg src=\"/images/posts/cryptoaliens/026_px.png\" width=\"50%\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"going-128px-last-minute-decision-hard-tradeoff\"\u003egoing 128px. Last minute decision, hard tradeoff\u003c/h2\u003e\n\u003cp\u003eDue to concerns on the \u0026quot;deterministic rendering\u0026quot; from Ethblock.art folks, I had to make a choice regarding the fact it was too slow on mobile... I\u0026#39;ve decided to switch to 128x128 rendering for ALL platforms so it\u0026#39;s consistent.\u003c/p\u003e\n\u003cp\u003eAll the images on that article were done on 1024x1024 which is slow on computer and not even working on my mobile phone. (OnePlus)\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s hard to have efficient raymarching today when you have many items.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUltimately, I like how it finally looks, there were some minimalism / cell shaded styles,.. now it embraces Pixel Art even more!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/posts/cryptoaliens/r02.png\" width=\"50%\" /\u003e\u003cimg src=\"/images/posts/cryptoaliens/r01.png\" width=\"50%\" /\u003e\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s also always possible to make higher quality version of these rendering and I\u0026#39;m excited to experiment more of these in future.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eMy name is Gaëtan Renaudeau, and I\u0026#39;m a noise explorer. \u003cstrong\u003efeel free to ping me on Twitter \u003ca href=\"https://twitter.com/greweb\"\u003e@greweb\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n","data":{"title":"CryptoAliens: Genesis, a technical look","thumbnail":"/images/posts/cryptoaliens/026_px.png","description":"Technical aspects of CryptoAliens digital creatures generated with Ethereum blockchain blocks. They can be minted on ethblock.at by anyone, which establishes a limited set of CryptoAliens species.","tags":["NFT","shaders"]}},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2021","month":"04","slug":"cryptoaliens-tech"},"buildId":"hFDiHNZ0j540JSd1Mm1FP","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>