<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="author" content="Gaëtan Renaudeau"/><meta name="description" content="This second article (in a series of 7 articles) reveals the technique used to 3D render the Generative Nano S Plus collection: using a GLSL fragment shader, without any 3D model, but with raymarching distance function technique."/><meta name="keywords" content="NFT"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@greweb"/><meta name="twitter:title" content="GNSP – the 3D distance to a Nano S Plus"/><meta name="og:title" content="GNSP – the 3D distance to a Nano S Plus"/><meta name="twitter:description" content="This second article (in a series of 7 articles) reveals the technique used to 3D render the Generative Nano S Plus collection: using a GLSL fragment shader, without any 3D model, but with raymarching distance function technique."/><meta name="twitter:creator" content="@greweb"/><meta name="og:image" content="http://greweb.me//images/2021/12/gnsp/glitch.png"/><meta name="twitter:image" content="http://greweb.me//images/2021/12/gnsp/glitch.png"/><link rel="image_src" href="http://greweb.me//images/2021/12/gnsp/glitch.png"/><title>@greweb - GNSP – the 3D distance to a Nano S Plus</title><link href="http://fonts.googleapis.com/css?family=Fredericka+the+Great|Arapey|Roboto:400,700,400italic" rel="stylesheet" type="text/css"/><link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/styles/default.min.css"/><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/highlight.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/javascript.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/cpp.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/glsl.min.js"></script><link rel="stylesheet" href="/style/main.css"/><meta name="next-head-count" content="25"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-11911496995bbdbf52b1.js" defer=""></script><script src="/_next/static/chunks/framework-c93ed74a065331c4bd75.js" defer=""></script><script src="/_next/static/chunks/main-005750ed97c879f2d59b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-092526a60f8cb7d1b3d6.js" defer=""></script><script src="/_next/static/chunks/988-83f401159b53b3fa4628.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-098b94d3fea72f3bf0b3.js" defer=""></script><script src="/_next/static/J90BXkjy8Fm-TWfINBQyB/_buildManifest.js" defer=""></script><script src="/_next/static/J90BXkjy8Fm-TWfINBQyB/_ssgManifest.js" defer=""></script><style id="__jsx-2519965637">.block.jsx-2519965637{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.block.jsx-2519965637 .right.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637{margin-top:10px;}.block.jsx-2519965637 .social.jsx-2519965637 a.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637 img.jsx-2519965637{height:20px;}</style><style id="__jsx-3621368397">.container.jsx-3621368397{min-height:100vh;padding:0 0.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><style id="__jsx-3469673304">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto, Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue, sans-serif;}*{box-sizing:border-box;}a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a:hover,a:active{-webkit-text-decoration:underline;text-decoration:underline;}</style></head><body><div id="__next"><div class="jsx-3621368397 container"><div id="container"><div id="main"><div id="content"><article><header><h1><a href="/">GNSP – the 3D distance to a Nano S Plus</a></h1><time class="date" dateTime="2021-12-29">2021-12-29</time><span class="tags"><a class="tag">NFT</a></span></header><div class="entry-content"><p>This second article (in a series of 7 articles) reveals the technique used to 3D render the Generative Nano S Plus collection: using a GLSL fragment shader, without any 3D model, raymarching a calculated distance to a Nano S Plus.</p>
<p><video muted loop autoplay controls src="/images/2021/12/gnsp/509model.mp4" width="50%" style="float:left; margin-right: 40px; margin-bottom:20px"></video></p>
<p><strong>Timeline:</strong></p>
<ul>
<li><a href="/2021/12/gnsp">article 1: GNSP – the concept</a></li>
<li><a href="/2021/12/gnsp-raymarching"><strong>article 2: the 3D distance to a Nano S Plus</strong></a></li>
<li><a href="/2022/02/gnsp-nanoscreen">article 3: the nano screen</a></li>
<li><a href="/2022/02/gnsp-swivel">article 4: the swivel</a></li>
<li>article 5: the background</li>
<li>article 6: the video generation</li>
<li>article 7: the final drop</li>
<li>(?March) public mint</li>
</ul>
<p><strong>The collection is browsable on <a href="https://greweb.me/gnsp">https://greweb.me/gnsp</a></strong></p>
<p><strong>OpenSea: <a href="https://opensea.io/collection/gnsp">https://opensea.io/collection/gnsp</a></strong></p>
<br style="clear:left"/>

<h2 id="the-rendering-is-implemented-in-a-glsl-fragment-shader">The rendering is implemented in a GLSL Fragment Shader</h2>
<p>The generative art is rendered entirely into one &quot;fragment shader&quot;, which is essentially a GPU program that takes a bunch of inputs and efficiently calculates the pixel colors with your graphic card.</p>
<p>This is a paradigm I like to call &quot;Functional Rendering paradigm&quot;: see article <a href="https://observablehq.com/@gre/introduction-to-functional-rendering-paradigm">https://observablehq.com/@gre/introduction-to-functional-rendering-paradigm</a></p>
<p>On top of this paradigm, I have used a technique called Raymarching distance function, see article <a href="https://observablehq.com/@gre/introduction-to-raymarching-distance-functions">https://observablehq.com/@gre/introduction-to-raymarching-distance-functions</a></p>
<p>Here is the main algorithm that implement the raymarching: (where <code>map</code> is the distance function)</p>
<pre><code class="language-glsl">HIT marcher (inout vec3 p, vec3 dir) {
  HIT hit = HIT(0.);
  float t = 0.;
  for (int i=0; i&lt;120; i++) {
    HIT h = map(p + t * dir);
    t += h.x;
    if (abs(h.x) &lt; .0001) {
      hit = h;
      break;
    }
  }
  p += t * dir; 
  return hit;
}
</code></pre>
<p>A fun proof of this is to play with the number of raymarching iteration (modulating iterations from 0 to 120):</p>
<p><video muted loop autoplay controls src="/images/2021/12/gnsp/glitch.mp4" width="50%"></video><video muted loop autoplay controls src="/images/2021/12/gnsp/glitch2.mp4" width="50%"></video></p>
<p>The main scene is described in this &quot;map&quot; distance function:</p>
<pre><code class="language-glsl">HIT map (vec3 position) {
  HIT s = HIT(10. - length(position), 0.);
  float t = 3. * fract(time);
  float swivelAngle = PI * ( 1. +
    cubicInOut(min(1.0, t)) +
    cubicInOut(min(1.0, max(t - 1.8, 0.0))) );
  s = opU(s, sdLedgerNanoSPlus(position, swivelAngle));
  return s;
}
</code></pre>
<h2 id="the-3d-distance-to-a-nano-s-plus">The 3D distance to a Nano S Plus</h2>
<p>Essentially, a Nano S Plus can be rendered with a bunch of union, difference and intersection math operations. Here are the basic utilities I used:</p>
<pre><code class="language-glsl">// SHAPE PRIMITIVES:
float sdCylinder( vec3 p, vec3 c ) {
  return length(p.xz-c.xy)-c.z;
}
float sdCappedCylinder( vec3 p, float h, float r ) {
  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}
float sdBox( vec3 p, vec3 b ) {
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}
float sdBox2(in vec2 p, in vec2 b) {
  vec2 d = abs(p) - b;
  return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);
}
float sdBoxRoundZ(vec3 p, vec3 b, float r) {
  return max(sdBox2(p.xy, b.xy-r)-r, abs(p.z)-b.z);
}
// SHAPE OPERATIONS:
float fOpUnionRound(float a, float b, float r) {
  vec2 u = max(vec2(r - a,r - b), vec2(0));
  return max(r, min (a, b)) - length(u);
}
float fOpIntersectionRound(float a, float b, float r) {
  vec2 u = max(vec2(r + a,r + b), vec2(0));
  return min(-r, max (a, b)) + length(u);
}
float fOpDifferenceRound (float a, float b, float r) {
  return fOpIntersectionRound(a, -b, r);
}
float opSmoothSubtraction( float d1, float d2, float k ) {
  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );
  return mix( d2, -d1, h ) + k*h*(1.0-h);
}
void pR(inout vec2 p, float a) {
  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}
</code></pre>
<p>This code might seems complex, but it&#39;s relatively simple primitives, some are from this great article: <a href="https://iquilezles.org/www/articles/distfunctions/distfunctions.htm">https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</a></p>
<p>With these utilities, I have developed that function called <code>sdLedgerNanoSPlus</code>, that implements the <strong>distance to a Nano S Plus</strong>:</p>
<p><code>HIT sdLedgerNanoSPlus (vec3 p, float rot)</code></p>
<p>Knowing the &quot;space distance to an object&quot; allows to use a raymarching algorithm to render it in 3D.</p>
<p>The function takes two parameters <code>p</code> and <code>rot</code>:</p>
<ul>
<li><code>p</code> is the 3D point from which to evaluate the distance. If the Nano S Plus is at 1 meter away from the Nano S Plus, it must return a value of 1 meter. as simple as this.</li>
<li><code>rot</code> allows for me to control the rotation of the swivel, so it can be animated from the caller.</li>
</ul>
<p>The function returns one <code>HIT</code> value. <code>HIT</code> is a simple alias to <code>vec2</code>, which actually allows me to return a tuple of two values: <code>(distance, material)</code>. On top of the distance, I need to track what is the &quot;closest material&quot;. Basically answering the question: from the point <code>p</code> what is the part of the Nano S Plus that is the closest? For instance, the swivel, the plastic part, the screen,...</p>
<blockquote>
<p>I was able to take precise measurements from some wireframes of the actual device and tried to make it as close as possible, transposed into code.</p>
</blockquote>
<p>This is probably a lot of code to digest, but here is its implementation:</p>
<pre><code class="language-glsl">HIT sdLedgerNanoSPlus (vec3 p, float rot) {
  float btn = sdBoxRoundZ(
    vec3(abs(p.x - 0.18) - 0.22, p.z, p.y - 0.155),
    vec3(0.06, 0.03, 0.04), 0.03);
  float case2d = sdBox2(p.xy, vec2(0.624, 0.174)-0.08)-0.08;
  float swivel_hook = sdCylinder(p.xzy, vec3(-0.44, 0.0, 0.074));
  HIT s = HIT(max(
    min(
      opSmoothSubtraction(
            min(
          max(case2d+0.015, abs(p.z+0.12)-0.015), // main casing carving
          btn-0.004 // btns carving
        ),
        max(case2d, abs(p.z)-0.101) - 0.01, // main casing
        0.008
      ),
      min(
        btn,
        max(swivel_hook-0.015, abs(p.z)-0.12) // plastic in the casing for the swivel
      )
    ),
    -swivel_hook // carve the swivel hook out
  ), 2.05);
  // screen
  float screen2 = sdBox2(p.xy - vec2(0.18, 0.), vec2(0.27, 0.12));
  s = opU(s, HIT(max(s.x, screen2), 2.1));
  // swivel
  p.x += 0.04;
  p.x += 0.4;
  pR(p.xy, rot);
  p.x -= 0.4;
  float w = 0.54;
  float x = p.x + 0.8;
  float z = abs(p.z) - 0.12;
  float swivel_radius = 0.192;
  float swivel_metal_width = 0.006;
  float rounding = 0.003;
  float swivel = opSmoothSubtraction(
    sdCylinder(p.xzy, vec3(-0.4, 0.0, 0.08)), // carved
    min(
      sdCappedCylinder(vec3(p.y, z, x - 0.4), swivel_radius, swivel_metal_width),
      sdBox(vec3(x - 0.41 + w, p.y, z), vec3(w, swivel_radius, swivel_metal_width))
    )-rounding,
    0.04
  );
  // metal to close the swivel end
  swivel = fOpUnionRound(swivel,
    sdBox(vec3(x + 0.135 + w, p.y, p.z), vec3(swivel_metal_width, swivel_radius, 0.123))
  ,0.01);
  noiseMetal = fbm(vec2(40.0, 1000.) * p.xy);
  vec2 coord = fract(vec2(1.0, -3.0) * p.xy + vec2(0.5));
  vec4 mt = texture2D(metalText, coord);
  float t = mix(0., grayscale(mt.rgb),mt.a * step(p.z, 0.) * step(p.x, -0.5) * step(abs(p.y), 0.16));
  float swivelM = 2.2 + t;
  s = opU(s, HIT(swivel, swivelM));
  return s;
}
</code></pre>
<p>To visualize it more, I&#39;ve animated the code to make it show the different steps union and difference operations:</p>
<p><video muted loop autoplay controls src="/images/2021/12/gnsp/model.mp4" width="100%"></video></p>
<p>But let&#39;s try to dive into more details and tricks.</p>
<h3 id="the-main-casing">The main casing</h3>
<p>The first part of the function is making the plastic casing:</p>
<pre><code class="language-glsl">float btn = sdBoxRoundZ(
  vec3(abs(p.x - 0.18) - 0.22, p.z, p.y - 0.155),
  vec3(0.06, 0.03, 0.04), 0.03);
float case2d = sdBox2(p.xy, vec2(0.624, 0.174)-0.08)-0.08;
float swivel_hook = sdCylinder(p.xzy, vec3(-0.44, 0.0, 0.074));
HIT s = HIT(max(
  min(
    opSmoothSubtraction(
      min(
        max(case2d+0.015, abs(p.z+0.12)-0.015), // main casing carving
        btn-0.004 // btns carving
      ),
      max(case2d, abs(p.z)-0.101) - 0.01, // main casing
      0.008
    ),
    min(
      btn, // buttons themself
      max(swivel_hook-0.015, abs(p.z)-0.12) // plastic in the casing for the swivel
    )
  ),
  -swivel_hook // carve the swivel hook out
), 2.05);
</code></pre>
<p>We can see that I use a lot of <code>min()</code> to combine the primitives. when you apply <code>min(A,B)</code> between the distance of objects A and B it is essentially the distance to the union of A and B, because min returns the closest distance. so <code>min</code> is an union.</p>
<p>We can also see the use of many <code>max()</code> like for instance <code>max(case2d, abs(p.z)-0.101) - 0.01</code> which renders a rounded box but with sharp edge on the Z axis:</p>
<p><img src="/images/2021/12/gnsp/casing.png" alt=""></p>
<blockquote>
<p><code>max(A, B)</code> is basically the intersection of A and B. Sadly, it&#39;s not an &quot;exact&quot; distance that limits the ability to bevel a tiny bit the edge. If someone have a trick to implement this shape with the exact distance, I would love to know.</p>
</blockquote>
<p><code>max(case2d, abs(p.z)-0.101) - 0.01</code> is therefore made of the intersection of:</p>
<ul>
<li><code>case2d</code> is a 2D box in xy space. defined by <code>sdBox2(p.xy, vec2(0.624, 0.174)-0.08)-0.08</code>. The value 0.8 is removed from the box dimension but also then removed from the distance. That value is actually the border radius of the box.</li>
<li><code>abs(p.z)</code> is the distance to the Z plan. <code>abs(p.z)-0.101</code> is distance to a volume of the plan enlarged with a <code>0.101</code> padding.</li>
</ul>
<h3 id="carving-out">Carving out</h3>
<p><img src="/images/2021/12/gnsp/casingdig.png" alt=""></p>
<p>The first operation done on the casing is to carve the part of the buttons and the inside. This is essentially done with the operation <code>max(A, -B)</code> (remove B from A), except here we are using a smooth difference operation to not make too &quot;sharp&quot; cuts.</p>
<p>The same technique is used on the swivel hole:</p>
<p><img src="/images/2021/12/gnsp/casingdig2.png" alt=""></p>
<p>And again done on the model swivel shape:</p>
<p><img src="/images/2021/12/gnsp/swiveldig.png" alt=""></p>
<p><strong>but for the swivel, it is done with a &quot;smoothing difference&quot;</strong>, which creates the nice rounded effect in the hole:</p>
<p><img src="/images/2021/12/gnsp/swiveldigresult.png" alt=""></p>
<p>Here is the code that do this:</p>
<pre><code class="language-glsl">opSmoothSubtraction(
  sdCylinder(p.xzy, vec3(-0.4, 0.0, 0.08)), // the carving shape is a cylinder
  min(
    sdCappedCylinder(vec3(p.y, z, x - 0.4), swivel_radius, swivel_metal_width), // circle of the swivel
    sdBox(vec3(x - 0.41 + w, p.y, z), vec3(w, swivel_radius, swivel_metal_width)) // long rectangle metal part
  )-rounding, // add a bit of rounding (bevel)
  0.04
)
</code></pre>
<p>and if we tweak that 0.04 value between 0.0 and 0.1, we obtain this interesting range of smoothing subtraction:</p>
<p><video muted loop autoplay controls src="/images/2021/12/gnsp/smoothdiff.mp4" width="50%"></video><video muted loop autoplay controls src="/images/2021/12/gnsp/smoothdiff2.mp4" width="50%"></video></p>
<p>There would be so much to improve in the modelization. For instance, I couldn&#39;t figure out a simple way to make the smooth corner of the swivel metal, so I end up with this simplification which isn&#39;t perfect:</p>
<p><img src="/images/2021/12/gnsp/modelsimpl.png" alt=""></p>
<pre><code class="language-glsl">// metal to close the swivel end
swivel = fOpUnionRound(swivel,
  sdBox(vec3(x + 0.135 + w, p.y, p.z), vec3(swivel_metal_width, swivel_radius, 0.123))
,0.01);
</code></pre>
<p>Distance function can always be optimized and details can always be added, possibilities are infinite it&#39;s only a matter of how much hours do you want to spend on. And on my case, it was basically a weekend.</p>
<h2 id="lighting-and-material">Lighting and material</h2>
<p>There would be a lot to write about the accumulation of techniques used for the lightning. Basically there are 2-3 lights in the scene and some are casting some shadows using raymarching as well.</p>
<p><video muted loop autoplay controls src="/images/2021/12/gnsp/material.mp4" width="100%"></video></p>
<p><em>That video looks surprisingly so professional, I love it!</em> The scene is just this code:</p>
<pre><code class="language-glsl">HIT map (vec3 p) {
  HIT s = HIT(10. - length(p), 0.);
  s = opU(s, HIT(length(p)-0.5, 2.05)); // sphere distance is just length(p)-radius
  return s;
}
</code></pre>
<p>It shows the rendering of a sphere on the plastic material. Before I talk about the materials, let&#39;s focus on the lighting.</p>
<h3 id="the-lighting">The lighting</h3>
<p>The general code that renders the scene is pretty straightforward:</p>
<pre><code class="language-glsl">vec3 scene(vec2 uv) {
  vec3 c = vec3(0.); // color of the pixel to set
  vec3 p = cameraP;
  vec3 dir = normalize(vec3(uv - .5, 1.)); // perspective camera
  dir = lookAt(cameraP, focusP) * dir; // camera focus on a point
  HIT hit = marcher(p, dir); // this throw camera ray and tells what points it hits (material and distance)
  vec3 n = normal(p); // this calculates the NORMAL VECTOR on the surface of the hit object
  c += lighting(hit, p, n, dir); // &lt;= THIS IS WHERE LIGHTING IS CALCULATED
  c = mix(c, sceneBgColor, pow(smoothstep(4., 10., length(p-cameraP)), .5)); // mist on far away objects
  return c;
}
</code></pre>
<p>Ok, so as you can see on the previous video, we have essentially 2 lights in the scene, one blueish and one redish. They spread differently in the material to simulate a bit their different size. We however can see the user of a THIRD light, which is more in the back and will be useful to simulate the fact the background is emitting its color. This was very useful for strong background colors like orange:</p>
<p><video muted loop autoplay controls src="/images/2021/12/gnsp/100.mp4" width="100%"></video></p>
<p>This is what lighting is implementing:</p>
<pre><code class="language-glsl">vec3 lighting (HIT hit, vec3 p, vec3 n, vec3 dir) { // (code is a bit simplified from original)
  vec3 l, ldir;
  vec3 c = vec3(0.);
  l = vec3(lightPos, 1.5, -3.4);
  vec3 obj = shade(hit, p);
  ldir = normalize(l - p);
  c +=
  0.92 * vec3(0.9, 0.7, 0.6) * (
    // ambient
    0.1
    // diffuse
    + obj
      * (.5 + .5 * diffuse(p, n, l)) // half lambert
      * (0.5 + 0.5 * softshadow(p, ldir, 0.05, 5., 8.))
    + specular(n, p, hit.y, ldir, dir, 10.)
  );
  l = vec3(-lightPos, 5., -2.);
  ldir = normalize(l - p);
  c +=
  0.92 * vec3(0.3, 0.5, 0.6) * (
  // ambient
  0.1
  // diffuse
  + obj
    * (.5 + .5 * diffuse(p, n, l)) // half lambert
  + specular(n, p, hit.y, ldir, dir, 20.)
  );

  l = vec3(0., 2., 8.);
  ldir = normalize(l - p);
  c += bgLightColor * (
    obj
    * diffuse(p, n, l)
    + specular(n, p, hit.y, ldir, dir, 20.)
  );
  return c;
}
</code></pre>
<p>You can see the first thing done here is:</p>
<pre><code>  vec3 obj = shade(hit, p);
</code></pre>
<p>It is a very important step that ask the hit object material &quot;give me your color&quot;. I will cover it in the Material section.</p>
<p>Then for each light I want to apply, you can see the same pattern:</p>
<p>First of all, we will put the light at a specific position in the space. For instance:</p>
<pre><code class="language-glsl">l = vec3(lightPos, 1.5, -3.4);
</code></pre>
<p>we calculate the actual light direction with <code>p</code> which is the point of interest to color.</p>
<pre><code class="language-glsl">ldir = normalize(l - p);
</code></pre>
<p>And then we can finally add to the object its emitted color:</p>
<pre><code class="language-glsl">  c +=
  0.92 * vec3(0.9, 0.7, 0.6) * (
    // ambient
    0.1
    // diffuse
    + obj
      * (.5 + .5 * diffuse(p, n, l)) // half lambert
      * (0.5 + 0.5 * softshadow(p, ldir, 0.05, 5., 8.))
    + specular(n, p, hit.y, ldir, dir, 10.)
  );
</code></pre>
<p>and there are a few components that is very inspired by the classical &quot;ambient diffuse specular&quot; paradigm: <a href="https://learnopengl.com/Lighting/Basic-Lighting">https://learnopengl.com/Lighting/Basic-Lighting</a> which I recommend you to read if you want to dive more into this part.</p>
<p>In my case, I use half lambert technique which I find really interesting for a cartoon-ish effect <a href="https://developer.valvesoftware.com/wiki/Half_Lambert">https://developer.valvesoftware.com/wiki/Half_Lambert</a> and because i don&#39;t use expensive ambient occlusion.</p>
<p>I also, in this light case, will use <code>softshadow</code> that cast a shadow toward the light direction.</p>
<p><strong>specular</strong> function is an important utility that have this implementation:</p>
<pre><code class="language-glsl">float specular (vec3 n, vec3 pos, float m, vec3 ldir, vec3 dir, float p) {
  return specularStrength(m, n, pos) * pow(max(dot(dir, reflect(ldir, n)), 0.0), p);
}
</code></pre>
<p>note that we can have different &quot;specular strength&quot; for each material or even depending on the position.</p>
<h3 id="the-material-specularstrength">The material <code>specularStrength()</code></h3>
<p><video muted loop autoplay controls src="/images/2021/12/gnsp/material.mp4" width="100%"></video></p>
<p>As we can see in this material, the plastic has been added some texturing.</p>
<p>This is implemented with a fbm noise and it is contained in the material value.</p>
<p>Then I had two possible ways to make it visible: either I change the color of the material OR I change the way it reflect lights in <code>specularStrength</code>. I&#39;ve used the second option for the plastic case:</p>
<pre><code class="language-glsl">float noiseMetal;
float specularStrength (float m, vec3 n, vec3 p) {
  if (m &lt; 2.1) {
      float v =
        n.z * fbm(600. * p.xy) +
        n.x * fbm(600. * p.yz) +
        n.y * fbm(600. * p.xz);
      return 0.4 + 0.3 * v;
  }
  if (m &lt; 2.2) {
    return 2.0;
  }
  if (m &lt; 4.) {
    return 0.6 - 0.5 * noiseMetal + 1. * ceil(m-2.21);
  }
  return 0.4;
}
</code></pre>
<p>So pretty basic stuff, I use <code>m</code> material value, which is a one dimension value to express all materials in. in plastic case, we are in the <code>m &lt; 2.1</code> case which have a strong noise frequency.</p>
<p>On the same principle, we can see it is also done for the swivel metal.</p>
<p>I used some trickery here because, as the swivel is moving, I had to use a global variable to set the noise value because I don&#39;t have the &quot;local position&quot;, only the global position.</p>
<p>The <code>noiseMetal</code> is set directly from the <code>sdLedgerNanoSPlus</code> function with this:</p>
<pre><code class="language-glsl">noiseMetal = fbm(vec2(40.0, 1000.) * p.xy);
</code></pre>
<p>where <code>p</code> is a local position of the swivel, contextual to the rotation applied to it.</p>
<p>The 40/1000 implements a stretched fbm noise which nicely recreates the effect:</p>
<p><img src="/images/2021/12/gnsp/metaltexture.jpg" alt=""></p>
<h3 id="the-material-shade">The material <code>shade()</code></h3>
<p><code>shade(hit,p)</code> is essentially the material coloring function. It tells what color does the object reflect at a given hit position.</p>
<p>Here is its implementation for the whole scene (I have omitted some part that will be covered in other articles):</p>
<pre><code class="language-glsl">vec3 shade (HIT hit, vec3 p) {
  if (hit.y &lt; 2.0) return sceneBgColor;
  if (hit.y &lt; 4.0) {
    if (hit.y &lt; 2.1) {
        return plasticColor;
    }
    if (hit.y &lt; 2.2) {
      return ...SCREEN RENDERING HERE...;
    }
    // swivel metal
    return vec3(0.7 - 0.1 * noiseMetal - 0.2 * (hit.y - 2.2));
  }
  if (hit.y &lt; 5.0) {
    return stickerColor;
  }
  return vec3(0.0);
}
</code></pre>
<p>So it&#39;s a simple, &quot;give me the color of the material id number&quot;. The only trick for the noise metal was to make it a bit darker on some part to accentuate the metal effect.</p>
<p><strong>The next article is going to dive into what this <code>...SCREEN RENDERING HERE...</code> part is doing, and more generally how I managed to also make the screen display text from inside a shader!</strong></p>
</div><footer><div class="jsx-2519965637 block"><img src="http://greweb.me/logo.svg" width="100" class="jsx-2519965637"/><div class="jsx-2519965637 right"><div class="jsx-2519965637 description">generative artist. doodling with algorithms (creative coding). shaders &amp; fountain pens robot plotting.</div><div class="jsx-2519965637 social"><a href="https://twitter.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitter.svg" class="jsx-2519965637"/></a><a href="https://instagram.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/instagram.svg" class="jsx-2519965637"/></a><a href="https://twitch.tv/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitch.svg" class="jsx-2519965637"/></a><a href="https://github.com/gre" class="jsx-2519965637"><img alt="" src="/icons/github.svg" class="jsx-2519965637"/></a><a href="https://opensea.io/greweb" class="jsx-2519965637"><img alt="" src="/icons/eth.svg" class="jsx-2519965637"/></a><a href="https://objkt.com/profile/tz1cgQAQfECg5bPASYTMyJ9QJQjSUi8rfL67" class="jsx-2519965637"><img alt="" src="/icons/tz.svg" class="jsx-2519965637"/></a><a href="https://fxhash.xyz/u/greweb" class="jsx-2519965637"><img alt="" src="/icons/tz.svg" class="jsx-2519965637"/></a><a href="https://greweb.itch.io" class="jsx-2519965637"><img alt="" src="/icons/iconmonstr-gamepad-3.svg" class="jsx-2519965637"/></a></div></div></div></footer></article></div></div></div><script>hljs.highlightAll();</script></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"2021-12-29-gnsp-raymarching","year":"2021","month":"12","day":"29","slug":"gnsp-raymarching","content":"\u003cp\u003eThis second article (in a series of 7 articles) reveals the technique used to 3D render the Generative Nano S Plus collection: using a GLSL fragment shader, without any 3D model, raymarching a calculated distance to a Nano S Plus.\u003c/p\u003e\n\u003cp\u003e\u003cvideo muted loop autoplay controls src=\"/images/2021/12/gnsp/509model.mp4\" width=\"50%\" style=\"float:left; margin-right: 40px; margin-bottom:20px\"\u003e\u003c/video\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTimeline:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/2021/12/gnsp\"\u003earticle 1: GNSP – the concept\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/2021/12/gnsp-raymarching\"\u003e\u003cstrong\u003earticle 2: the 3D distance to a Nano S Plus\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/2022/02/gnsp-nanoscreen\"\u003earticle 3: the nano screen\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/2022/02/gnsp-swivel\"\u003earticle 4: the swivel\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003earticle 5: the background\u003c/li\u003e\n\u003cli\u003earticle 6: the video generation\u003c/li\u003e\n\u003cli\u003earticle 7: the final drop\u003c/li\u003e\n\u003cli\u003e(?March) public mint\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eThe collection is browsable on \u003ca href=\"https://greweb.me/gnsp\"\u003ehttps://greweb.me/gnsp\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOpenSea: \u003ca href=\"https://opensea.io/collection/gnsp\"\u003ehttps://opensea.io/collection/gnsp\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cbr style=\"clear:left\"/\u003e\n\n\u003ch2 id=\"the-rendering-is-implemented-in-a-glsl-fragment-shader\"\u003eThe rendering is implemented in a GLSL Fragment Shader\u003c/h2\u003e\n\u003cp\u003eThe generative art is rendered entirely into one \u0026quot;fragment shader\u0026quot;, which is essentially a GPU program that takes a bunch of inputs and efficiently calculates the pixel colors with your graphic card.\u003c/p\u003e\n\u003cp\u003eThis is a paradigm I like to call \u0026quot;Functional Rendering paradigm\u0026quot;: see article \u003ca href=\"https://observablehq.com/@gre/introduction-to-functional-rendering-paradigm\"\u003ehttps://observablehq.com/@gre/introduction-to-functional-rendering-paradigm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eOn top of this paradigm, I have used a technique called Raymarching distance function, see article \u003ca href=\"https://observablehq.com/@gre/introduction-to-raymarching-distance-functions\"\u003ehttps://observablehq.com/@gre/introduction-to-raymarching-distance-functions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eHere is the main algorithm that implement the raymarching: (where \u003ccode\u003emap\u003c/code\u003e is the distance function)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003eHIT marcher (inout vec3 p, vec3 dir) {\n  HIT hit = HIT(0.);\n  float t = 0.;\n  for (int i=0; i\u0026lt;120; i++) {\n    HIT h = map(p + t * dir);\n    t += h.x;\n    if (abs(h.x) \u0026lt; .0001) {\n      hit = h;\n      break;\n    }\n  }\n  p += t * dir; \n  return hit;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA fun proof of this is to play with the number of raymarching iteration (modulating iterations from 0 to 120):\u003c/p\u003e\n\u003cp\u003e\u003cvideo muted loop autoplay controls src=\"/images/2021/12/gnsp/glitch.mp4\" width=\"50%\"\u003e\u003c/video\u003e\u003cvideo muted loop autoplay controls src=\"/images/2021/12/gnsp/glitch2.mp4\" width=\"50%\"\u003e\u003c/video\u003e\u003c/p\u003e\n\u003cp\u003eThe main scene is described in this \u0026quot;map\u0026quot; distance function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003eHIT map (vec3 position) {\n  HIT s = HIT(10. - length(position), 0.);\n  float t = 3. * fract(time);\n  float swivelAngle = PI * ( 1. +\n    cubicInOut(min(1.0, t)) +\n    cubicInOut(min(1.0, max(t - 1.8, 0.0))) );\n  s = opU(s, sdLedgerNanoSPlus(position, swivelAngle));\n  return s;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"the-3d-distance-to-a-nano-s-plus\"\u003eThe 3D distance to a Nano S Plus\u003c/h2\u003e\n\u003cp\u003eEssentially, a Nano S Plus can be rendered with a bunch of union, difference and intersection math operations. Here are the basic utilities I used:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003e// SHAPE PRIMITIVES:\nfloat sdCylinder( vec3 p, vec3 c ) {\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBox2(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\nfloat sdBoxRoundZ(vec3 p, vec3 b, float r) {\n  return max(sdBox2(p.xy, b.xy-r)-r, abs(p.z)-b.z);\n}\n// SHAPE OPERATIONS:\nfloat fOpUnionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r - a,r - b), vec2(0));\n  return max(r, min (a, b)) - length(u);\n}\nfloat fOpIntersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a,r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\nfloat fOpDifferenceRound (float a, float b, float r) {\n  return fOpIntersectionRound(a, -b, r);\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nvoid pR(inout vec2 p, float a) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code might seems complex, but it\u0026#39;s relatively simple primitives, some are from this great article: \u003ca href=\"https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\"\u003ehttps://iquilezles.org/www/articles/distfunctions/distfunctions.htm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eWith these utilities, I have developed that function called \u003ccode\u003esdLedgerNanoSPlus\u003c/code\u003e, that implements the \u003cstrong\u003edistance to a Nano S Plus\u003c/strong\u003e:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eHIT sdLedgerNanoSPlus (vec3 p, float rot)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eKnowing the \u0026quot;space distance to an object\u0026quot; allows to use a raymarching algorithm to render it in 3D.\u003c/p\u003e\n\u003cp\u003eThe function takes two parameters \u003ccode\u003ep\u003c/code\u003e and \u003ccode\u003erot\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ep\u003c/code\u003e is the 3D point from which to evaluate the distance. If the Nano S Plus is at 1 meter away from the Nano S Plus, it must return a value of 1 meter. as simple as this.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erot\u003c/code\u003e allows for me to control the rotation of the swivel, so it can be animated from the caller.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe function returns one \u003ccode\u003eHIT\u003c/code\u003e value. \u003ccode\u003eHIT\u003c/code\u003e is a simple alias to \u003ccode\u003evec2\u003c/code\u003e, which actually allows me to return a tuple of two values: \u003ccode\u003e(distance, material)\u003c/code\u003e. On top of the distance, I need to track what is the \u0026quot;closest material\u0026quot;. Basically answering the question: from the point \u003ccode\u003ep\u003c/code\u003e what is the part of the Nano S Plus that is the closest? For instance, the swivel, the plastic part, the screen,...\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI was able to take precise measurements from some wireframes of the actual device and tried to make it as close as possible, transposed into code.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis is probably a lot of code to digest, but here is its implementation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003eHIT sdLedgerNanoSPlus (vec3 p, float rot) {\n  float btn = sdBoxRoundZ(\n    vec3(abs(p.x - 0.18) - 0.22, p.z, p.y - 0.155),\n    vec3(0.06, 0.03, 0.04), 0.03);\n  float case2d = sdBox2(p.xy, vec2(0.624, 0.174)-0.08)-0.08;\n  float swivel_hook = sdCylinder(p.xzy, vec3(-0.44, 0.0, 0.074));\n  HIT s = HIT(max(\n    min(\n      opSmoothSubtraction(\n            min(\n          max(case2d+0.015, abs(p.z+0.12)-0.015), // main casing carving\n          btn-0.004 // btns carving\n        ),\n        max(case2d, abs(p.z)-0.101) - 0.01, // main casing\n        0.008\n      ),\n      min(\n        btn,\n        max(swivel_hook-0.015, abs(p.z)-0.12) // plastic in the casing for the swivel\n      )\n    ),\n    -swivel_hook // carve the swivel hook out\n  ), 2.05);\n  // screen\n  float screen2 = sdBox2(p.xy - vec2(0.18, 0.), vec2(0.27, 0.12));\n  s = opU(s, HIT(max(s.x, screen2), 2.1));\n  // swivel\n  p.x += 0.04;\n  p.x += 0.4;\n  pR(p.xy, rot);\n  p.x -= 0.4;\n  float w = 0.54;\n  float x = p.x + 0.8;\n  float z = abs(p.z) - 0.12;\n  float swivel_radius = 0.192;\n  float swivel_metal_width = 0.006;\n  float rounding = 0.003;\n  float swivel = opSmoothSubtraction(\n    sdCylinder(p.xzy, vec3(-0.4, 0.0, 0.08)), // carved\n    min(\n      sdCappedCylinder(vec3(p.y, z, x - 0.4), swivel_radius, swivel_metal_width),\n      sdBox(vec3(x - 0.41 + w, p.y, z), vec3(w, swivel_radius, swivel_metal_width))\n    )-rounding,\n    0.04\n  );\n  // metal to close the swivel end\n  swivel = fOpUnionRound(swivel,\n    sdBox(vec3(x + 0.135 + w, p.y, p.z), vec3(swivel_metal_width, swivel_radius, 0.123))\n  ,0.01);\n  noiseMetal = fbm(vec2(40.0, 1000.) * p.xy);\n  vec2 coord = fract(vec2(1.0, -3.0) * p.xy + vec2(0.5));\n  vec4 mt = texture2D(metalText, coord);\n  float t = mix(0., grayscale(mt.rgb),mt.a * step(p.z, 0.) * step(p.x, -0.5) * step(abs(p.y), 0.16));\n  float swivelM = 2.2 + t;\n  s = opU(s, HIT(swivel, swivelM));\n  return s;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo visualize it more, I\u0026#39;ve animated the code to make it show the different steps union and difference operations:\u003c/p\u003e\n\u003cp\u003e\u003cvideo muted loop autoplay controls src=\"/images/2021/12/gnsp/model.mp4\" width=\"100%\"\u003e\u003c/video\u003e\u003c/p\u003e\n\u003cp\u003eBut let\u0026#39;s try to dive into more details and tricks.\u003c/p\u003e\n\u003ch3 id=\"the-main-casing\"\u003eThe main casing\u003c/h3\u003e\n\u003cp\u003eThe first part of the function is making the plastic casing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003efloat btn = sdBoxRoundZ(\n  vec3(abs(p.x - 0.18) - 0.22, p.z, p.y - 0.155),\n  vec3(0.06, 0.03, 0.04), 0.03);\nfloat case2d = sdBox2(p.xy, vec2(0.624, 0.174)-0.08)-0.08;\nfloat swivel_hook = sdCylinder(p.xzy, vec3(-0.44, 0.0, 0.074));\nHIT s = HIT(max(\n  min(\n    opSmoothSubtraction(\n      min(\n        max(case2d+0.015, abs(p.z+0.12)-0.015), // main casing carving\n        btn-0.004 // btns carving\n      ),\n      max(case2d, abs(p.z)-0.101) - 0.01, // main casing\n      0.008\n    ),\n    min(\n      btn, // buttons themself\n      max(swivel_hook-0.015, abs(p.z)-0.12) // plastic in the casing for the swivel\n    )\n  ),\n  -swivel_hook // carve the swivel hook out\n), 2.05);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can see that I use a lot of \u003ccode\u003emin()\u003c/code\u003e to combine the primitives. when you apply \u003ccode\u003emin(A,B)\u003c/code\u003e between the distance of objects A and B it is essentially the distance to the union of A and B, because min returns the closest distance. so \u003ccode\u003emin\u003c/code\u003e is an union.\u003c/p\u003e\n\u003cp\u003eWe can also see the use of many \u003ccode\u003emax()\u003c/code\u003e like for instance \u003ccode\u003emax(case2d, abs(p.z)-0.101) - 0.01\u003c/code\u003e which renders a rounded box but with sharp edge on the Z axis:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021/12/gnsp/casing.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003emax(A, B)\u003c/code\u003e is basically the intersection of A and B. Sadly, it\u0026#39;s not an \u0026quot;exact\u0026quot; distance that limits the ability to bevel a tiny bit the edge. If someone have a trick to implement this shape with the exact distance, I would love to know.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ccode\u003emax(case2d, abs(p.z)-0.101) - 0.01\u003c/code\u003e is therefore made of the intersection of:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecase2d\u003c/code\u003e is a 2D box in xy space. defined by \u003ccode\u003esdBox2(p.xy, vec2(0.624, 0.174)-0.08)-0.08\u003c/code\u003e. The value 0.8 is removed from the box dimension but also then removed from the distance. That value is actually the border radius of the box.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eabs(p.z)\u003c/code\u003e is the distance to the Z plan. \u003ccode\u003eabs(p.z)-0.101\u003c/code\u003e is distance to a volume of the plan enlarged with a \u003ccode\u003e0.101\u003c/code\u003e padding.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"carving-out\"\u003eCarving out\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021/12/gnsp/casingdig.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eThe first operation done on the casing is to carve the part of the buttons and the inside. This is essentially done with the operation \u003ccode\u003emax(A, -B)\u003c/code\u003e (remove B from A), except here we are using a smooth difference operation to not make too \u0026quot;sharp\u0026quot; cuts.\u003c/p\u003e\n\u003cp\u003eThe same technique is used on the swivel hole:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021/12/gnsp/casingdig2.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eAnd again done on the model swivel shape:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021/12/gnsp/swiveldig.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ebut for the swivel, it is done with a \u0026quot;smoothing difference\u0026quot;\u003c/strong\u003e, which creates the nice rounded effect in the hole:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021/12/gnsp/swiveldigresult.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eHere is the code that do this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003eopSmoothSubtraction(\n  sdCylinder(p.xzy, vec3(-0.4, 0.0, 0.08)), // the carving shape is a cylinder\n  min(\n    sdCappedCylinder(vec3(p.y, z, x - 0.4), swivel_radius, swivel_metal_width), // circle of the swivel\n    sdBox(vec3(x - 0.41 + w, p.y, z), vec3(w, swivel_radius, swivel_metal_width)) // long rectangle metal part\n  )-rounding, // add a bit of rounding (bevel)\n  0.04\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand if we tweak that 0.04 value between 0.0 and 0.1, we obtain this interesting range of smoothing subtraction:\u003c/p\u003e\n\u003cp\u003e\u003cvideo muted loop autoplay controls src=\"/images/2021/12/gnsp/smoothdiff.mp4\" width=\"50%\"\u003e\u003c/video\u003e\u003cvideo muted loop autoplay controls src=\"/images/2021/12/gnsp/smoothdiff2.mp4\" width=\"50%\"\u003e\u003c/video\u003e\u003c/p\u003e\n\u003cp\u003eThere would be so much to improve in the modelization. For instance, I couldn\u0026#39;t figure out a simple way to make the smooth corner of the swivel metal, so I end up with this simplification which isn\u0026#39;t perfect:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021/12/gnsp/modelsimpl.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003e// metal to close the swivel end\nswivel = fOpUnionRound(swivel,\n  sdBox(vec3(x + 0.135 + w, p.y, p.z), vec3(swivel_metal_width, swivel_radius, 0.123))\n,0.01);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDistance function can always be optimized and details can always be added, possibilities are infinite it\u0026#39;s only a matter of how much hours do you want to spend on. And on my case, it was basically a weekend.\u003c/p\u003e\n\u003ch2 id=\"lighting-and-material\"\u003eLighting and material\u003c/h2\u003e\n\u003cp\u003eThere would be a lot to write about the accumulation of techniques used for the lightning. Basically there are 2-3 lights in the scene and some are casting some shadows using raymarching as well.\u003c/p\u003e\n\u003cp\u003e\u003cvideo muted loop autoplay controls src=\"/images/2021/12/gnsp/material.mp4\" width=\"100%\"\u003e\u003c/video\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThat video looks surprisingly so professional, I love it!\u003c/em\u003e The scene is just this code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003eHIT map (vec3 p) {\n  HIT s = HIT(10. - length(p), 0.);\n  s = opU(s, HIT(length(p)-0.5, 2.05)); // sphere distance is just length(p)-radius\n  return s;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt shows the rendering of a sphere on the plastic material. Before I talk about the materials, let\u0026#39;s focus on the lighting.\u003c/p\u003e\n\u003ch3 id=\"the-lighting\"\u003eThe lighting\u003c/h3\u003e\n\u003cp\u003eThe general code that renders the scene is pretty straightforward:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003evec3 scene(vec2 uv) {\n  vec3 c = vec3(0.); // color of the pixel to set\n  vec3 p = cameraP;\n  vec3 dir = normalize(vec3(uv - .5, 1.)); // perspective camera\n  dir = lookAt(cameraP, focusP) * dir; // camera focus on a point\n  HIT hit = marcher(p, dir); // this throw camera ray and tells what points it hits (material and distance)\n  vec3 n = normal(p); // this calculates the NORMAL VECTOR on the surface of the hit object\n  c += lighting(hit, p, n, dir); // \u0026lt;= THIS IS WHERE LIGHTING IS CALCULATED\n  c = mix(c, sceneBgColor, pow(smoothstep(4., 10., length(p-cameraP)), .5)); // mist on far away objects\n  return c;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOk, so as you can see on the previous video, we have essentially 2 lights in the scene, one blueish and one redish. They spread differently in the material to simulate a bit their different size. We however can see the user of a THIRD light, which is more in the back and will be useful to simulate the fact the background is emitting its color. This was very useful for strong background colors like orange:\u003c/p\u003e\n\u003cp\u003e\u003cvideo muted loop autoplay controls src=\"/images/2021/12/gnsp/100.mp4\" width=\"100%\"\u003e\u003c/video\u003e\u003c/p\u003e\n\u003cp\u003eThis is what lighting is implementing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003evec3 lighting (HIT hit, vec3 p, vec3 n, vec3 dir) { // (code is a bit simplified from original)\n  vec3 l, ldir;\n  vec3 c = vec3(0.);\n  l = vec3(lightPos, 1.5, -3.4);\n  vec3 obj = shade(hit, p);\n  ldir = normalize(l - p);\n  c +=\n  0.92 * vec3(0.9, 0.7, 0.6) * (\n    // ambient\n    0.1\n    // diffuse\n    + obj\n      * (.5 + .5 * diffuse(p, n, l)) // half lambert\n      * (0.5 + 0.5 * softshadow(p, ldir, 0.05, 5., 8.))\n    + specular(n, p, hit.y, ldir, dir, 10.)\n  );\n  l = vec3(-lightPos, 5., -2.);\n  ldir = normalize(l - p);\n  c +=\n  0.92 * vec3(0.3, 0.5, 0.6) * (\n  // ambient\n  0.1\n  // diffuse\n  + obj\n    * (.5 + .5 * diffuse(p, n, l)) // half lambert\n  + specular(n, p, hit.y, ldir, dir, 20.)\n  );\n\n  l = vec3(0., 2., 8.);\n  ldir = normalize(l - p);\n  c += bgLightColor * (\n    obj\n    * diffuse(p, n, l)\n    + specular(n, p, hit.y, ldir, dir, 20.)\n  );\n  return c;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can see the first thing done here is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  vec3 obj = shade(hit, p);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is a very important step that ask the hit object material \u0026quot;give me your color\u0026quot;. I will cover it in the Material section.\u003c/p\u003e\n\u003cp\u003eThen for each light I want to apply, you can see the same pattern:\u003c/p\u003e\n\u003cp\u003eFirst of all, we will put the light at a specific position in the space. For instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003el = vec3(lightPos, 1.5, -3.4);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewe calculate the actual light direction with \u003ccode\u003ep\u003c/code\u003e which is the point of interest to color.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003eldir = normalize(l - p);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd then we can finally add to the object its emitted color:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003e  c +=\n  0.92 * vec3(0.9, 0.7, 0.6) * (\n    // ambient\n    0.1\n    // diffuse\n    + obj\n      * (.5 + .5 * diffuse(p, n, l)) // half lambert\n      * (0.5 + 0.5 * softshadow(p, ldir, 0.05, 5., 8.))\n    + specular(n, p, hit.y, ldir, dir, 10.)\n  );\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand there are a few components that is very inspired by the classical \u0026quot;ambient diffuse specular\u0026quot; paradigm: \u003ca href=\"https://learnopengl.com/Lighting/Basic-Lighting\"\u003ehttps://learnopengl.com/Lighting/Basic-Lighting\u003c/a\u003e which I recommend you to read if you want to dive more into this part.\u003c/p\u003e\n\u003cp\u003eIn my case, I use half lambert technique which I find really interesting for a cartoon-ish effect \u003ca href=\"https://developer.valvesoftware.com/wiki/Half_Lambert\"\u003ehttps://developer.valvesoftware.com/wiki/Half_Lambert\u003c/a\u003e and because i don\u0026#39;t use expensive ambient occlusion.\u003c/p\u003e\n\u003cp\u003eI also, in this light case, will use \u003ccode\u003esoftshadow\u003c/code\u003e that cast a shadow toward the light direction.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003especular\u003c/strong\u003e function is an important utility that have this implementation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003efloat specular (vec3 n, vec3 pos, float m, vec3 ldir, vec3 dir, float p) {\n  return specularStrength(m, n, pos) * pow(max(dot(dir, reflect(ldir, n)), 0.0), p);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enote that we can have different \u0026quot;specular strength\u0026quot; for each material or even depending on the position.\u003c/p\u003e\n\u003ch3 id=\"the-material-specularstrength\"\u003eThe material \u003ccode\u003especularStrength()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cvideo muted loop autoplay controls src=\"/images/2021/12/gnsp/material.mp4\" width=\"100%\"\u003e\u003c/video\u003e\u003c/p\u003e\n\u003cp\u003eAs we can see in this material, the plastic has been added some texturing.\u003c/p\u003e\n\u003cp\u003eThis is implemented with a fbm noise and it is contained in the material value.\u003c/p\u003e\n\u003cp\u003eThen I had two possible ways to make it visible: either I change the color of the material OR I change the way it reflect lights in \u003ccode\u003especularStrength\u003c/code\u003e. I\u0026#39;ve used the second option for the plastic case:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003efloat noiseMetal;\nfloat specularStrength (float m, vec3 n, vec3 p) {\n  if (m \u0026lt; 2.1) {\n      float v =\n        n.z * fbm(600. * p.xy) +\n        n.x * fbm(600. * p.yz) +\n        n.y * fbm(600. * p.xz);\n      return 0.4 + 0.3 * v;\n  }\n  if (m \u0026lt; 2.2) {\n    return 2.0;\n  }\n  if (m \u0026lt; 4.) {\n    return 0.6 - 0.5 * noiseMetal + 1. * ceil(m-2.21);\n  }\n  return 0.4;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo pretty basic stuff, I use \u003ccode\u003em\u003c/code\u003e material value, which is a one dimension value to express all materials in. in plastic case, we are in the \u003ccode\u003em \u0026lt; 2.1\u003c/code\u003e case which have a strong noise frequency.\u003c/p\u003e\n\u003cp\u003eOn the same principle, we can see it is also done for the swivel metal.\u003c/p\u003e\n\u003cp\u003eI used some trickery here because, as the swivel is moving, I had to use a global variable to set the noise value because I don\u0026#39;t have the \u0026quot;local position\u0026quot;, only the global position.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003enoiseMetal\u003c/code\u003e is set directly from the \u003ccode\u003esdLedgerNanoSPlus\u003c/code\u003e function with this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003enoiseMetal = fbm(vec2(40.0, 1000.) * p.xy);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere \u003ccode\u003ep\u003c/code\u003e is a local position of the swivel, contextual to the rotation applied to it.\u003c/p\u003e\n\u003cp\u003eThe 40/1000 implements a stretched fbm noise which nicely recreates the effect:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2021/12/gnsp/metaltexture.jpg\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch3 id=\"the-material-shade\"\u003eThe material \u003ccode\u003eshade()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eshade(hit,p)\u003c/code\u003e is essentially the material coloring function. It tells what color does the object reflect at a given hit position.\u003c/p\u003e\n\u003cp\u003eHere is its implementation for the whole scene (I have omitted some part that will be covered in other articles):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003evec3 shade (HIT hit, vec3 p) {\n  if (hit.y \u0026lt; 2.0) return sceneBgColor;\n  if (hit.y \u0026lt; 4.0) {\n    if (hit.y \u0026lt; 2.1) {\n        return plasticColor;\n    }\n    if (hit.y \u0026lt; 2.2) {\n      return ...SCREEN RENDERING HERE...;\n    }\n    // swivel metal\n    return vec3(0.7 - 0.1 * noiseMetal - 0.2 * (hit.y - 2.2));\n  }\n  if (hit.y \u0026lt; 5.0) {\n    return stickerColor;\n  }\n  return vec3(0.0);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo it\u0026#39;s a simple, \u0026quot;give me the color of the material id number\u0026quot;. The only trick for the noise metal was to make it a bit darker on some part to accentuate the metal effect.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThe next article is going to dive into what this \u003ccode\u003e...SCREEN RENDERING HERE...\u003c/code\u003e part is doing, and more generally how I managed to also make the screen display text from inside a shader!\u003c/strong\u003e\u003c/p\u003e\n","data":{"title":"GNSP – the 3D distance to a Nano S Plus","thumbnail":"/images/2021/12/gnsp/glitch.png","description":"This second article (in a series of 7 articles) reveals the technique used to 3D render the Generative Nano S Plus collection: using a GLSL fragment shader, without any 3D model, but with raymarching distance function technique.","tags":["NFT"]}},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2021","month":"12","slug":"gnsp-raymarching"},"buildId":"J90BXkjy8Fm-TWfINBQyB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>