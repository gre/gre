{"pageProps":{"id":"2013-07-10-q-a-promise-library","year":"2013","month":"07","day":"10","slug":"q-a-promise-library","content":"<h1 id=\"a-world-of-promises-episode-1\"><a href=\"/pages/a-world-of-promises/\">A World Of Promises</a>, episode 1</h1>\n<p><em>This article is the first of a series of small articles \non the Q Javascript library and its eco-system.\nThis article is a brief introduction to Q Promises.</em></p>\n<img src=\"/images/2013/07/promise_then_thumbnail.jpg\" alt=\"\" class=\"thumbnail-left\" />\n\n<p><a href=\"http://github.com/kriskowal/q\">Q</a> is a <strong>Promise library</strong> in <strong>Javascript</strong> \ncreated 4 years ago by <a href=\"https://github.com/kriskowal\">Kris Kowal</a> who is one of the main contributor to <a href=\"http://wiki.commonjs.org/\">CommonJS</a>\nwhere we can find the <strong><a href=\"http://wiki.commonjs.org/wiki/Promises/A\">Promises/A</a></strong> specification.</p>\n<p><a href=\"http://github.com/kriskowal/q\">Q</a> is probably <strong>the most mature and powerful Promise library in Javascript</strong>\nwhich inspired a lot of libraries like <a href=\"http://jquery.com/\">jQuery</a>.\nIt exposes a complete API with, in my humble opinion, \ngood ideas like the separation of concerns between a &quot;Deferred&quot; object (the resolver) \nand a &quot;Thenable&quot; Promise (the read-only promise).</p>\n<p>This article is a brief introduction to Q Promises with some examples.\nFor more information on the subject, I highly recommend reading\nthe article <a href=\"http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/\">&quot;You&#39;re Missing the Point of Promises&quot;</a> \nand <a href=\"https://raw.github.com/kriskowal/q/master/design/README.js\">the Q implementation design README</a>.</p>\n<!--more-->\n\n<h2 id=\"what-is-a-promise\">What is a Promise</h2>\n<p>A <strong>Promise</strong> is an object representing a <strong>possible future value</strong> which has \na <code>then</code> method to access this value via callback. A Promise is initially \nin a <em>pending</em> state and is then either <em>fulfilled</em> with a value or <em>rejected</em> with an error.</p>\n<p><img src=\"/images/2013/07/promise.png\" alt=\"Schema representing Promise states: pending -&gt; fulfilled|rejected\"></p>\n<h3 id=\"some-properties\">Some properties</h3>\n<p>It is <strong>immutable</strong> because the Promise value never changes and each <code>then</code> creates a new Promise. \nAs a consequence, one same Promise can be shared between different code.</p>\n<p>It is <strong>chainable</strong> through the <code>then</code> method (and other Q shortcut methods),\nwhich transforms a Promise into a new Promise without knowing what&#39;s inside.</p>\n<p>It is <strong>composable</strong> because the <code>then</code> method will unify any Promise returned as \na result of the callback with the current Promise (act like a map or flatmap). \n<a href=\"http://github.com/kriskowal/q\">Q</a> also has a <code>Q.all</code> helper for combining an Array of Promise into one big Promise.</p>\n<h2 id=\"a-solution-against-the-pyramid-of-doom-effect\">A solution against the <a href=\"http://tritarget.org/blog/2012/11/28/the-pyramid-of-doom-a-javascript-style-trap/\">Pyramid of Doom</a> effect</h2>\n<p><em>Javascript</em> is by nature an <strong>asynchronous language</strong> based on an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop\">event loop</a> which enqueue events.\nAs a consequence, there is no way to block long actions (like Image Loading, ajax requests, other events), but everything is instead asynchronous:\nMost of Javascript APIs are using <strong>callbacks</strong> - functions called when the event has succeeded.</p>\n<p><strong>Problem with callbacks</strong> is when you start having a lot of asynchronous actions.\nIt quickly becomes a <a href=\"http://callbackhell.com/\">Callback Hell</a>.</p>\n<h3 id=\"example\">Example</h3>\n<p>Here is a simple illustration, let&#39;s say we have 2 functions, \none for <strong>retrieving some photos meta-infos from Flickr</strong> with a search criteria: <code>getFlickrJson(search, callback)</code>, \nanother for <strong>loading an image from one photo meta-info</strong>: <code>loadImage(json, callback)</code>. \nOf-course both functions are asynchonous so they need a callback to be called with a result.</p>\n<p>With this callback approach, we can then write:</p>\n<pre><code class=\"language-javascript\">// search photos for &quot;Paris&quot;, load and display the first one\ngetFlickrJson(&quot;Paris&quot;, function (imagesMeta) {\n  loadImage(imagesMeta[0], function (image) {\n    displayImage(image);\n  });\n});\n</code></pre>\n<p><em>(Imagine what it can look like with more nested steps.)</em></p>\n<blockquote>\n<p>we can easily turn a <em>callback</em> API into a <em>Promise</em> API</p>\n</blockquote>\n<h4 id=\"promise-style\">Promise style</h4>\n<p><code>getFlickrJson</code> and <code>loadImage</code> can now be rewritten as Promise APIs:</p>\n<p>Each function has clean signatures:</p>\n<ul>\n<li><code>getFlickrJson</code> is a <code>(search: String) =&gt; Promise[Array of ImageMeta]</code>.</li>\n<li><code>loadImage</code> is a <code>(imageMeta: ImageMeta) =&gt; Promise[DOM Image]</code>.</li>\n<li><code>displayImage</code> is a <code>(image: DOM Image) =&gt; undefined</code>.</li>\n</ul>\n<p>...and are easily pluggable together:</p>\n<pre><code class=\"language-javascript\">getFlickrJson(&quot;Paris&quot;)\n  .then(function (imagesMeta) { return imagesMeta[0]; })\n  .then(loadImage)\n  .then(displayImage, displayError);\n</code></pre>\n<p><strong>This is much more flatten, concise, maintainable and beautiful!</strong></p>\n<p>Note that if we want to be safer we can write:</p>\n<pre><code class=\"language-javascript\">Q.fcall(getFlickrJson, &quot;Paris&quot;)\n  .then(function (imagesMeta) { return imagesMeta[0]; })\n  .then(loadImage)\n  .then(displayImage, displayError);\n</code></pre>\n<p><code>Q.fcall</code> will call the function with the given parameters and ensure wrapping the returned value into a <strong>Promise</strong>.\nSo my code should continue working even if we change signatures to:</p>\n<ul>\n<li><code>getFlickrJson</code> is a <code>(search: String) =&gt; Array of ImageMeta</code>.</li>\n<li><code>loadImage</code> is a <code>(imageMeta: ImageMeta) =&gt; DOM Image</code>.</li>\n</ul>\n<p>One other cool thing about this chain of Promises is <strong>we can easily add more steps</strong> between two <code>then</code> step, for instance a DOM animation, a little delay, etc.</p>\n<h3 id=\"error-handling\">Error Handling</h3>\n<p>But a much important benefit is, unlike the callbacks approach,\nwe can properly <strong>handle the error in one row</strong> because one of the following steps eventually fails:</p>\n<ul>\n<li><code>getFlickrJson</code> fails to perform the ajax request to retrieve the Flickr JSON data.</li>\n<li>The array returned by Flickr was empty so <code>loadImage</code> throws an exception.</li>\n<li>The <code>loadImage</code> fails (e.g. the image is unavailable).</li>\n</ul>\n<p>This is called <strong>propagation</strong> and is exactly how <strong>exceptions</strong> work.</p>\n<p><strong>Promise Error Handling</strong> really looks like <strong>Exception Handling</strong>.</p>\n<p>If it would be possible to have two methods:</p>\n<ul>\n<li><code>getFlickrJsonSync</code> is a <code>(search: String) =&gt; Array of ImageMeta</code>.</li>\n<li><code>loadImageSync</code> is a <code>(imageMeta: ImageMeta) =&gt; DOM Image</code>.</li>\n</ul>\n<p>Then, the blocking code would look like this:</p>\n<pre><code class=\"language-javascript\">try {\n  var imagesMeta = getFlickrJsonSync(&quot;Paris&quot;)\n  var firstImageMeta = imagesMeta[0]\n  var image = loadImageSync(firstImageMeta)\n  displayImage(image);\n} catch (e) {\n  displayError(e);\n}\n</code></pre>\n<p><em>...which is very close to Promise style.</em></p>\n<p><strong>Q Promises also unify Exceptions and Rejected Promises</strong>:\nthrowing an exception in any Q callback will result in a rejected Promise.</p>\n<pre><code class=\"language-javascript\">var safePromise = Q.fcall(function () {\n  // following eventually throws an exception\n  return JSON.parse(someUnsafeJsonString);\n});\n// safePromise is either fulfilled with a JSON Object\n// or rejected with an error.\n</code></pre>\n<blockquote>\n<p>Error handling with the callbacks approach is hell:</p>\n</blockquote>\n<pre><code class=\"language-javascript\">getFlickrJson(&quot;Paris&quot;, function (imagesMeta) {\n  if (imagesMeta.length == 0) {\n    displayError();\n  }\n  else {\n    loadImage(imagesMeta[0], function (image) {\n      displayImage(image);\n    }, displayError);\n  }\n}, displayError);\n</code></pre>\n<h2 id=\"next-episode\">Next episode</h2>\n<p>Next episode, we will show you how to create your own Promises with <em>Deferred</em> objects.\nWe will introduce <strong>Qimage</strong>, a simple Image loader wrapped with Q.</p>\n<hr>\n<p>Special Kudos to <a href=\"http://twitter.com/42loops\">@42loops</a> &amp; <a href=\"http://twitter.com/bobylito\">@bobylito</a>\nfor bringing Q in my developer life :-P</p>\n","data":{"title":"Qep1.: Q, a Promise library","description":"This article is the first of a series of small articles on the Q Javascript library and its eco-system. It is a brief introduction to Q Promises.","thumbnail":"/images/2013/07/promise_then_thumbnail.jpg","author":"Gaetan","layout":"post","tags":["AWOP","javascript","promise","Q","library"]}},"__N_SSG":true}