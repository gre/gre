{"pageProps":{"n":"202","plot":{"n":"202","key":"./202/README.md","rustFile":"202/main.rs","sourceURL":"https://github.com/gre/gre/blob/master/plots/examples/202/main.rs","content":"<p>@greweb&#39;s #12 plot loop. Taking the idea of <a href=\"/plots/198\">plot#198</a> to the next level using an animated eye.</p>\n<p>These are plotted (~ 2 hours each frame) with fountain pens and two inks (&#39;Bloody Brexit&#39; by Diamine and &#39;Writers Blood&#39; by Diamine) on a A4 watercolor paper (300g/m2).</p>\n<p>The eye is mirrored with a different offset to make this duality. The title refers to the French expression &quot;œil pour œil, dent pour dent&quot; which means &quot;an eye for an eye&quot;.</p>\n<h3 id=\"making-of\">Making of</h3>\n<p>I took a video of my wife eye and use this GIF as an input to my generator =)</p>\n<p><video src=\"/images/plots/202-input.mp4\" width=\"100%\" controls autoplay muted loop></video></p>\n<p>The way to mix the two eyes is using a simple technique, using my own tool set:</p>\n<pre><code class=\"language-rust\">let get_color_1 = image_gif_get_color(&quot;images/eye.gif&quot;, opts.index).unwrap();\nlet get_color_2 = image_gif_get_color(&quot;images/eye.gif&quot;, opts.index + 2).unwrap();\nlet f = |(x, y): (f64, f64)| {\n    let p = (x, y);\n    let c1 = get_color_1((p.0, p.1 + 0.2));\n    let c2 = get_color_2((p.0, 1.2 - p.1));\n    smoothstep(0.0, 1.0, grayscale(c1)) *\n    smoothstep(0.0, 1.0, grayscale(c2))\n};\n</code></pre>\n","data":{"date":"2021-07-21","title":"œil pour œil (4 frames)","image":"/images/plots/202.gif","description":"@greweb's #12 plot loop","tags":["plotloop"]}},"prev":{"n":"201","key":"./201/README.md","rustFile":"201/main.rs","sourceURL":"https://github.com/gre/gre/blob/master/plots/examples/201/main.rs","content":"<p>Plotting 1000 digits of π. Y axis spreads from 0 to 9, X axis is the index of digits. Diamine &#39;Red Dragon&#39; ink with fontain pen on watercolor paper.</p>\n","data":{"date":"2021-07-20","title":"1000 digits of π","image":"/images/plots/201.jpg","description":"Plotting 1000 digits of π. the y axis spreads from 0 to 9, the x axis is the index of digits.","tags":["pi"]}},"next":{"n":"203","key":"./203/README.md","rustFile":"203/main.rs","sourceURL":"https://github.com/gre/gre/blob/master/plots/examples/203/main.rs","content":"<p>As you may notice, I like randomness a lot. Exploring the beauty of noise is also recreating Nature&#39;s pattern and trying to put back some order in that randomness.</p>\n<p>This creation is an unusual version of &quot;circle packing&quot; that instead of a pure random distribution will run a few times to actually try to find the biggest circle to place. This makes the distribution less random and way more ordered. However, the fact there is a &quot;a few times&quot; maximum tries gives some room for some randomness and not &quot;pure order&quot;.</p>\n<p>The algorithm at stake is relatively simple, I will have to improve it in future to parallelize the computation.</p>\n<pre><code class=\"language-rust\">fn packing(\n    seed: f64,\n    iterations: usize,\n    desired_count: usize,\n    optimize_size: usize, // &lt;--- number of retries to optimize the size\n    pad: f64,\n    container: &amp;VCircle,\n    min_scale: f64,\n    max_scale: f64,\n) -&gt; Vec&lt;VCircle&gt; {\n    let mut circles = Vec::new();\n    let mut tries = Vec::new();\n    let mut rng = rng_from_seed(seed);\n    let x1 = container.x - container.r;\n    let y1 = container.y - container.r;\n    let x2 = container.x + container.r;\n    let y2 = container.y + container.r;\n    let max_scale = max_scale.min(container.r);\n    for _i in 0..iterations {\n        let x: f64 = rng.gen_range(x1, x2);\n        let y: f64 = rng.gen_range(y1, y2);\n        if let Some(size) = search_circle_radius(&amp;container, &amp;circles, x, y, min_scale, max_scale) {\n            let circle = VCircle::new(x, y, size - pad);\n            // innovation happens here, basically we keep pushing until we reach the nb\n            tries.push(circle);\n            if tries.len() &gt; optimize_size {\n                // then we grab the biggest\n                tries.sort_by(|a, b| b.r.partial_cmp(&amp;a.r).unwrap());\n                let c = tries[0];\n                circles.push(c.clone());\n                tries = Vec::new();\n            }\n        }\n        if circles.len() &gt; desired_count {\n            break;\n        }\n    }\n    circles\n}\n</code></pre>\n","data":{"date":"2021-07-22","title":"circles recursion & ordered noise","image":"/images/plots/203.jpg","description":"I like randomness a lot. Exploring the beauty of noise is also recreating Nature's pattern and trying to put back some order in that randomness.","tags":["shape-packing"]}}},"__N_SSG":true}