{"pageProps":{"id":"2012-02-29-bezier-curve-based-easing-functions-from-concept-to-implementation","year":"2012","month":"02","day":"29","slug":"bezier-curve-based-easing-functions-from-concept-to-implementation","content":"<blockquote>\n<p><strong>EDIT 2014:</strong> This article ends up in an updated library available on <a href=\"http://npmjs.org/package/bezier-easing\">NPM</a> (<code>bezier-easing</code>) and available on <a href=\"https://github.com/gre/bezier-easing\">Github</a>. It has been used by Apple for the <a href=\"http://www.apple.com/mac-pro/\">mac-pro page</a> and by <a href=\"http://velocityjs.org/\">Velocity.js</a>. You can also find its usage in the <a href=\"http://greweb.me/glsl-transition/example/\">glsl-transition examples</a>.</p>\n</blockquote>\n<img src=\"/images/2012/02/bezier_transition_editor.png\" class=\"thumbnail-left\" />\n\n<p>Many animation libraries are today using <strong>easing functions</strong> – functions of time returning a progression percentage value. This is required to perform such cool effects:</p>\n<iframe src=\"/demo/simple-easing-animation/\" height=\"50\" width=\"50%\"></iframe>\n\n<p>But most of these libraries implement a huge collection of functions. We will see how we can generalize them with bezier curves.</p>\n<!--more-->\n\n<p>For instance, we use to do this:</p>\n<pre><code class=\"language-javascript\">EasingFunctions = {\n  linear: function (t) {\n    return t;\n  },\n  easeInQuad: function (t) {\n    return t * t;\n  },\n  easeOutQuad: function (t) {\n    return t * (2 - t);\n  },\n  easeInOutQuad: function (t) {\n    return t &lt; 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  },\n  easeInCubic: function (t) {\n    return t * t * t;\n  },\n  easeOutCubic: function (t) {\n    return --t * t * t + 1;\n  },\n  easeInOutCubic: function (t) {\n    return t &lt; 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n  },\n  easeInQuart: function (t) {\n    return t * t * t * t;\n  },\n  easeOutQuart: function (t) {\n    return 1 - --t * t * t * t;\n  },\n  easeInOutQuart: function (t) {\n    return t &lt; 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n  easeInQuint: function (t) {\n    return t * t * t * t * t;\n  },\n  easeOutQuint: function (t) {\n    return 1 + --t * t * t * t * t;\n  },\n  easeInOutQuint: function (t) {\n    return t &lt; 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n  },\n};\n</code></pre>\n<p>Defining such functions is lot of math fun but it is very <strong>specific</strong> and not really customizable. Hopefully, we can generalize these easing functions. With <strong>Bezier curves</strong>.</p>\n<p>In fact, this work has already been done in CSS Transitions and CSS Animations specifications! You can use <code>transition-timing-function</code> CSS property and give a <code>cubic-bezier(x1, y1, x2, y2)</code> value (all <strong>ease, linear, ease-in, ease-out, ease-in-out</strong> values are just fallbacking on this cubic-bezier usage).</p>\n<p><img src=\"/images/2012/02/TimingFunction.png\" alt=\"\"></p>\n<p>In a bezier curve based easing function, the X axis is the <strong>time axis</strong> whereas the Y axis represents the <strong>percentage of progress</strong> of the animation.<br>The two points P1 and P2 are called <strong>handles</strong> and you can (exclusively) control their X and Y positions to generate every possible cubic timing function.</p>\n<h3 id=\"live-demo\">Live demo</h3>\n<p>Try to interact with the handles:</p>\n<iframe src=\"/demo/bezier-easing/\" frameborder=\"0\" width=\"560\" height=\"400\"></iframe>\n\n<h2 id=\"implementation\">Implementation</h2>\n<p>Ok, so, this bezier curve concept is great but how can I implement it?</p>\n<p>I’ve read <a href=\"http://13thparallel.com/archive/bezier-curves/\">here</a> how simple is it to <strong>compute many points of a Bezier curve</strong> and potentially draw them:</p>\n<pre><code class=\"language-javascript\">function B1(t) {\n  return t * t * t;\n}\nfunction B2(t) {\n  return 3 * t * t * (1 - t);\n}\nfunction B3(t) {\n  return 3 * t * (1 - t) * (1 - t);\n}\nfunction B4(t) {\n  return (1 - t) * (1 - t) * (1 - t);\n}\nfunction getBezier(percent, C1, C2, C3, C4) {\n  var pos = new coord();\n  pos.x =\n    C1.x * B1(percent) +\n    C2.x * B2(percent) +\n    C3.x * B3(percent) +\n    C4.x * B4(percent);\n  pos.y =\n    C1.y * B1(percent) +\n    C2.y * B2(percent) +\n    C3.y * B3(percent) +\n    C4.y * B4(percent);\n  return pos;\n}\n</code></pre>\n<p>But it’s not enough. We need to project a point to the Bezier curve, in other words, we need to get the Y of a given X in the bezier curve, and we can’t just get it with the <code>percent</code> parameter of the Bezier computation.<br><strong>We need an interpolation.</strong></p>\n<h3 id=\"deep-into-firefox-implementation\">Deep into Firefox implementation</h3>\n<p>In Mozilla Firefox, The bezier curve interpolation is implemented in nsSMILKeySpline.cpp : .</p>\n<p>What we can learn from it is:</p>\n<ul>\n<li>A first optimization store <strong>sample values of the bezier curve</strong> in a small table used to roughly find a initial X guess.</li>\n<li>Then, it use two different implementation strategies: One use the <a href=\"http://en.wikipedia.org/wiki/Newton%27s_method\">Newton’s method</a> and the other is just a <a href=\"http://en.wikipedia.org/wiki/Dichotomic_search\">dichotomic search</a> (binary subdivision).</li>\n<li>A <strong>criteria</strong> based on the <strong>slope</strong> give the best strategy to take.</li>\n</ul>\n<p>These sub-optimizations probably make the difference for the C++ version but are not really relevant for the JavaScript implementation. Moreover, I have only used the Newton’s method algorithm.<br>And this is the code:</p>\n<script src=\"https://gist.github.com/1926947.js?file=KeySpline.js\"></script>\n\n<p>Now we can just alias some classic easing function – like CSS does.</p>\n<script src=\"https://gist.github.com/1926947.js?file=EasingFunctions.json\"></script>\n\n<p>I’m working on the next version of <a href=\"http://sliderjs.org/\">Slider.JS</a> which relies on 3 different technologies for image transitions: <strong>CSS Transitions</strong>, <strong>Canvas</strong> and <strong>GLSL shaders (from WebGL)</strong>.</p>\n<hr>\n<p>I have now found <strong>a common way to describe easing functions for both CSS-based and Javascript-based animations</strong>!</p>\n<p>This example has shown that sometimes, finding a larger solution for a problem is more interesting than having specific solutions.<br><strong>This is called the <a href=\"http://en.wikipedia.org/wiki/Inventor&#39;s_paradox\">Inventor’s paradox</a>.</strong></p>\n","data":{"title":"Bezier Curve based easing functions – from concept to implementation","description":"Many animation libraries are today using easing functions – functions of time returning a progression percentage value. We will see how we can generalize them with bezier curves.","thumbnail":"/images/2012/02/bezier_transition_editor.png","author":"Gaetan","layout":"post","permalink":"/2012/02/bezier-curve-based-easing-functions-from-concept-to-implementation/","tags":["animation","bezier","css","javascript"]}},"__N_SSG":true}