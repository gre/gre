{"pageProps":{"id":"2013-09-17-timelapse","year":"2013","month":"09","day":"17","slug":"timelapse","content":"<img src=\"/images/2013/09/timelapse.png\" alt=\"\" class=\"thumbnail-left\" />\n\n<p>While continuing to experiment with <a href=\"https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html\">Web Audio API</a> and <a href=\"/2013/02/glsl-js-a-javascript-glsl-library-dry-efficient/\">GLSL</a>,\nI&#39;ve made <strong><a href=\"http://js13kgames.com/entries/timelapse\">a game called Timelapse</a></strong> for <a href=\"http://js13kgames.com/\">js13kgames</a>\n(an HTML5 game competition where entries must be less than 13 kb zipped).</p>\n<p>This article is a <strong>postmortem overview of my game development</strong> which will try to explain\nwhat was my game mecanism ideas and show you some interesting parts with <strong>screenshots, audios and source code snippets</strong>.</p>\n<h2 id=\"the-game\">The Game</h2>\n<p><a href=\"http://js13kgames.com/entries/timelapse\">Open the game on js13kgames</a> / <a href=\"https://github.com/gre/js13k\">github</a>.</p>\n<p><strong>The game intends to work on Desktop and Mobile</strong>.\nHowever, <em>Chrome</em> is recommended \n(<em>Firefox Aurora</em> also supports it but audio is a bit wrong, but Mozilla devs should improve this <a href=\"https://twitter.com/padenot/status/375924494537195520\">soon</a>).\nToday, it works on <em>Android Chrome Beta</em> on a Nexus 4, unfortunately with some clicks in the audio (Web Audio API is bleeding-edge).</p>\n<!--more-->\n\n<h2 id=\"experimenting-with-stuff\">Experimenting with stuff</h2>\n<p>Last months, I&#39;ve been playing with Web Audio API and released a few experiments like \n<a href=\"/2013/09/beez\">Beez</a>, <a href=\"/2013/08/FM-audio-api\">FM Synthesis</a> and <a href=\"/2013/08/zound-wip-v1/\">Zound</a>.</p>\n<p>My game development started last weekend as an experiment, I tried to make some <strong>dubstep-like sound</strong>, \nstarting with a <strong><a href=\"http://jsfiddle.net/greweb/CrXYw/4/\">&quot;Wob Wob Wob&quot; sound</a></strong>.</p>\n<p>I also started to dig into <a href=\"http://glsl.heroku.com/\">glsl.heroku.com</a>, \nI definitely wanted to make some <strong>cool and unusual graphics with glitchy style</strong> to fit with dubstep audio part, \nI unfortunately hadn&#39;t enough deepen this glitchy part as I would have liked.</p>\n<p>GLSL quite fits this need: it mays look strange and hard code language as a start \nbut <strong>it&#39;s very easy and free to do anything with it</strong>. \nI used my <a href=\"/2013/02/glsl-js-a-javascript-glsl-library-dry-efficient/\">glsl.js</a> wrapper to easily have a shader rendering the whole Canvas.</p>\n<blockquote>\n<p>GLSL is a totally different way of thinking the rendering: \nthe main principle is to define <strong>a function which returns a Color for a given Position</strong>. \nI use to call it &quot;Functional Rendering&quot; in opposite to &quot;Procedural Rendering&quot;. I&#39;ll talk again about those concepts soon.</p>\n</blockquote>\n<p>I started my graphics by forking <a href=\"http://glsl.heroku.com/e#10795.2\">this very interesting glow effect</a>.</p>\n<h2 id=\"prototyping-the-game-ideas\">Prototyping the game ideas</h2>\n<p>Then I started to really think about the game I could do, \nI sketched some game mecanisms and thought about the gameplay.</p>\n<p>My game was designed to be a <strong>one-button</strong> <a href=\"https://en.wikipedia.org/wiki/Dance_Dance_Revolution\">DDR</a>-like <strong>rhythm game</strong>\nwith the main idea that <strong>the user controls the speed</strong> <em>(the BPM, beats per minute)</em> of the song.\nI wanted an <strong>inertia system</strong>: tap a bit early and your song will speed up, tap a bit late and the song will slow down.\nThis speed freedom isn&#39;t without constraints: You can reach a gameover if your speed isn&#39;t enough fast, or contrariwise if it is too fast (like a overheat).</p>\n<blockquote>\n<p>The game listen to your inputs to adapt the song BPM.</p>\n</blockquote>\n<p>The game is basically about SPACE-typing on each beat, but also introduce some <strong>freestyle &quot;dubstep&quot; phase</strong>\n<em>(It&#39;s not really dubstep though!)</em>: the gameplay is either typing on the key like hell or holding and releasing some &quot;riff&quot;. </p>\n<p>The score mecanisms give good scores for very precise beats and will be negative for very bad/loss rhythms.\nDuring the freestyle section, each action gives a score, also each riff (holding the button for more than 1 tick) gives a score. Making small riffs has been designed to give more points that a very long riff so you have to find the good balance.\n(The score also increases at the end of each freestyle phase).</p>\n<img src=\"/images/2013/09/highscores.png\" style=\"max-width: 300px; width: 50%\" />\n\n<p>I also had to find a game end, I first thought about trying to make the game harder and harder but it wasn&#39;t trivial to make\nbecause I wanted to keep my <em>&quot;player is free to take any speed he wants&quot;</em> idea.</p>\n<p>Instead, I chose to <strong>limit the game time by one minute</strong>, \nwhich makes my game a psychedelic rush game if you want a good score: \nA good strategy to make a good score is to first speed up the song inertia as fast as possible, and then keep the rhythm on an high BPM.</p>\n<blockquote>\n<p>That mecanism is interesting because it is also harder to make precise scores on higher speed, it can even be risky (reaching the BPM limit, failing some beats), the player has to find the speed it fits the most!</p>\n</blockquote>\n<h2 id=\"the-game-experience\">The game experience</h2>\n<p>I wanted my game experience to be both on the <strong>graphics</strong> and on the <strong>audio</strong> aspects:\nyou have both a feedback on your actions with the graphics using a color (\n<span style=\"color:#0F0\">green=good</span>,\n<span style=\"color:#CC0\">yellow=meh</span>,\n<span style=\"color:#F00\">red=bad</span>\n) and with the audio (different sound depending on the rate of the action).</p>\n<img src=\"/images/2013/09/good.png\" style=\"width: 30%\" />\n<img src=\"/images/2013/09/timelapse.png\" style=\"width: 30%\" />\n<img src=\"/images/2013/09/toofast.png\" style=\"width: 30%\" />\n\n<p>The audio BPM is also graphically visualized using a circle with a rotating pulse\nwhich also helps you on the rhythm.</p>\n<p>During the freestyle phase, the circle turns fully highlighted and the audio &quot;wob wob wob&quot; part is playing.\nEach user freestyle &quot;riff&quot; (hold a note) will randomly change the delay of a &quot;repeater&quot;, an important part on the audio of that section I will discuss in the <em>Audio Section</em>.</p>\n<img src=\"/images/2013/09/killer-riff.png\" style=\"max-width: 300px; width: 100%\" />\n\n<p>If the player runs the song too fast, an overheat happens and the circle turns very light:</p>\n<img src=\"/images/2013/09/lighted.png\" style=\"max-width: 300px; width: 100%\" />\n\n<p>On the contrary, it turns very dark and glitchy when the BPM is very slow:</p>\n<img src=\"/images/2013/09/slow.png\" style=\"max-width: 300px; width: 100%\" />\n\n<h2 id=\"more-about-the-audio\">More about the audio</h2>\n<p>As described in the <a href=\"https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html\">specification</a>, the <em>Web Audio API</em> is an audio routing graph composed of low level audio nodes.\nUsing it raw can be quite verbose, I&#39;ve made my own reusable component using those nodes.\nMy convention is to use Javascript constructor for those components and to have a &quot;inp&quot; and an &quot;out&quot; <em>AudioNode</em> field.</p>\n<p>First I create a <code>ctx</code> <em>AudioContext</em> (works for Chrome &amp; Firefox Aurora):</p>\n<pre><code class=\"language-javascript\">var ctx = new (window.AudioContext || window.webkitAudioContext)();\n</code></pre>\n<p>This <code>ctx</code> variable now offers all methods to work with sound.</p>\n<h3 id=\"global-effects-reverbation-compressor\">Global effects: Reverbation, Compressor</h3>\n<p>Web Audio API have a <strong>Convolver</strong> node which allows to make diverse audio effects like <strong>reverbation</strong>, which is basically emulating your song played in a room. You can find more information <a href=\"http://creativejs.com/resources/web-audio-api-a-bit-more-advanced/\">here</a>.</p>\n<p>I&#39;ve used a simple Reverb effect to pass the whole sound. This simple reverb implementation can be found on <a href=\"https://github.com/web-audio-components/simple-reverb\">https://github.com/web-audio-components/simple-reverb</a>.</p>\n<p>Another <strong>very</strong> important brick of the Audio graph is the <strong>Compressor</strong>.\nThe <a href=\"https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html\">Web Audio API</a> have a built-in Compressor with some parameters.</p>\n<p>A compressor dynamically adapts the input sound to a normalized output. It ensures the output is not distorted (saturated because amplitude is too high) or inaudible because too low.\nIn other words, it consists of dynamically raise the volume if the input is lower, and decrease the volume if the input is higher, that a given rate.</p>\n<p>Here is the global audio setup I&#39;ve used as an output for all different sounds of the song:</p>\n<pre><code class=\"language-javascript\">  var out = ctx.createGain(); // My global output\n  var outCompressor = ctx.createDynamicsCompressor();\n  var reverb = new Reverb(0.5);\n  out.gain.value = 0; // We will increase the main volume when the song starts\n  out.connect(reverb.inp);\n  reverb.out.connect(outCompressor);\n  outCompressor.connect(ctx.destination);\n</code></pre>\n<h3 id=\"ambiant-sounds\">Ambiant sounds</h3>\n<p>I&#39;ve used a soft <strong>sine Oscillator</strong> and some <strong>Noise generator</strong> (protected by a bandpass Filter) for the <strong>ambiant sound</strong>.\nThat gives more depth to the song.</p>\n<p>It was also used to give more audio feedback on the gameplay:</p>\n<ul>\n<li>The <strong>Oscillator frequency follows the BPM</strong> (goes higher in frequency with the song speed).</li>\n<li>The BPM also affects the <strong>frequency of a LFO</strong> which oscillate the <strong>volume of the Noise</strong> to make an <strong>helicopter-like sound</strong>.</li>\n<li>The Oscillator is fastly <strong>detuned on each user action</strong>, and especially if the user tap too early it will produce a &quot;bip&quot; like you can hear in the following Soundcloud.</li>\n<li>Finally, a second noise passed into a highpass filter will be louder if the player is in danger (BPM is too slow or too fast). <em>(we won&#39;t show the code for this one)</em></li>\n</ul>\n<p>I have muted all other sounds to make you hear only the ambiant sound when speeding up the song up to a gameover:</p>\n<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" src=\"https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110774935\"></iframe>\n\n<p>The Noise component:</p>\n<pre><code class=\"language-javascript\">  function Noise () {\n    // Here we loop on a 2s noise buffer, it is more efficient that generating on the fly\n    var bufferSize = 2 * ctx.sampleRate,\n    noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate),\n    output = noiseBuffer.getChannelData(0);\n    for (var i = 0; i &lt; bufferSize; i++) {\n      output[i] = Math.random() * 2 - 1;\n    }\n    var whiteNoise = ctx.createBufferSource();\n    whiteNoise.buffer = noiseBuffer;\n    whiteNoise.loop = true;\n\n    var gain = createGain();\n    whiteNoise.connect(gain);\n\n    var filter = ctx.createBiquadFilter();\n    gain.connect(filter);\n    filter.type = &quot;lowpass&quot;; // Generally lowpass, but can be overrided\n\n    this.white = whiteNoise;\n    this.gain = gain;\n    this.out = this.filter = filter;\n  }\n\n  Noise.prototype = {\n    start: function (time, duration) {\n      this.white.start(time, 0, duration);\n    }\n  };\n</code></pre>\n<p>Here is some code I used for making the ambiant sound:</p>\n<pre><code class=\"language-javascript\">  var bpmOsc2mult = 3;\n  var bpmNoiseMult = 10;\n  var noiseBpmGain = ctx.createGain();\n  noiseBpmGain.connect(out);\n  var noiseBpm = new Noise();\n  noiseBpm.out.connect(noiseBpmGain);\n  noiseBpm.start(0);\n  noiseBpm.gain.gain.value = 0.2;\n  noiseBpm.filter.type = &quot;bandpass&quot;;\n  noiseBpm.filter.Q.value = 20;\n  noiseBpm.filter.frequency.value = 0;\n\n  var bpmNoiseLfoMult = 0.05;\n  var bpmNoiseLfoPow = 1.3;\n  var lfoBpm = ctx.createOscillator();\n  lfoBpm.start(0);\n  var lfoBpmGain = ctx.createGain();\n  lfoBpmGain.gain.value = 0.8;\n  lfoBpm.connect(lfoBpmGain);\n  lfoBpmGain.connect(noiseBpmGain.gain);\n\n  var osc2 = new OscGain();\n  osc2.type = &quot;sawtooth&quot;;\n  osc2.osc.frequency.value = vars.bpm * bpmOsc2mult;\n  osc2.osc.detune.value = 5;\n  osc2.gain.gain.value = 0.1;\n  osc2.out.connect(out);\n  osc2.start(0);\n</code></pre>\n<h3 id=\"notes\">NOTES</h3>\n<p>To easily define melodies, I first define &quot;NOTES&quot;, a map of <code>note -&gt; frequency</code>. \nFor instance <code>NOTES.A4</code> is <code>440</code> Hz:</p>\n<pre><code class=\"language-javascript\">var NOTES = (function () {\n  var notes = {};\n  var toneSymbols = &quot;CcDdEFfGgAaB&quot;;\n  function noteToFrequency (note) {\n    return Math.pow(2, (note-69)/12)*440; // Beauty of audio math!\n  };\n  for (var octave = 0; octave &lt; 8; ++octave) {\n    for (var t = 0; t &lt; 12; ++t) {\n      notes[toneSymbols[t]+octave] = noteToFrequency(octave * 12 + t);\n    }\n  }\n  return notes;\n}());\n</code></pre>\n<p>My convention here is to use a cap for major notes like <code>D</code> and no cap for minor notes like <code>d</code> (the black keys on a Piano).\nThe following number is the octave. Notes are defined with two characters: Like A1, C2, B3, a4, ...\nYou will see that&#39;s quite convenient to use the <code>with(NOTES){ ... }</code> syntax.</p>\n<p>See Also <a href=\"https://en.wikipedia.org/wiki/Frequencies_of_notes\">Frequencies of notes</a>.</p>\n<h3 id=\"fm-synth-bass-melody\">FM Synth &quot;bass&quot; melody</h3>\n<p>I used some <a href=\"/2013/08/FM-audio-api\">FM synth</a> for making the main &quot;bass&quot; melody:</p>\n<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" src=\"https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110622269\"></iframe>\n\n\n<p>First, I made a &quot;OscGain&quot; and a &quot;FM&quot; components.</p>\n<pre><code class=\"language-javascript\">  function OscGain (t) {\n    this.osc = ctx.createOscillator();\n    if (t) this.osc.type = t;\n    this.out = this.gain = ctx.createGain();\n    this.osc.connect(this.gain);\n  }\n  OscGain.prototype = {\n    start: function (time, duration) {\n      this.osc.start(time, 0, duration);\n    }\n  };\n\n  function FM () {\n    OscGain.call(this);\n    this.mod = new OscGain();\n    this.mod.out.connect(this.osc.frequency);\n  }\n  FM.prototype = {\n    start: function (time, duration) {\n      this.osc.start(time, 0, duration);\n      this.mod.start(time, duration);\n    }\n  };\n</code></pre>\n<p>And used this melody:</p>\n<pre><code class=\"language-javascript\">with (NOTES) {\n  bassMelo = [G4,D4,F4,C4];\n}\n</code></pre>\n<pre><code class=\"language-javascript\">  // Usage for the bass:\n  var bass = new FM();\n  bass.out.connect(out);\n  function tick (i, time) {\n    // ...\n    // Change the note each 4 tick\n    var oscFreq = bassMelo[Math.floor(i/4) % bassMelo.length];\n    bass.osc.frequency.value = oscFreq * 2.0;\n    bass.mod.osc.frequency.value = oscFreq * 0.5;\n    bass.mod.gain.gain.value = oscFreq * 0.5;\n    // ...\n  }\n</code></pre>\n<blockquote>\n<p><strong>N.B.</strong>:\nThe modulator frequency is 1/4 of the oscillator frequency which gives a cool bass sound. <br/>\nAlso, That tick function is called at a (variable) frequency of <code>60 / BPM</code> Hz (BPM means Beat Per Minute, here it&#39;s more a Tick Per Minute) with the tick number <code>&quot;i&quot;</code> and the tick time <code>&quot;time&quot;</code>.</p>\n</blockquote>\n<h3 id=\"fm-synth-main-melody\">FM Synth &quot;main&quot; melody</h3>\n<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" src=\"https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110620277\"></iframe>\n\n<p>This &quot;main&quot; synth is also a Frequency Modulation, but using a 3/4 ratio on the modulator frequency,\nand with an envelope on each notes.</p>\n<pre><code class=\"language-javascript\">with (NOTES) {\n  melo1 = [E3,G3,D3,G3,E3,A3,C3,G3];\n  melo2 = [E3,B3,D3,G3,E3,C4,C3,D3];\n}\n</code></pre>\n<p>Making an envelope consists of scheduling the amplitude through time with a <em>Gain</em>. See my <a href=\"/2013/08/FM-audio-api\">FM Article</a>.</p>\n<pre><code class=\"language-javascript\">  function envelope (gainNode, time, volume, duration, a, d, s, r) {\n    var gain = gainNode.gain;\n    gain.cancelScheduledValues(0);\n    gain.setValueAtTime(gain, 0, time);\n    gain.linearRampToValueAtTime(volume, time + a);\n    gain.linearRampToValueAtTime(volume * s, time + a + d);\n    gain.setValueAtTime(volume * s, time + a + d + duration);\n    gain.linearRampToValueAtTime(0, time + a + d + duration + r);\n  }\n</code></pre>\n<p>Also, the melody periodically switch into &quot;arpeggio note&quot; with this function:</p>\n<pre><code class=\"language-javascript\">  var DELTAS = [\n    Math.pow(2, 0),\n    Math.pow(2, 1),\n    Math.pow(2, 2)\n  ];\n\n  function applyArpeggio (freqParam, baseFreq, time, duration, arpDuration, deltas) {\n    if (!deltas) deltas = DELTAS;\n    var length = deltas.length;\n    var ranges = [];\n    cancelScheduledValues(freqParam, 0);\n    for (var t = 0, i = 0; t &lt;= duration; t += arpDuration, i = (i+1) % length) {\n      setValueAtTime(freqParam, baseFreq * deltas[i], time + t);\n    }\n  }\n</code></pre>\n<p>The Arpeggio effect is about fastly changing some octaves higher (like C3,C4,C5,C3,C4,C5,... very fastly).\nI&#39;ve keeped that &quot;deltas&quot; a parameter to try other arpeggios, I&#39;ve only used <code>[1,2,4]</code> multiplicators in the game.</p>\n<p>Indeed, thanks to the magic of audio math, \nincrementing the octave means multipling the frequency by 2,\nmore generally increment by N octaves means multiplying by <code>2 ^ N</code>.</p>\n<p>Finally, here is &quot;meloNote&quot;, the function which triggers one melody note.</p>\n<pre><code class=\"language-javascript\">  function meloNote (noteFreq, time, arpeggio, metallic) {\n    var fm = new FM();\n    var duration = 0.3;\n    var release = 0.1;\n    fm.osc.type = &quot;triangle&quot;;\n    fm.osc.frequency.value = 4 * noteFreq;\n    fm.mod.osc.frequency.value = 3 * noteFreq;\n    fm.mod.osc.type = &quot;sine&quot;;\n    fm.out.connect(meloOut.inp);\n    setTimeout(function () {\n      fm.out.disconnect(meloOut.inp);\n    }, 1000);\n    startNode(fm, time, 0, 1);\n    arpeggio &amp;&amp; applyArpeggio(fm.osc.frequency, 4 * noteFreq, time, duration+release, 0.025);\n    envelope(fm.gain, time, 0.5, duration, \n        0.01, 0.02, 0.6, 0.2);\n    envelope(fm.mod.gain, time, 4 * noteFreq * metallic, duration, \n        0.05, 0.1, 0.6, 0.2);\n  }\n</code></pre>\n<blockquote>\n<p><strong>N.B.</strong> The metallic parameter is a parameter from 0 to 1 to give a more metallic sound. \nIt changes the modulator intensity. In fact, that 3/4 ratio on the FM is the reason metallic sound.</p>\n</blockquote>\n<p>This function is called each tick with a new note:</p>\n<pre><code class=\"language-javascript\">function tick (i, time) {\n  // ...\n  var r = risk(); // How the player is in danger\n  var metallic = 0.4 * r + 0.3 * smoothstep(-1, 1, Math.cos(Math.PI * i / 16));\n  var melo = i % 16 &lt; 8 ? melo1 : melo2;\n  var octave = i % 32 &lt; 16 ? 0 : 1;\n  var m = melo[i % 8] * (1 &lt;&lt; octave);\n  meloNote(m, time, meloIsArpeggio, metallic);\n  // ...\n}\n</code></pre>\n<h3 id=\"repeater-of-freestyle-part\">Repeater of freestyle part</h3>\n<p>A <strong>&quot;repeater&quot; with random delay add crazyness in the freestyle section</strong>. The delay time is randomly changed each time you hold the key so it gives cool feedback.</p>\n<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" src=\"https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110612559\"></iframe>\n\n<p>The <em>Repeater</em> is made of a <em>Delay</em> piped in a <em>Gain</em> and piped back in the delay input to produce feedback (echo).\nA particularity of this component is the input <em>Gain</em> is also the output <em>Gain</em>.</p>\n<p><img src=\"/images/2013/09/repeater_schema.png\" alt=\"\"></p>\n<p>Implementation of a Repeater:</p>\n<pre><code class=\"language-javascript\">  function Repeater (delayValue, repeatGainValue) {\n    var out = ctx.createGain();\n    var delay = ctx.createDelay(1); // The Max Delay\n    delay.delayTime.value = delayValue;\n    out.connect(delay);\n    var repeatGain = ctx.createGain();\n    repeatGain.gain.value = repeatGainValue;\n    delay.connect(repeatGain);\n    repeatGain.connect(out);\n    this.delay = delay;\n    this.repeater = repeatGain;\n    this.gain = this.inp = this.out = out;\n  }\n</code></pre>\n<h3 id=\"playing-with-stereo\">Playing with Stereo</h3>\n<p>Doing stereo with Web Audio API can be a bit verbose without wrapping it,\nhere is the Stereo component:</p>\n<pre><code class=\"language-javascript\">  function Stereo (left, right) {\n    var merger = ctx.createChannelMerger();\n    var inp = ctx.createGain();\n    inp.connect(left.inp);\n    inp.connect(right.inp);\n    this.inp = inp;\n    left.out.connect(merger, 0, 0);\n    right.out.connect(merger, 0, 1);\n    this.left = left;\n    this.right = right;\n    this.out = merger;\n  }\n</code></pre>\n<h3 id=\"drumbox\">Drumbox</h3>\n<p><strong>The Drumbox is simply made of a Kick, a Snare and a Hihat.</strong></p>\n<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" src=\"https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110781486\"></iframe>\n\n<p>A <strong>Snare</strong> is implemented with a Noise and a Filter:</p>\n<pre><code class=\"language-javascript\">  function Snare (volume, freqFrom, freqTo) {\n    var noise = new Noise();\n    noise.filter.type = &quot;lowpass&quot;;\n    noise.filter.Q.value = 5;\n    noise.gain.gain.value = 0;\n    this.noise = noise;\n    this.out = noise.out;\n    this.volume = volume || 1;\n    this.freqFrom = freqFrom || 800;\n    this.freqTo = freqTo || 1000;\n    this.release = 0.3;\n  }\n\n  Snare.prototype = {\n    trigger: function (time) {\n      this.noise.start(time, 1);\n      envelope(this.noise.gain, time, this.volume, 0.05, \n          0.01, 0.03, 0.25, this.release);\n      var f = this.noise.filter.frequency;\n      f.setValueAtTime(this.freqFrom, time);\n      f.linearRampToValueAtTime(this.freqTo, time+0.1);\n    }\n  };\n</code></pre>\n<p>The <strong>HiHat</strong> is also made with a Noise and a Filter, \nexcept the Filter is a highpass filter (only high frequency are audible).</p>\n<p>Finally, The <strong>Kick</strong> is made with a <code>Kicker</code> and a <code>Snare</code>.</p>\n<p>Here is the Kicker implementation:</p>\n<pre><code class=\"language-javascript\">  function Kicker (freq, attack, duration, fall) {\n    OscGain.call(this);\n    this.gain.gain.value = 0;\n    this.osc.frequency.value = freq;\n    this.freq = freq || 50;\n    this.fall = fall || 0;\n    this.attack = attack || 0;\n    this.duration = duration || 0;\n    this.volume = 1;\n  }\n\n  Kicker.prototype = {\n    start: function (time, duration) {\n      startNode(this.osc, time, 0, duration);\n    },\n    trigger: function (time) {\n      var a = this.attack, d = this.attack + 0.06, s = 0.8, r = 0.1;\n      this.start(time, this.duration + 1);\n      envelope(this.gain, time, this.volume, this.duration, a, d, s, r);\n      setValueAtTime(this.osc.frequency, this.freq, time);\n      linearRampToValueAtTime(this.osc.frequency, 0, time + this.fall);\n    }\n  };\n</code></pre>\n<p>And finally, here is my &quot;kick&quot; method called each time a user press the key:</p>\n<pre><code class=\"language-javascript\">  kick: function (t, errorRate) {\n    errorRate = errorRate * errorRate * errorRate;\n    var freq = mix(100, 120, errorRate);\n    var speed = mix(0.2, 0.3, errorRate) * 100 / vars.bpm;\n    var kick = new Kicker(freq, 0.01, speed, speed);\n    kick.volume = 1.5;\n    kick.osc.type = &quot;sine&quot;;\n    var filter = ctx.createBiquadFilter();\n    filter.frequency.value = mix(200, 300, errorRate);\n    filter.Q.value = 10 + 10 * errorRate;\n    kick.out.connect(filter);\n    filter.connect(drumOut.inp);\n    setTimeout(function () {\n      filter.disconnect(drumOut.inp);\n    }, 1000);\n    kick.trigger(t);\n\n    var snare = new Snare(0.5, 1000, 10);\n    snare.out.connect(drumOut.inp);\n    setTimeout(function () {\n      snare.out.disconnect(drumOut.inp);\n    }, 1000);\n    snare.trigger(t);\n\n    E.pub(&quot;kick&quot;, t);\n  }\n</code></pre>\n<h3 id=\"stereo-drumbox\">Stereo Drumbox</h3>\n<p>I&#39;ve used two Repeaters (one for the left, on for the right) on the Drumbox to produce some stereo echo effects.</p>\n<p>The effect can be very weak to hear, so I made in the following audio example 2 different delays so you can understand what I mean:</p>\n<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" src=\"https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110622238\"></iframe>\n\n<p>All sounds from the drumbox (snare, hihat, kick) is piped into &quot;drumOut&quot;, which have that Stereo system.</p>\n<p>Here is the code of the &quot;drumOut&quot; (the output where goes all Drum Box sounds):</p>\n<pre><code class=\"language-javascript\">  var drumOut = (function () {\n    // using the second example delay effect (listen to the soundcloud sound)\n    var left = new Repeater(0.1, 0.5);\n    var right = new Repeater(0.2, 0.7); // Playing with different values for stereo effects\n    right.gain.gain.value = 0.8; // move the drum a bit to the left\n    return new Stereo(left, right);\n  }());\n  drumOut.out.connect(out);\n</code></pre>\n<h2 id=\"the-glsl-shader\">The GLSL shader</h2>\n<p>Here is the GLSL code I used for the game, the final version is a bit crazy because I incrementally add features to it!\nAll the graphics are defined here!</p>\n<pre><code class=\"language-glsl\">#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define BPM_MIN 30.0\n#define BPM_MAX 150.0\n\nuniform vec2 resolution;\nuniform float time;\nuniform float kick;\nuniform float kickSpeed;\nuniform float bpm;\nuniform float lvl;\n\nuniform bool dubstepAction;\nuniform float useraction;\nuniform float successState;\n\nuniform float dubloading;\nuniform bool dubphase;\nuniform float pulseOpenFrom;\nuniform float pulseOpenTo;\n\nconst vec2 center = vec2(0.5, 0.5);\n\nconst float PI = 3.14159265359;\nconst float PI_x_2 = 6.28318530718;\n\nconst vec3 COLOR_NEUTRAL = vec3(0.1, 0.2, 0.7);\nconst vec3 COLOR_SUCCESS = vec3(0.0, 0.7, 0.1);\nconst vec3 COLOR_ERROR = vec3(0.7, 0.0, 0.05);\n\nfloat expInOut (float a) {\n  return 0.0==a ? 0.0 : 1.0==a ? 1.0 : 1.0 &gt; (a *= 2.0) ? 0.5 * pow(1024.0,a-1.0):0.5*(-pow(2.0,-10.0*(a-1.0))+2.0);\n}\n\nfloat random (vec2 pos) {\n  return fract(sin(dot(pos.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 random3 (vec2 pos) {\n  return vec3(\n    random(pos),\n    random(pos*3.),\n    random(pos*13.)\n  );\n}\n\nfloat distanceRadius (float a, float b) {\n  float d = mod(distance(a, b), PI_x_2);\n  return d &lt; PI ? d : PI_x_2 - d;\n}\n\nfloat spiralDistance (vec2 v, float r) {\n  float d = length(v);\n  float a = (PI + atan(v.x, v.y))/PI_x_2;\n  float n = log(d/r)+a;\n  return distance(1.0, 2.0 * smoothstep(0.0, 1.0, fract(n)));\n}\n\nfloat bpmToSec (float bpm) {\n  return 60. / bpm;\n}\n\nfloat circlePulse (\n  vec2 v, float kickForce,\n  float kickGlitchFreq, float kickGlitchAmp,\n  float thin, float pulseAngle, bool dubphase,\n  float waveFreq, float waveAmp, float waveDuration,\n  float bullForce\n) {\n  float angle = atan(-v.x, -v.y);\n  float clock = distanceRadius(0.0, angle) / PI;\n  float distAngle = distanceRadius(angle, PI_x_2 * pulseAngle) / PI;\n  float f = mix(1.0, smoothstep(-1.0, 1.0, cos(kickGlitchFreq * (clock+0.1*angle+kickForce))), kickGlitchAmp);\n  float r = mix(0.35, 0.2, kickForce*f);\n  float sc = smoothstep(1.0-waveDuration, 1.0, distAngle);\n  float intensity = 0.1+0.05*sc;\n  r /= mix(0.95, 1.0, waveAmp*sc*cos(angle*waveFreq));\n  float a = mod(PI_x_2+atan(v.x, v.y), PI_x_2)/PI_x_2;\n  float ring = abs(length(v)-r) - 0.03*bullForce*(!dubphase ? \n    smoothstep(1.0-1.5*waveDuration, 1.0, clock) : \n    (\n    a &lt; pulseOpenFrom ? smoothstep(0.05, 0.0, distance(a, pulseOpenFrom)) : \n    a &gt; pulseOpenTo ? smoothstep(0.05, 0.0, distance(a, pulseOpenTo)) : \n    1.0\n    )\n  );\n  float value = smoothstep(0.0, intensity, ring);\n  float returnValue = 1.0/sqrt(abs(value))/1.0 * pow(thin, 2.);\n  if ( length(v) &lt; r) {\n    float sr = PI;\n    float s = spiralDistance(v, sr);\n    float a = (PI + atan(v.x, v.y))/PI_x_2;;\n    float v = \n      smoothstep(0.02, 0., distanceRadius(PI+pulseAngle*PI_x_2, a*PI_x_2)/PI) *\n      smoothstep(0.2, 0., s);\n    returnValue += v * 2.0;\n    s = 1.0 - pow(smoothstep(0.0, 0.3, s), 0.3);\n    returnValue += s;\n  }\n  float centerIntensity = dubphase ? 0.1 : 0.1*dubloading;\n  if (centerIntensity &gt; 0.0) {\n    float s = bpmToSec(bpm);\n    float c = mix(1.0, 10.0, mod(time, s)/s) * smoothstep(centerIntensity, 0.0, length(v));\n    returnValue += c;\n  }\n  return returnValue;\n}\n\nvoid main (void) {\n  vec3 c = vec3(0.0);\n  vec2 p = gl_FragCoord.xy / resolution;\n  float sec = bpmToSec(bpm);\n  float statePower = smoothstep(0.8, 0.0, time-useraction);\n  float colorPower = dubstepAction ? 1.0 : statePower;\n  float cPulse = circlePulse(\n    p - center,\n    smoothstep(kickSpeed, 0.0, time-kick),\n    20.0,\n    0.5,\n    0.5 + 0.5 * smoothstep(smoothstep(0.6, 1.0, statePower), 0.0, distance(smoothstep(0.8, 1.0, statePower), distance(p, center))),\n    mod((time-kick)/sec, 1.0),\n    dubphase,\n    1.2*sqrt(bpm) + 4.0*statePower,\n    2.0,\n    min(0.5, bpm / 800.0),\n    1.0 - statePower\n  );\n  vec3 mainColor = mix(\n    COLOR_NEUTRAL,\n    mix(COLOR_ERROR, COLOR_SUCCESS, successState),\n    colorPower);\n  \n  c += cPulse * mainColor;\n\n  c = clamp(\n    c,\n    vec3(0.05, 0.05, 0.05),\n    vec3(1.0, 1.0, 1.0)\n  );\n\n  float bpmLight = smoothstep(BPM_MIN, BPM_MAX, bpm);\n  c = mix(c * (0.5 * random(p + time) + 0.5 * random(floor(p * 100.) + 0.01*time) - 0.5 * random(floor(p * 10.) + time)), c, min(1.0, 15.0*bpmLight));\n\n  c *= 0.1 + max(0.95, 100.0*(bpmLight-0.85));\n\n  gl_FragColor = vec4(c, 1.0);\n}\n</code></pre>\n<h2 id=\"bonus\">Bonus</h2>\n<p><strong>Did you recognize the melody I used in the freestyle part?</strong>\nThe melody doesn&#39;t keep the rhythm though, but you should be able to recognize it!</p>\n<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" src=\"https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F110614352\"></iframe>\n","data":{"title":"Making a rhythm game with bleeding-edge web","description":"While continuing to experiment with Web Audio API and GLSL, I've made a game called Timelapse for js13kgames (an HTML5 game competition where entries must be less than 13 kb zipped).","thumbnail":"/images/2013/09/timelapse.png","author":"Gaetan","layout":"post","tags":["js13k","GLSL","audio","gamedev"]}},"__N_SSG":true}