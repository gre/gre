{"pageProps":{"id":"2021-04-09-cryptoaliens-tech","year":"2021","month":"04","day":"09","slug":"cryptoaliens-tech","content":"<blockquote>\n<p>See also <a href=\"/2021/04/cryptoaliens\">CryptoAliens: Genesis</a> main article.</p>\n</blockquote>\n<p>This article explains how <a href=\"/2021/04/cryptoaliens\">CryptoAliens: Genesis (ethblock.art)</a> works in technical depth.</p>\n<p><img src=\"/images/posts/cryptoaliens/032_px.png\" width=\"50%\" /><img src=\"/images/posts/cryptoaliens/036_px.png\" width=\"50%\" /></p>\n<p>First of all, I would like to point out the <a href=\"https://github.com/gre/gre/tree/master/blockarts/CryptoAliens\">source code is available here on Github</a>.</p>\n<p>This whole idea was kicked off on <a href=\"https://twitch.tv/greweb\">Twitch</a>. A recording is <a href=\"https://www.youtube.com/watch?v=WUzOlLq0IAo\">available on Youtube</a>. Apart from the many glitches this 3 hours session had remained to be solved, the main part of this was implemented that night. Indeed I had to work countlessly on polishing the shaders, lighting and post-processing. I also spent a lot of time using the block data in a meaningful way because it&#39;s what <a href=\"https://ethblock.art\">EthBlock.art</a> really is about.</p>\n<h2 id=\"ethblockart-revolutionary-idea\">EthBlock.art revolutionary idea</h2>\n<p>Before going further into the technical details of CryptoAliens, I would like to point out how revolutionary this EthBlock.art idea is.</p>\n<p>The project aims to create a virtuous ecosystem of &quot;deterministic art&quot;, code visualization of Ethereum blocks. Everything is data: from the ethereum block of transactions, to the code that visualize it, and to the NFTs minted/traded using Ethereum transactions (that themselves are into Ethereum blocks).</p>\n<p><strong>This is a virtuous ecosystem, similar to <a href=\"https://en.wikipedia.org/wiki/Value_chain\">Supply Chain Transformation concepts</a>: each actor in this ecosystem add value and get retributed for it, as I tried to explain in this schema:</strong></p>\n<p><img src=\"/images/posts/cryptoaliens/ethblockart.png\" alt=\"\"></p>\n<p><code>CryptoAliens: Genesis</code> is one possible BlockStyle that I&#39;ve designed, as a creative coder. It tries to visualize what happened in the Ethereum Block and will take mods into account to try to be as good as possible to deliver interesting possibilities to BlockArt minters.</p>\n<h2 id=\"ok-so-how-is-it-implemented-technically\">Ok, so how is it implemented technically?</h2>\n<p>Indeed WebGL.</p>\n<p>More precisely, it is implemented with <a href=\"https://github.com/gre/gl-react\"><code>gl-react</code></a> which is convenient to write and compose <a href=\"https://www.khronos.org/opengl/wiki/Fragment_Shader\"><em>GLSL Fragment Shaders</em></a>.</p>\n<p><strong>here is the big picture of the pipeline:</strong></p>\n<p><img src=\"/images/posts/cryptoaliens/graph.gif\" alt=\"\"></p>\n<p>There are 2 main shaders: Mandelglitch (for skin texturing) and Scene (the main raymarching shader). Each of them take a bunch of parameters. <code>mod1..4</code> are values from the creator. The rest are inferred from the Block information, they are split into multiple parameters for convenience.</p>\n<p>The parameters <code>s1..9</code> are coming directly from <code>mersenne-twister</code> library, a <a href=\"https://en.wikipedia.org/wiki/Pseudorandom_number_generator\">PRNG</a> used to get a wide and deterministic variety of shapes, initialized with the block hash. That said, as pointed in the previous section, the main features of the shape are determined by Ethereum block information itself (number of transactions, timestamp, transfers, gas used,...).</p>\n<p>On top of these, some other parameters are controling key elements they come from more block information (heavy, head, bonesK, arms info,...).</p>\n<p>The technique implemented on the main Scene shader is <a href=\"https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\">raymarching distance functions</a>. The shapes at stake are mostly segments that are merged with a smooth union. There are many loops involved which made it challenging to optimize.\nThere may be issues on some mobile phone even tho it works on mine thanks to a &quot;pixelated&quot; version. (downscaling the pixels helped)</p>\n<p>Because of an heavy usage of this technique, the main scene was really challenging to optimize, it actually runs something like 5 FPS. My choice was to not animate it directly (you can see on the rendering graph that actually the buffer don&#39;t need to refresh, except when a &quot;mod&quot; is changed). However, thanks to intermediary framebuffers we can do 60 FPS animation at the postprocessing level. This is what the final user will get as the mods are static.</p>\n<h3 id=\"canvas-2d-to-draw-texts\">Canvas 2D to draw texts</h3>\n<p>A Canvas 2D element is used to draw the text that will appear on top of everything.</p>\n<pre><code class=\"language-js\">/// canvas used to draw in postprocessing ///\nfunction FrameText({ blockNumber, dateText, width, height, kg, bones }) {\n  const onCanvasRef = (canvas) =&gt; {\n    if (!canvas) return;\n    const ctx = canvas.getContext(&quot;2d&quot;);\n    const w = ctx.canvas.width;\n    const h = ctx.canvas.height;\n    const pad = Math.round(w * 0.01);\n    const padX = Math.round(w * 0.02);\n    const fontS = Math.floor(0.19 * w) / 10;\n    const fontSize = `${fontS}px`;\n    ctx.save();\n    ctx.fillStyle = &quot;#000&quot;;\n    ctx.fillRect(0, 0, w, h);\n    ctx.font = &quot;bold &quot; + fontSize + &quot; monospace&quot;;\n    ctx.textBaseline = &quot;top&quot;;\n    ctx.fillStyle = &quot;#fff&quot;;\n    ctx.fillText(`CryptoAliens specimen #${blockNumber}`, padX, pad);\n    ctx.textBaseline = &quot;bottom&quot;;\n    ctx.textAlign = &quot;right&quot;;\n    ctx.font = fontSize + &quot; monospace&quot;;\n    ctx.fillText(\n      `born ${dateText}, ${kg} kg, ${bones} bones`,\n      w - padX,\n      h - pad\n    );\n    ctx.restore();\n  };\n  return (\n    &lt;canvas\n      ref={onCanvasRef}\n      width={String(width * 2)}\n      height={String(height * 2)}\n    /&gt;\n  );\n}\nconst FrameTextCached = React.memo(FrameText);\n</code></pre>\n<h3 id=\"how-is-mandelglitch-used\">How is Mandelglitch used?</h3>\n<p>As said, <a href=\"https://ethblock.art/create/17\">Mandelglitch BlockStyle</a> is re-used in this CryptoAliens BlockStyle. This really is the power of gl-react: it makes such composability really easy to do, the same way you can compose React components.</p>\n<p>You can see in the <a href=\"https://www.youtube.com/watch?v=WUzOlLq0IAo\">Youtube recording</a> the way I have implemented it initially: it is just a simple import of Mandelglitch.js (literally the BlockStyle as-is) that I can just send as a uniform sampler2D.</p>\n<pre><code>&lt;Node\n  shader={sceneShaders.scene}\n  uniforms={{\n    t: &lt;Mandelglitch block={block} mod1={mod1} mod2={mod2} mod3={mod3} /&gt;,\n  ...\n</code></pre>\n<p>after that, it was simpler to embed Mandelglitch in the BlockStyle.</p>\n<p>The way Mandelglitch texturing is used however is that I will only use the &quot;red&quot; component and remap it to CryptoAliens&#39; own palette, in order to have a better control of the coloring.</p>\n<h3 id=\"code-organisation\">Code organisation</h3>\n<p>React and Gl-React allows to organize the code relatively easily. First of all each pass in the rendering scene is a component, then shaders are organized in the <code>Shaders.create</code> usage. I&#39;ve tried to collocate them (still in same one big file to simplify the upload to EthBlock.art).</p>\n<p>I find it pretty convenient to externalize piece of the logic into &quot;hooks&quot; function. Example:</p>\n<pre><code class=\"language-js\">const CustomStyle = (props) =&gt; {\n  // prettier-ignore\n  const { block, attributesRef, mod1, mod2, mod3, mod4, highQuality, width, height } = props;\n  // prettier-ignore\n  const { kg, bones, theme, background, s1, s2, s3, s4, s5, s6, s7, s8, heavy, head, bonesK, armsLen, armsSpread, armsCenter, armsEndW, dateText, blockNumber } =\n    useBlockDerivedData(block, mod1, mod2, mod3, mod4);\n\n  useAttributesSync(attributesRef, kg, bones, theme);\n\n  return (\n    &lt;LiveTV\n      text={\n        &lt;FrameTextCached ... /&gt;\n      }\n      ...\n    &gt;\n      &lt;NearestCopy width={w} height={h}&gt;\n        &lt;Scene\n          t={&lt;MandelglitchCached ... /&gt;}\n          ...\n        /&gt;\n      &lt;/NearestCopy&gt;\n    &lt;/LiveTV&gt;\n  );\n};\n</code></pre>\n<p><code>useBlockDerivedData</code> internally uses <code>useMemo</code> in order to cache the computation of block data interpretation.</p>\n<p>In order to make <strong>only</strong> one part of the tree to actively re-render, i&#39;ve used a local <code>useTime</code> that would re-render only that part (the LiveTV final shader). It&#39;s implementation is trivial:</p>\n<pre><code class=\"language-js\">function useTime() {\n  const [time, setTime] = useState(0);\n  useEffect(() =&gt; {\n    let startT;\n    let h;\n    function loop(t) {\n      h = requestAnimationFrame(loop);\n      if (!startT) startT = t;\n      setTime((t - startT) / 1000);\n    }\n    h = requestAnimationFrame(loop);\n    return () =&gt; cancelAnimationFrame(h);\n  }, []);\n  return time;\n}\n</code></pre>\n<h2 id=\"arms-joints-rotation-glsl-random-and-determinism\">Arms joints rotation, GLSL random and determinism</h2>\n<p>Ok, this is a hard topic. But it&#39;s extremely important that every BlockArt reliably produce the same result with the same block data, regardless of the computer used.</p>\n<p>That last &quot;regardless of computer used&quot; part has challenged me at the last minute! JavaScript doesn&#39;t have this problem because it&#39;s stable between implementations (computers, engines). However, <strong>this is not the case with OpenGL / GLSL</strong>: every computer, every hardware (GPU) or possibly the &quot;backend&quot; implementation for WebGL (<a href=\"https://github.com/google/angle\">ANGLE</a> have different backends) can differ when it comes to float precision and primitive results.</p>\n<p>In my shader, I was using the classical <code>random</code> function that is documented at <a href=\"https://thebookofshaders.com/10/\">https://thebookofshaders.com/10/</a></p>\n<pre><code class=\"language-cpp\">float random (vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n</code></pre>\n<p>It works very well when you need a nice 2D distributed noise for basic effects <strong>but it is very bad if you strongly rely on a stable &amp; consistent noise to generate different shapes</strong>.</p>\n<p>Empirically, I can observe that <code>sin()</code> yields different results on different computers.</p>\n<p>This was impacting me badly because I was able to see very various shapes:</p>\n<p><img src=\"/images/posts/cryptoaliens/rand1.png\" width=\"33%\"/><img src=\"/images/posts/cryptoaliens/rand2.png\" width=\"33%\"/><img src=\"/images/posts/cryptoaliens/rand3.png\" width=\"33%\"/></p>\n<p>What I need to varies a bit here is just the angle at each joint of the arms. This is very important for the uniqueness of the creature. The problem is that if each value changes a tiny bit, the whole thing diverge VERY QUICKLY, as the rotation angle will accumulate.</p>\n<p>Worse than that, I had a bad pattern to accumulate randomness like this:</p>\n<pre><code class=\"language-cpp\">float ss1 = s1;\nfor (int i = 0; i &lt; armsLen; i++) {\n  ss1 = random(ss1);\n  ...\n}\n</code></pre>\n<p>Actually I don&#39;t need that, first of all it&#39;s probably not good for performance, secondly I can just afford taking the fractional part of a simple polynomial:</p>\n<pre><code class=\"language-cpp\">float arm (inout vec3 p, float index, float w, float h) {\n  float s = sdSegment(p, h, w);\n  float base1 = 305.53 * s1 + 77.21 * index;\n  float base2 = 403.53 * s2 + 69.71 * index;\n  for (int i = 0; i &lt; armsLen; i++) {\n    float fi = float(i);\n    float ss1 = fract(base1 + 9.412 * fi);\n    float ss2 = fract(base2 + 8.823 * fi);\n    pR(p.xy, 8. * s4 * (ss2-.5));\n    pR(p.xz, 6. * s5 * (ss1-.5));\n    s = fOpUnionSoft(bonesK, s, sdSegment(p, h, w));\n    h *= .9;\n    w *= .9;\n    p.y -= 1.2 * h;\n  }\n  s = fOpUnionSoft(bonesK + 0.2 * s5, s, length(p) - armsEndW);\n  return s;\n}\n</code></pre>\n<p>Note that here it&#39;s very arbitrary numbers, the point is to obtain variety and unpredictability in the results. <code>fract</code> is a very simple operation (take the fractional part of the number). Indeed i&#39;m still prone to approximation, but the risk is limited by the fact i don&#39;t go too high in values here. Worse case scenario is it varies a bit the rotation but it should be so tiny that it won&#39;t be visible.</p>\n<p>As said before and as seen in this code, the number will be used to do rotations (that <code>pR</code> is transforming <code>p</code> with some rotations). I use <code>s4</code> and <code>s5</code> values to give the magnitude of rotations.</p>\n<p><strong>Let&#39;s look at a few cases:</strong></p>\n<p>If both s4 and s5 are very near 0.0, it will be straight arms (it&#39;s a rare case therefore).</p>\n<p><img src=\"/images/posts/cryptoaliens/042_px.png\" width=\"50%\"/><img src=\"/images/posts/cryptoaliens/033_px.png\" width=\"50%\"/></p>\n<p>If one of the s4 or s5 are 0.0, it will be only happening on one &quot;plan&quot;, or slightly diverging spirals, which I assume also to be rare cases:</p>\n<p><img src=\"/images/posts/cryptoaliens/017_px.png\" width=\"50%\"/><img src=\"/images/posts/cryptoaliens/020_px.png\" width=\"50%\"/></p>\n<p>Otherwise, most of the times, it will be relatively random:</p>\n<p><img src=\"/images/posts/cryptoaliens/029_px.png\" width=\"50%\"/><img src=\"/images/posts/cryptoaliens/032_px.png\" width=\"50%\"/>\n<img src=\"/images/posts/cryptoaliens/028_px.png\" width=\"50%\"/><img src=\"/images/posts/cryptoaliens/026_px.png\" width=\"50%\"/></p>\n<h2 id=\"going-128px-last-minute-decision-hard-tradeoff\">going 128px. Last minute decision, hard tradeoff</h2>\n<p>Due to concerns on the &quot;deterministic rendering&quot; from Ethblock.art folks, I had to make a choice regarding the fact it was too slow on mobile... I&#39;ve decided to switch to 128x128 rendering for ALL platforms so it&#39;s consistent.</p>\n<p>All the images on that article were done on 1024x1024 which is slow on computer and not even working on my mobile phone. (OnePlus)</p>\n<p>It&#39;s hard to have efficient raymarching today when you have many items.</p>\n<p><strong>Ultimately, I like how it finally looks, there were some minimalism / cell shaded styles,.. now it embraces Pixel Art even more!</strong></p>\n<p><img src=\"/images/posts/cryptoaliens/r02.png\" width=\"50%\" /><img src=\"/images/posts/cryptoaliens/r01.png\" width=\"50%\" /></p>\n<p>It&#39;s also always possible to make higher quality version of these rendering and I&#39;m excited to experiment more of these in future.</p>\n<hr>\n<p>My name is GaÃ«tan Renaudeau, and I&#39;m a noise explorer. <strong>feel free to ping me on Twitter <a href=\"https://twitter.com/greweb\">@greweb</a></strong></p>\n","data":{"title":"CryptoAliens: Genesis, a technical look","thumbnail":"/images/posts/cryptoaliens/026_px.png","description":"Technical aspects of CryptoAliens digital creatures generated with Ethereum blockchain blocks. They can be minted on ethblock.at by anyone, which establishes a limited set of CryptoAliens species.","tags":["NFT","shaders"]}},"__N_SSG":true}