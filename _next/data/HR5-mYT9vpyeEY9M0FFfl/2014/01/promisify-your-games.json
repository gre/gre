{"pageProps":{"id":"2014-01-12-promisify-your-games","year":"2014","month":"01","day":"12","slug":"promisify-your-games","content":"<p>One month ago was the <a href=\"http://www.ludumdare.com/compo/\">LudumDare</a> #28 gamejam theming <em>&quot;You Only Get One&quot;</em>.</p>\n<a href=\"http://greweb.me/ld28/\">\n  <img src=\"/images/2014/01/ld28.png\" alt=\"\" class=\"thumbnail-left\" />\n</a>\n\n<p>I <a href=\"http://www.ludumdare.com/compo/ludum-dare-28/?action=preview&amp;uid=18803\">submitted</a> a <a href=\"http://greweb.me/ld28/\">mini-game</a> which ranked 105th out of 2064 entries and also 26th in the &quot;theme&quot; category.</p>\n<p>This is of-course a web game implemented in JavaScript and using HTML and CSS.</p>\n<p>But actually, my main goal was not really making a game done \nbut more about technically <strong>making a state-of-the-art Promise-based game</strong>.</p>\n<p>I think <a href=\"/2013/07/q-a-promise-library/\">Promises</a> contains very interesting advantages in a game development design:\n<em>Resource loading managment</em>, <em>game scenes chaining</em>, <em>animations</em>... are some use-cases.</p>\n<ul>\n<li>Checkout the <a href=\"https://github.com/gre/ld28\">source code</a> on Github - <a href=\"https://github.com/gre/ld28/tree/master/src/app.js\"><code>src/app.js</code></a> is the entry point</li>\n<li>LudumDare entry is <a href=\"http://www.ludumdare.com/compo/ludum-dare-28/?action=preview&amp;uid=18803\">here</a>.</li>\n<li><a href=\"http://greweb.me/ld28/\">Play the Game</a>.</li>\n</ul>\n<!--more-->\n\n<h2 id=\"fp-in-game-development\">FP in game development</h2>\n<p>Using some Functional Programming paradigm in game development is interesting,\nand here I&#39;m just talking at least about the basic stuff:\n<strong>Avoid globals, Minimize state variables</strong>.</p>\n<p>I&#39;ve written a few games where restarting the game without using <code>location.reload()</code> was a challenge\nbecause the game variable states was so spread everywhere!</p>\n<p>By doing more FP, you can have this restart feature by design without need to &quot;reset&quot; all variables\nbecause your start function just takes everything it needs in parameter and restarting is just about re-calling that function.</p>\n<h2 id=\"promises-as-first-class-citizen\">Promises as first-class citizen</h2>\n<h3 id=\"game-scenes-chaining\">Game scenes chaining</h3>\n<p>Like maybe 99% of games, my game has an <strong>intro</strong> (menu), a <strong>main</strong> scene and an <strong>outro</strong> scene (gameover / finish).</p>\n<p>When you develop a game with just one big <code>render()</code> loop,\nit easily becomes a pain when you want to add more steps to the scene,\nit doesn&#39;t scale and fastly become spaghetti code:\nyou tend to have to figure out in which state you are (or which part of the animation timeline) from the game state.</p>\n<p>Hopefully, scene management is very easy to do with Promises:</p>\n<pre><code class=\"language-javascript\">function start () {\n  return Q()\n    .then(intro)\n    .then(_.partial(runMiniGames, 20))\n    .then(outro);\n}\n\nQ.all([/*..something to load..*/])\n .then(start/*, ..*/) // start game when ready\n .done(); // just help Q to trigger errors if some.\n</code></pre>\n<p>How beautiful to read! Call <code>intro</code> then run 20 mini-games then perform <code>outro</code>.</p>\n<h4 id=\"no-game-state-shared-pure-functions\">No game state shared, pure functions</h4>\n<p><strong>intro</strong> is the menu screen where you can choose the game difficulty.\n<strong>outro</strong> is the game end screen where the final score is displayed.\nThere is however <strong>no global variables shared</strong>, those are just passed from one function to another.</p>\n<p>Let&#39;s look deeper in how it works:</p>\n<ul>\n<li>The <code>intro()</code> function just returns a Promise resolved when the user made a &quot;difficulty&quot; choice. That Promise actually contains the difficulty (0, 1 or 2).</li>\n<li>The <code>runMiniGames</code> function takes 2 parameters: the number of games and the difficulty. <code>_.partial(runMiniGames, 20)</code> is just an helper for making a 20 mini-games function which takes the difficulty in parameter. This difficulty is given by the previous Promise. The <code>runMiniGames</code> function returns a Promise of Score (integer).</li>\n<li>That score is then fed into the <code>outro(score)</code> function which displays this score to the user.</li>\n</ul>\n<blockquote>\n<p><strong>TL;DR.</strong> This is just about plumbing 3 functions together!</p>\n</blockquote>\n<p>Checkout also the <a href=\"https://github.com/gre/ld28/blob/master/src/app.js#L24-L37\"><code>runMiniGames</code> implementation</a>.</p>\n<h4 id=\"speed-up-the-development\">Speed up the development</h4>\n<p>And you know what? It make development easier and faster because you can easily skip some part in any Promises chain:</p>\n<pre><code class=\"language-javascript\">function start () {\n  return Q(0)\n    //.then(intro) // Directly jump to the games\n    .then(_.partial(runMiniGames, 20))\n    .then(outro);\n}\n</code></pre>\n<p>I used that a lot and not only for this part, but for all part during the game development.</p>\n<h3 id=\"loading-resources\">Loading resources</h3>\n<p>Promises also help you to wait resources before starting the game.\nYou don&#39;t have to make yet another loading library, Promise already are ready for that, \nand you can also have proper error managment or even &quot;progress&quot; loading display (Q has Progress event in a Promise).</p>\n<p>Each loading resource is a Promise and you can combine them all using <code>Q.all</code>.</p>\n<p>Here is an example using <a href=\"https://npmjs.org/package/qajax\">Qajax</a> and <a href=\"https://npmjs.org/package/qimage\">Qimage</a>.</p>\n<pre><code class=\"language-javascript\">Q.all([\n  Qajax(&quot;music.wav&quot;).then(mapToAudio),\n  Qajax.getJSON(&quot;map.json&quot;),\n  Qimage(&quot;images/logo.png&quot;),\n  Qimage(&quot;images/textures.png&quot;)\n]).spread(function (music, map, logo, textures) {\n  \n  // Start the game !\n\n}, function (error) {\n\n  // display proper error\n\n}, function (progressEvent) {\n\n  // maybe you want to display a loading progress bar \n  // with that third progress callback.\n\n});\n</code></pre>\n<p>Here is a similar example:</p>\n<pre><code class=\"language-javascript\">var musicPromise = Qajax(&quot;music.wav&quot;).then(mapToAudio);\nvar mapPromise = Qajax.getJSON(&quot;map.json&quot;);\nvar texturesPromise = Qimage(&quot;images/textures.png&quot;);\nQ.all([ mapPromise, texturesPromise ]).spread(startGame, errorLoading);\n// because maybe you don&#39;t want to wait the music for starting the game:\nmusicPromise.then(function (a) { a.play(); });\n\nfunction startGame (map, textures) {\n  // ...\n}\nfunction errorLoading (e) {\n  // ...\n}\n</code></pre>\n<h3 id=\"mini-games-workflow\">Mini games workflow</h3>\n<p>My games is divided into a set of mini-games which are all independent but share a common interface.\nThis interface was quite a WIP at the end of the weekend development but it does the job.</p>\n<p>Here is the template I used for my game: <a href=\"https://github.com/gre/ld28/blob/master/src/games/_template.js\">src/games/_template.js</a>.</p>\n<p>A Game instance has different methods, and especially <code>enter</code> and <code>leave</code> method which are call on game enter and on game leave. It also has a <code>.end</code> Promise which is resolved when the Game end.</p>\n<ul>\n<li>A mini-game when solved gives a score depending on how well the user succeed it (through the <code>end</code> Promise).</li>\n<li>A mini-game have a timeout and if the player doesn&#39;t terminate it, it passes to the next game without scores.</li>\n</ul>\n<p>Those <code>enter()</code> and <code>leave()</code> methods return Promise in order to be plugged in the game workflow (we can wait them to finish before moving to next state).</p>\n<p>For instance, we don&#39;t start the game timeout before it actually starts (just wait the <code>enter()</code> Promise to be resolved) and also we don&#39;t switch to the next game before the <code>leave()</code> Promise is done).</p>\n<p>Checkout also the <a href=\"https://github.com/gre/ld28/blob/master/src/app.js#L51-L76\"><code>nextMiniGame</code> implementation</a>.\nThe result of that function is the score of the mini-game and that we sum up all scores from the previous score.</p>\n<h4 id=\"composability\">Composability</h4>\n<p>The <code>enter()</code> and <code>leave()</code> methods can be composed of animations which can themselves be composed of animations.</p>\n<p><strong>We can easily subdivided work into different level of Promises chain.</strong>\nHere is a little schema to summary that composability:</p>\n<p><img src=\"/images/2014/01/ld28_composition_schema.svg\" alt=\"\"></p>\n<h3 id=\"promise-animations\">Promise Animations</h3>\n<p>In my game, all the animations are controlled with Promises more exactly using CSS3 Transitions \nvia <strong><a href=\"https://github.com/peutetre/Zanimo\">Zanimo</a> Promise library</strong> because it fits my game (DOM-based game).\nThe fact that a Promise can be waited and chained <strong>gives a powerful controls over CSS Transitions for making animations</strong>.</p>\n<p>You can easily trigger animations <strong>one after another</strong> for moving an element in multiple places.\nYou can also perform <strong>multiple animations at the same times</strong> (on 2 different elements) and <strong>wait for both to finish</strong>\nbefore triggering a third animation.</p>\n<p>See for instance how <code>enter()</code> and <code>leave()</code> animations are done in mini-games.</p>\n<p>In the animation ending the &quot;memo&quot; game I used concurrent animations:\nall memo cards are randomly moved out.</p>\n<pre><code class=\"language-javascript\">/* // FYI\nCard.prototype.transform = function (x, y, scale, duration) {\n  return Zanimo.transition(this.el, &quot;transform&quot;,\n    &quot;translate(&quot;+x+&quot;px, &quot;+y+&quot;px) scale(&quot;+scale+&quot;)&quot;, duration||0);\n};\n*/\n\nfunction animateOut (dispersion) {\n  return Q.all(_.map(cards, function (card) {\n    if (card.destroyed) return Q(); // no animation because card is destroyed\n    return Q()\n      .then(function(){\n        return card.transform(card.x, card.y, card.number === 1 ? 1 : 0.8, 100);\n      })\n      .delay(Math.floor((card.number===1 ? 500 : 0)+300*Math.random()))\n      .then(function () {\n        var x = Math.round((Math.random()&lt;0.5 ? -card.w/dimensions.width-dispersion*Math.random() : 1+dispersion*Math.random())*dimensions.width);\n        var y = Math.round((Math.random()&lt;0.5 ? -card.h/dimensions.height-dispersion*Math.random() : 1+dispersion*Math.random())*dimensions.height);\n        return card.transform(x, y, 0, 500);\n      });\n  }));\n}\n\n// Usage in Memo.leave() :\nreturn Q.delay(50)\n  .then(function(){ return animateOut(0.5); })\n  .delay(100);\n</code></pre>\n<p>In the calculation game I used a chain of animations subdivided in functions:</p>\n<pre><code class=\"language-javascript\">return Q.delay(50)\n  .then(fadeOutInvalids)\n  .then(displaySolution)\n  .then(displayEquality)\n  .delay(500)\n  .then(fadeOut)\n  .then(hideEquality)\n  .delay(200);\n</code></pre>\n<p><a href=\"https://github.com/gre/ld28/blob/master/src/games/calculation.js#L411-L500\">Full code here</a>.</p>\n<h3 id=\"wait-for-next-click\">&quot;Wait for next click&quot;</h3>\n<p>While my game are just based on click user interaction,\nI&#39;ve made a <a href=\"https://github.com/gre/ld28/blob/master/src/waitNextClick.js\"><code>waitNextClick</code></a> function\nwhich returns a Promise of click for the given element.</p>\n<pre><code class=\"language-javascript\">var Q = require(&quot;q&quot;);\n\nmodule.exports = function waitNextClick (btn) {\n  var d = Q.defer();\n  btn.addEventListener(&quot;click&quot;, function listener (e) {\n    btn.removeEventListener(&quot;click&quot;, listener);\n    d.resolve(e.target);\n  }, false);\n  return d.promise;\n};\n</code></pre>\n<p>This was quite an interesting solution which is just like a jQuery &quot;once&quot; event but in Promise paradigm.</p>\n<p>I was able to combine that function with <code>Q.race</code> which wait for one of the given Promise to be redeemed.</p>\n<blockquote>\n<p><code>Q.race(_.map(btns, waitNextClick))</code></p>\n</blockquote>\n<p>For instance in the cats game, I just wait the first &quot;This one&quot; button to be clicked:</p>\n<pre><code class=\"language-javascript\">var houseChoice = Q.race(_.map(this.houses, function (catHouse) {\n    return waitNextClick(catHouse.btn)\n    .then(function () {\n      return catHouse;\n    });\n// houseChoice is a Promise of House choosen by the player.\n</code></pre>\n<h3 id=\"using-the-progress-event\">Using the &quot;progress&quot; event</h3>\n<p>I also used a bit the &quot;progress&quot; event of a Q Promise, which is a way to notify that a Promise is being resolved.</p>\n<ul>\n<li>I used that &quot;progress&quot; event on the <code>game.end</code> Promise for notifying that the player is winning some scores in a mini-game while playing.</li>\n<li>I also used it to make a timeout ticking the remaining time before the timeout is reached and that Promise resolved.</li>\n</ul>\n<p>See both usages <a href=\"https://github.com/gre/ld28/blob/master/src/app.js#L62-L70\">here</a>:</p>\n<pre><code class=\"language-javascript\">return Q.race([\n  gameEnd\n    .progress(function (score) {\n      stats.setScore(totalScore+score);\n    }),\n  timeoutWithTicks(gameEnd, timeout)\n    .progress(stats.setTimeProgress)\n    .then(_.bind(game.submit, game))\n]);\n</code></pre>\n<h2 id=\"code-organization-using-npm--browserify\">Code organization using NPM + Browserify</h2>\n<p>NPM &amp; Browserify has also been used because I find this stack very productive,\nespecially when writing a game from scratch.</p>\n<p>Browserify has been trendy the last past year, but there is here an interesting way of organizing your code\nand especially reusing it.\nYou can find a lot of <a href=\"https://npmjs.org/\">available modules using NPM</a>, \nBrowserify will just make you able to require them using <code>require(&quot;modulename&quot;)</code>.</p>\n","data":{"title":"Promisify your games","description":"a game showcase using Q Promise as first-class citizen and driven with CSS3 Animations via Zanimo.","thumbnail":"/images/2014/01/ld28.png","author":"Gaetan","layout":"post","tags":["gamedev","promise","Q","ludumdare"]}},"__N_SSG":true}