{"pageProps":{"id":"2016-07-01-projectseptember-opengl","year":"2016","month":"07","day":"01","slug":"projectseptember-opengl","content":"<p> ðŸŽ‰ Hooray! <a href=\"https://twitter.com/ProjSeptEng\">We</a> recently released an iOS app called <a href=\"https://projectseptember.com\">Project September</a>.</p>\n<p>This application is built with nice tech stack including <a href=\"http://facebook.github.io/react-native/\">React Native</a> and <a href=\"http://graphql.org/\">GraphQL</a>. The backend is powered by <a href=\"http://scala-lang.org/\">Scala</a>, a robust functional language, and we use many other <a href=\"https://twitter.com/ProjSeptEng\">cool techs</a>.</p>\n<p>This fashion app needed some fancy features: one was demo-ed at last <a href=\"/2016/06/glreactconf\">React.js conference</a> with the ability to do localized blur on text over images.</p>\n<p>We have developed <strong><a href=\"https://github.com/ProjectSeptemberInc/gl-react\"><code>gl-react</code></a></strong> to abstract GL in React paradigm â€“ with two companion libraries <a href=\"https://github.com/ProjectSeptemberInc/gl-react-dom\"><code>gl-react-dom</code></a> and <a href=\"https://github.com/ProjectSeptemberInc/gl-react-native\"><code>gl-react-native</code></a> that glues React Native with OpenGL.</p>\n<p>Let&#39;s first see 2 demos of OpenGL usage in our app, and then we&#39;ll write a bit about how it&#39;s hard to get animations right.</p>\n<!--more-->\n\n<h2 id=\"the-text-over-image-blur\">The Text Over Image blur</h2>\n<h3 id=\"the-goal\">The goal</h3>\n<p><img width=\"50%\" src=\"/images/2016/07/current-1.png\" /><img width=\"50%\" src=\"/images/2016/07/current-2.png\" /></p>\n<h3 id=\"how-it-works\">How it works</h3>\n<img src=\"/images/2016/07/initial.png\" />\n\n<p><strong>+</strong> <em><strong>(layer)</strong></em></p>\n<img src=\"/images/2016/07/layer.png\" />\n\n<p><strong>=</strong></p>\n<img src=\"/images/2016/07/result.png\" />\n\n\n<h3 id=\"under-the-hood\">Under the hood</h3>\n<ul>\n<li>The shadow intensity, size, position, is procedurally generated, we can adjust that. The shadow color is the blurry image color</li>\n<li>The text color is determined by the color picked in blurred image at the shadow middle position. <strong>If the <code>monochrome</code> value of that color is lower than 60%</strong>, text will be white, otherwise text will be black.</li>\n</ul>\n<p>Here is more detail on how the shadow is generated:</p>\n<img src=\"/images/2016/07/under-1.png\" />\n\n\n<p><strong>* (multiply alpha)</strong></p>\n<img src=\"/images/2016/07/under-2.png\" />\n\n<p><strong>=</strong></p>\n<img src=\"/images/2016/07/under-3.png\" />\n\n<p><strong>+ (layer)</strong></p>\n<img src=\"/images/2016/07/under-4.png\" />\n\n<p><strong>=</strong></p>\n<img src=\"/images/2016/07/layer.png\" />\n\n<h3 id=\"fragment-shader\">Fragment shader</h3>\n<pre><code class=\"language-glsl\">precision highp float;\nvarying vec2 uv;\n\nuniform sampler2D img;\nuniform sampler2D imgBlurred;\nuniform sampler2D txt;\n\nconst vec2 shadowCenter = vec2(0.5, 0.9);\nconst vec2 shadowSize = vec2(0.6, 0.2);\nfloat shadow () {\n  return 0.8 * smoothstep(1.0, 0.2, distance(uv / shadowSize, shadowCenter / shadowSize));\n}\nfloat monochrome (vec3 c) {\n  return 0.2125 * c.r + 0.7154 * c.g + 0.0721 * c.b;\n}\nvec3 textColor (vec3 bg) {\n  return vec3(step(monochrome(bg), 0.6));\n}\n\nvoid main () {\n  vec4 bg = mix(texture2D(img, uv), texture2D(imgBlurred, uv), shadow());\n  vec4 fg = vec4(textColor(texture2D(imgBlurred, shadowCenter).rgb), 1.0);\n  float fgFactor = 1.0 - texture2D(txt, uv).r;\n  gl_FragColor = mix(bg, fg, fgFactor);\n}\n</code></pre>\n<h3 id=\"integration\">Integration</h3>\n<pre><code class=\"language-html\">&lt;GL.Node shader={shaders.textOverImage}&gt;\n  &lt;GL.Uniform name=&quot;img&quot;&gt;\n    {img}\n  &lt;/GL.Uniform&gt;\n  &lt;GL.Uniform name=&quot;imgBlurred&quot;&gt;\n    &lt;Blur factor={20} passes={6} width={width} height={height}&gt;\n      {img}\n    &lt;/Blur&gt;\n  &lt;/GL.Uniform&gt;\n  &lt;GL.Uniform name=&quot;txt&quot;&gt;\n    &lt;Text style={titleStyle}&gt;{title}&lt;/Text&gt;\n  &lt;/GL.Uniform&gt;\n&lt;/GL.Node&gt;\n</code></pre>\n<h2 id=\"uploading-thumbnail\">Uploading Thumbnail</h2>\n<p>This is a video record of our app:</p>\n<p><img src=\"/images/2016/07/upload.gif\" alt=\"\"></p>\n<p>The uploading spinner effect is implemented with an OpenGL shader. This was not easy to avoid all the blinks we used to have. We have different components to render each step (uploading animation / uploaded final image) and the uploaded image needs to be downloaded again to not render as white. One solution could be to use a monolithic &quot;thumbnail&quot; component that do everything. We wanted to  keep independent components.\nHopefully, everything now works seamlessly with some &quot;double buffering&quot;/swapping mechanism we will explained at the end of this article.</p>\n<h2 id=\"animate-all-the-things\">Animate all the things</h2>\n<h3 id=\"designing-animations\">Designing animations</h3>\n<blockquote>\n<p>Fluid, meaningful animations are essential to the mobile user experience.\n<strong><a href=\"https://facebook.github.io/react-native/docs/animations.html\">â€” React Native Animations documentation</a></strong></p>\n</blockquote>\n<p>It&#39;s not easy to design how an application should animate, to define transitions between all the different possible single state and edge-cases of your app. Designing animations, as part of UX design, is a time consuming work but it tends to be underestimated while being essential for moving from a <em>good app</em> to a <em>very good app</em>. That tends to be the last 20% remaining missing parts of your app that are the hardest but that makes the 80% of a great UX.</p>\n<h3 id=\"implementing-animations\">Implementing animations</h3>\n<p>Not only it&#39;s hard to have figured out the animations (to find the optimal UX) but it can also be quite challenging to implement them in a maintainable and robust way. Turns out most of the times, your code is not ready for it and it implies big refactoring.</p>\n<h4 id=\"in-react-native\">in React Native</h4>\n<p>React Native <a href=\"https://facebook.github.io/react-native/docs/animations.html\">Animations API</a> makes it easier: you just have to switch to one of the <code>Animated.*</code> component. In <code>gl-react</code> we even support Animated values to flow into the shaders uniforms so it&#39;s very convenient to animate a GL effect.</p>\n<p>That said, React Native Animations is not the ultimate silver bullet. There are things Animations won&#39;t solve for you. React Native Animated is still a low level API, it&#39;s also imperative and not opinionated on how you should turn it into descriptive paradigm.</p>\n<p>I guess what&#39;s generally hard with animations in React functional/descriptive paradigm (&quot;always <code>render()</code>ing Virtual DOM again&quot; idea) is to figure out <strong>how to not &quot;break&quot; your animations</strong>. For instance, ugly animation interruption could happen if you <code>render()</code> a different component: because it forces the component to unmount. If you have an animation happening, you might not want it to stop, or at least you might want to smoothly customize the transition to the new state.</p>\n<p>That&#39;s something CSS transitions might help solving, but in React Native we don&#39;t have them, so it&#39;s not so trivial.</p>\n<h5 id=\"our-current-solution\">our current solution</h5>\n<p>We have built our own abstraction to solve this problem: a Component decorator manages to kill a lot of flashes and blinks cases (e.g. images not ready yet, animation getting interrupted).</p>\n<blockquote>\n<p>What the decoration solves: when moving from A to B, you want B to be ready (e.g. images are loaded), you also want A to have finish its (animated) work.</p>\n</blockquote>\n<p>*<em>A component can express it needs some time to mount <em>(e.g. an image to load!)</em> OR that it needs some time to unmount <em>(e.g. an &quot;animating out&quot;)</em>. This will basically hold the rendering to happen:</em>*</p>\n<p>The decoration can implement &quot;double buffering&quot; on a Component: <code>render()</code> function keeps rendering Component with the previous &quot;stable props&quot; but will also render in background another instance of Component with the next props. When that next props Component is ready and loaded, we can successful swap it to be the new &quot;stable props&quot;.</p>\n<p>You have the basic idea, the decorator is not so trivial to implement as it also needs to handle some edge-cases, for instance if the decorator receives new props during the transition. We also have a minimal way to express &quot;styles transitions&quot; similarly to how CSS Transitions works.</p>\n","data":{"title":"ðŸŽ‰ There are some OpenGL in the Project September fashion app!","author":"Gaetan","layout":"post","tags":["react","opengl","gl-react"]}},"__N_SSG":true}