{"pageProps":{"id":"2022-02-20-gnsp-swivel","year":"2022","month":"02","day":"20","slug":"gnsp-swivel","content":"<p>This fourth article (in a series of 7 articles) reveals the technique used to render the Nano swivel.</p>\n<p><video muted loop autoplay controls src=\"/images/2022/gnsp/361.mp4\" width=\"50%\" style=\"float:left; margin-right: 40px; margin-bottom:20px\"></video></p>\n<p><strong>Timeline:</strong></p>\n<ul>\n<li><a href=\"/2021/12/gnsp\">article 1: GNSP – the concept</a></li>\n<li><a href=\"/2021/12/gnsp-raymarching\">article 2: the 3D distance to a Nano S+</a></li>\n<li><a href=\"/2022/02/gnsp-nanoscreen\">article 3: the nano screen</a></li>\n<li><a href=\"/2022/02/gnsp-swivel\"><strong>article 4: the swivel</strong></a></li>\n<li>article 5: the background</li>\n<li>article 6: the video generation</li>\n<li>article 7: the final drop</li>\n<li>(?March) public mint</li>\n</ul>\n<p><strong>The collection is browsable on <a href=\"https://greweb.me/gnsp\">https://greweb.me/gnsp</a></strong></p>\n<p><strong>OpenSea: <a href=\"https://opensea.io/collection/gnsp\">https://opensea.io/collection/gnsp</a></strong></p>\n<br style=\"clear:left\"/>\n\n<p>This is very similar to the &quot;nano screen&quot; in that we will use a Canvas 2D as a texture to the GLSL shader and it will be projected on the swivel surface.</p>\n<h2 id=\"the-canvas-2d-generative-swivel-code\">The Canvas 2D generative swivel code</h2>\n<p>A canvas 2D of 1200 x 400 pixels is used to draw the swivel engraved texture. We use it to possibly display a text and draw some &quot;plotted lines&quot;.</p>\n<pre><code class=\"language-js\">async function metal(word, swivelPlotted) {\n  const w = 1200;\n  const h = 400;\n  const canvas = document.createElement(&quot;canvas&quot;);\n  canvas.width = w;\n  canvas.height = h;\n  const ctx = canvas.getContext(&quot;2d&quot;);\n  ctx.fillStyle = &quot;#000&quot;;\n  ctx.fillRect(0, 0, w, h);\n  ctx.fillStyle = &quot;#fff&quot;;\n  let font = &quot;Arial&quot;;\n  // ...plot things...\n  // ...draw text...\n  return canvas;\n}\n</code></pre>\n<p>Here is what the texture of #472 looks like:</p>\n<img src=\"/images/2022/gnsp/472-texture.png\" width=\"100%\" />\n\n<p>and here is the final result in the raymarched object:</p>\n<p><video muted loop autoplay controls src=\"/images/2022/gnsp/472.mp4\" width=\"100%\"></video></p>\n<h3 id=\"plotted-lines\">&quot;plotted&quot; lines</h3>\n<p><video muted loop autoplay controls src=\"/images/2022/gnsp/461.mp4\" width=\"100%\"></video></p>\n<p>The swivel can sometimes be &quot;laser plotted&quot; which is a reference to the &quot;plotting&quot; work I&#39;ve been doing last year. This &quot;plotting&quot; is a simple stacking of lines which create some mountains effect.</p>\n<p>In the following code, <code>swivelPlotted</code> is defined when plotting is active and is an array of random values.</p>\n<pre><code class=\"language-js\">if (swivelPlotted) {\n  ctx.strokeStyle = &quot;#fff&quot;;\n  ctx.lineWidth = 3;\n  const octaveCount = Math.floor(3 + 6 * swivelPlotted[4]);\n  const perlin = generatePerlinNoise(w, h, {\n    octaveCount,\n    amplitude: swivelPlotted[3],\n    persistence: 0.2,\n  });\n  let pad = [50, 20];\n  let amp = 120 * mix(swivelPlotted[0], swivelPlotted[1], swivelPlotted[2]);\n  let incr = Math.floor(3 + 50 * swivelPlotted[1]);\n  if (incr &lt; 15 || (octaveCount &lt; 4 &amp;&amp; amp &gt; 40)) {\n    ctx.fillStyle = &quot;#000&quot;;\n    font = &quot;Arial Black&quot;;\n  }\n  let heights = Array(w).fill(h);\n  for (let y = h - pad[1]; y &gt; pad[1] + amp; y -= incr) {\n    ctx.beginPath();\n    let up = true;\n    for (let x = pad[0]; x &lt; w - pad[0]; x++) {\n      let dy = amp * perlin[y * w + x];\n      let yy = y - dy;\n      let m = heights[x];\n      if (yy &gt; m) {\n        up = true;\n        continue;\n      }\n      heights[x] = yy;\n      if (up) {\n        ctx.moveTo(x, yy);\n        up = false;\n      } else {\n        ctx.lineTo(x, yy);\n      }\n    }\n    ctx.stroke();\n  }\n}\n</code></pre>\n<h3 id=\"text\">text</h3>\n<p>As shown at the beginning, we can also simply have a text on the swivel. Sometimes it is combined with the plotting effect.</p>\n<p><video muted loop autoplay controls src=\"/images/2022/gnsp/322.mp4\" width=\"100%\"></video></p>\n<pre><code class=\"language-js\">if (word) {\n  ctx.textAlign = &quot;center&quot;;\n  ctx.textBaseline = &quot;middle&quot;;\n  const lines = word.split(&quot;\\n&quot;);\n  const sz = Math.floor(\n    20 + 1200 / (3 + Math.max(...lines.map((l) =&gt; l.length)))\n  );\n  ctx.font = sz + &quot;px &quot; + font;\n  lines.forEach((line, i) =&gt; // multi line\n    ctx.fillText(\n      line,\n      w / 2,\n      Math.round(h / 2 + 1.2 * sz * (i + 0.5 - lines.length / 2))\n    )\n  );\n}\n</code></pre>\n<h3 id=\"sticker-text\">sticker text</h3>\n<p>We can also use emoji instead of text.</p>\n<p><video muted loop autoplay controls src=\"/images/2022/gnsp/365.mp4\" width=\"100%\"></video></p>\n<h2 id=\"raymarching-shader-integration\">Raymarching shader integration</h2>\n<p>The swivel metal texture is rendered using a brownian noise. (like explained in <a href=\"https://thebookofshaders.com/13/\">https://thebookofshaders.com/13/</a>)</p>\n<p>Contextually to the raymarching, we have the local coordinate of the swivel (including its rotation), which allows us to do a texture lookup on the swivel text texture. All of this information (noise and texture) is encoded in the material value (a float). It is possible to encode it on one value like this because it&#39;s a grayscale value.</p>\n<pre><code class=\"language-glsl\">noiseMetal = fbm(vec2(40.0, 1000.) * p.xy);\nvec2 coord = fract(vec2(1.0, -3.0) * p.xy + vec2(0.5));\nvec4 mt = texture2D(metalText, coord);\nfloat t = mix(0., grayscale(mt.rgb),mt.a * step(p.z, 0.) * step(p.x, -0.5) * step(abs(p.y), 0.16));\nfloat swivelM = 2.2 + t;\ns = opU(s, HIT(swivel, swivelM));\n</code></pre>\n<h2 id=\"sticker-emoji\">sticker emoji</h2>\n<p><video muted loop autoplay controls src=\"/images/2022/gnsp/321.mp4\" width=\"100%\"></video></p>\n<p>For the sticker that appear on the swivel, we add to the distance a disc and we use a side effect <code>vec3 sticker_color</code> variable that is later used in the <code>shade</code> function. The position of the sticker is randomly placed.</p>\n<pre><code class=\"language-glsl\">${\n  !opts.sticker\n    ? &quot;&quot;\n    : `\nvec2 q = p.xy + vec2(${opts.stickerPosX.toFixed(2)}, ${opts.stickerPosY.toFixed(2)});\nfloat sticker_size = 0.15;\nfloat sticker_border = 0.01;\ncoord = fract(vec2(.5,-.5) * q / sticker_size - 0.5);\nvec4 v = texture2D(stickerText, coord);\nsticker_color = mix(vec3(1.), v.rgb, v.a);\nfloat l = length(q.xy)-sticker_size;\ns = opU(s, HIT(max(\n  abs(p.z + 0.13)-0.005,\n  l-sticker_border\n), 4.2 - step(0.0, l)));\n`\n}\n</code></pre>\n","data":{"title":"GNSP – the swivel rendering","thumbnail":"/images/2022/gnsp/swivel-thumbnail.png","description":"This fourth article reveals the technique used to render the Nano swivel.","tags":["NFT"]}},"__N_SSG":true}