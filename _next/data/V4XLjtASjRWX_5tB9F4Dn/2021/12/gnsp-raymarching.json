{"pageProps":{"id":"2021-12-29-gnsp-raymarching","year":"2021","month":"12","day":"29","slug":"gnsp-raymarching","content":"<p>This second article (in a series of 7 articles) reveals the technique used to 3D render the Generative Nano S Plus collection: using a GLSL fragment shader, without any 3D model, raymarching a calculated distance to a Nano S Plus.</p>\n<p><video muted loop autoplay controls src=\"/images/2021/12/gnsp/509model.mp4\" width=\"50%\" style=\"float:left; margin-right: 40px; margin-bottom:20px\"></video></p>\n<p><strong>Timeline:</strong></p>\n<ul>\n<li><a href=\"/2021/12/gnsp\">article 1: GNSP â€“ the concept</a></li>\n<li><a href=\"/2021/12/gnsp-raymarching\"><strong>article 2: the 3D distance to a Nano S Plus</strong></a></li>\n<li><a href=\"/2022/02/gnsp-nanoscreen\">article 3: the nano screen</a></li>\n<li><a href=\"/2022/02/gnsp-swivel\">article 4: the swivel</a></li>\n<li>article 5: the background</li>\n<li>article 6: the video generation</li>\n<li>article 7: the final drop</li>\n<li>(?March) public mint</li>\n</ul>\n<p><strong>The collection is browsable on <a href=\"https://greweb.me/gnsp\">https://greweb.me/gnsp</a></strong></p>\n<p><strong>OpenSea: <a href=\"https://opensea.io/collection/gnsp\">https://opensea.io/collection/gnsp</a></strong></p>\n<br style=\"clear:left\"/>\n\n<h2 id=\"the-rendering-is-implemented-in-a-glsl-fragment-shader\">The rendering is implemented in a GLSL Fragment Shader</h2>\n<p>The generative art is rendered entirely into one &quot;fragment shader&quot;, which is essentially a GPU program that takes a bunch of inputs and efficiently calculates the pixel colors with your graphic card.</p>\n<p>This is a paradigm I like to call &quot;Functional Rendering paradigm&quot;: see article <a href=\"https://observablehq.com/@gre/introduction-to-functional-rendering-paradigm\">https://observablehq.com/@gre/introduction-to-functional-rendering-paradigm</a></p>\n<p>On top of this paradigm, I have used a technique called Raymarching distance function, see article <a href=\"https://observablehq.com/@gre/introduction-to-raymarching-distance-functions\">https://observablehq.com/@gre/introduction-to-raymarching-distance-functions</a></p>\n<p>Here is the main algorithm that implement the raymarching: (where <code>map</code> is the distance function)</p>\n<pre><code class=\"language-glsl\">HIT marcher (inout vec3 p, vec3 dir) {\n  HIT hit = HIT(0.);\n  float t = 0.;\n  for (int i=0; i&lt;120; i++) {\n    HIT h = map(p + t * dir);\n    t += h.x;\n    if (abs(h.x) &lt; .0001) {\n      hit = h;\n      break;\n    }\n  }\n  p += t * dir; \n  return hit;\n}\n</code></pre>\n<p>A fun proof of this is to play with the number of raymarching iteration (modulating iterations from 0 to 120):</p>\n<p><video muted loop autoplay controls src=\"/images/2021/12/gnsp/glitch.mp4\" width=\"50%\"></video><video muted loop autoplay controls src=\"/images/2021/12/gnsp/glitch2.mp4\" width=\"50%\"></video></p>\n<p>The main scene is described in this &quot;map&quot; distance function:</p>\n<pre><code class=\"language-glsl\">HIT map (vec3 position) {\n  HIT s = HIT(10. - length(position), 0.);\n  float t = 3. * fract(time);\n  float swivelAngle = PI * ( 1. +\n    cubicInOut(min(1.0, t)) +\n    cubicInOut(min(1.0, max(t - 1.8, 0.0))) );\n  s = opU(s, sdLedgerNanoSPlus(position, swivelAngle));\n  return s;\n}\n</code></pre>\n<h2 id=\"the-3d-distance-to-a-nano-s-plus\">The 3D distance to a Nano S Plus</h2>\n<p>Essentially, a Nano S Plus can be rendered with a bunch of union, difference and intersection math operations. Here are the basic utilities I used:</p>\n<pre><code class=\"language-glsl\">// SHAPE PRIMITIVES:\nfloat sdCylinder( vec3 p, vec3 c ) {\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBox2(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n}\nfloat sdBoxRoundZ(vec3 p, vec3 b, float r) {\n  return max(sdBox2(p.xy, b.xy-r)-r, abs(p.z)-b.z);\n}\n// SHAPE OPERATIONS:\nfloat fOpUnionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r - a,r - b), vec2(0));\n  return max(r, min (a, b)) - length(u);\n}\nfloat fOpIntersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a,r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\nfloat fOpDifferenceRound (float a, float b, float r) {\n  return fOpIntersectionRound(a, -b, r);\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nvoid pR(inout vec2 p, float a) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n</code></pre>\n<p>This code might seems complex, but it&#39;s relatively simple primitives, some are from this great article: <a href=\"https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\">https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</a></p>\n<p>With these utilities, I have developed that function called <code>sdLedgerNanoSPlus</code>, that implements the <strong>distance to a Nano S Plus</strong>:</p>\n<p><code>HIT sdLedgerNanoSPlus (vec3 p, float rot)</code></p>\n<p>Knowing the &quot;space distance to an object&quot; allows to use a raymarching algorithm to render it in 3D.</p>\n<p>The function takes two parameters <code>p</code> and <code>rot</code>:</p>\n<ul>\n<li><code>p</code> is the 3D point from which to evaluate the distance. If the Nano S Plus is at 1 meter away from the Nano S Plus, it must return a value of 1 meter. as simple as this.</li>\n<li><code>rot</code> allows for me to control the rotation of the swivel, so it can be animated from the caller.</li>\n</ul>\n<p>The function returns one <code>HIT</code> value. <code>HIT</code> is a simple alias to <code>vec2</code>, which actually allows me to return a tuple of two values: <code>(distance, material)</code>. On top of the distance, I need to track what is the &quot;closest material&quot;. Basically answering the question: from the point <code>p</code> what is the part of the Nano S Plus that is the closest? For instance, the swivel, the plastic part, the screen,...</p>\n<blockquote>\n<p>I was able to take precise measurements from some wireframes of the actual device and tried to make it as close as possible, transposed into code.</p>\n</blockquote>\n<p>This is probably a lot of code to digest, but here is its implementation:</p>\n<pre><code class=\"language-glsl\">HIT sdLedgerNanoSPlus (vec3 p, float rot) {\n  float btn = sdBoxRoundZ(\n    vec3(abs(p.x - 0.18) - 0.22, p.z, p.y - 0.155),\n    vec3(0.06, 0.03, 0.04), 0.03);\n  float case2d = sdBox2(p.xy, vec2(0.624, 0.174)-0.08)-0.08;\n  float swivel_hook = sdCylinder(p.xzy, vec3(-0.44, 0.0, 0.074));\n  HIT s = HIT(max(\n    min(\n      opSmoothSubtraction(\n            min(\n          max(case2d+0.015, abs(p.z+0.12)-0.015), // main casing carving\n          btn-0.004 // btns carving\n        ),\n        max(case2d, abs(p.z)-0.101) - 0.01, // main casing\n        0.008\n      ),\n      min(\n        btn,\n        max(swivel_hook-0.015, abs(p.z)-0.12) // plastic in the casing for the swivel\n      )\n    ),\n    -swivel_hook // carve the swivel hook out\n  ), 2.05);\n  // screen\n  float screen2 = sdBox2(p.xy - vec2(0.18, 0.), vec2(0.27, 0.12));\n  s = opU(s, HIT(max(s.x, screen2), 2.1));\n  // swivel\n  p.x += 0.04;\n  p.x += 0.4;\n  pR(p.xy, rot);\n  p.x -= 0.4;\n  float w = 0.54;\n  float x = p.x + 0.8;\n  float z = abs(p.z) - 0.12;\n  float swivel_radius = 0.192;\n  float swivel_metal_width = 0.006;\n  float rounding = 0.003;\n  float swivel = opSmoothSubtraction(\n    sdCylinder(p.xzy, vec3(-0.4, 0.0, 0.08)), // carved\n    min(\n      sdCappedCylinder(vec3(p.y, z, x - 0.4), swivel_radius, swivel_metal_width),\n      sdBox(vec3(x - 0.41 + w, p.y, z), vec3(w, swivel_radius, swivel_metal_width))\n    )-rounding,\n    0.04\n  );\n  // metal to close the swivel end\n  swivel = fOpUnionRound(swivel,\n    sdBox(vec3(x + 0.135 + w, p.y, p.z), vec3(swivel_metal_width, swivel_radius, 0.123))\n  ,0.01);\n  noiseMetal = fbm(vec2(40.0, 1000.) * p.xy);\n  vec2 coord = fract(vec2(1.0, -3.0) * p.xy + vec2(0.5));\n  vec4 mt = texture2D(metalText, coord);\n  float t = mix(0., grayscale(mt.rgb),mt.a * step(p.z, 0.) * step(p.x, -0.5) * step(abs(p.y), 0.16));\n  float swivelM = 2.2 + t;\n  s = opU(s, HIT(swivel, swivelM));\n  return s;\n}\n</code></pre>\n<p>To visualize it more, I&#39;ve animated the code to make it show the different steps union and difference operations:</p>\n<p><video muted loop autoplay controls src=\"/images/2021/12/gnsp/model.mp4\" width=\"100%\"></video></p>\n<p>But let&#39;s try to dive into more details and tricks.</p>\n<h3 id=\"the-main-casing\">The main casing</h3>\n<p>The first part of the function is making the plastic casing:</p>\n<pre><code class=\"language-glsl\">float btn = sdBoxRoundZ(\n  vec3(abs(p.x - 0.18) - 0.22, p.z, p.y - 0.155),\n  vec3(0.06, 0.03, 0.04), 0.03);\nfloat case2d = sdBox2(p.xy, vec2(0.624, 0.174)-0.08)-0.08;\nfloat swivel_hook = sdCylinder(p.xzy, vec3(-0.44, 0.0, 0.074));\nHIT s = HIT(max(\n  min(\n    opSmoothSubtraction(\n      min(\n        max(case2d+0.015, abs(p.z+0.12)-0.015), // main casing carving\n        btn-0.004 // btns carving\n      ),\n      max(case2d, abs(p.z)-0.101) - 0.01, // main casing\n      0.008\n    ),\n    min(\n      btn, // buttons themself\n      max(swivel_hook-0.015, abs(p.z)-0.12) // plastic in the casing for the swivel\n    )\n  ),\n  -swivel_hook // carve the swivel hook out\n), 2.05);\n</code></pre>\n<p>We can see that I use a lot of <code>min()</code> to combine the primitives. when you apply <code>min(A,B)</code> between the distance of objects A and B it is essentially the distance to the union of A and B, because min returns the closest distance. so <code>min</code> is an union.</p>\n<p>We can also see the use of many <code>max()</code> like for instance <code>max(case2d, abs(p.z)-0.101) - 0.01</code> which renders a rounded box but with sharp edge on the Z axis:</p>\n<p><img src=\"/images/2021/12/gnsp/casing.png\" alt=\"\"></p>\n<blockquote>\n<p><code>max(A, B)</code> is basically the intersection of A and B. Sadly, it&#39;s not an &quot;exact&quot; distance that limits the ability to bevel a tiny bit the edge. If someone have a trick to implement this shape with the exact distance, I would love to know.</p>\n</blockquote>\n<p><code>max(case2d, abs(p.z)-0.101) - 0.01</code> is therefore made of the intersection of:</p>\n<ul>\n<li><code>case2d</code> is a 2D box in xy space. defined by <code>sdBox2(p.xy, vec2(0.624, 0.174)-0.08)-0.08</code>. The value 0.8 is removed from the box dimension but also then removed from the distance. That value is actually the border radius of the box.</li>\n<li><code>abs(p.z)</code> is the distance to the Z plan. <code>abs(p.z)-0.101</code> is distance to a volume of the plan enlarged with a <code>0.101</code> padding.</li>\n</ul>\n<h3 id=\"carving-out\">Carving out</h3>\n<p><img src=\"/images/2021/12/gnsp/casingdig.png\" alt=\"\"></p>\n<p>The first operation done on the casing is to carve the part of the buttons and the inside. This is essentially done with the operation <code>max(A, -B)</code> (remove B from A), except here we are using a smooth difference operation to not make too &quot;sharp&quot; cuts.</p>\n<p>The same technique is used on the swivel hole:</p>\n<p><img src=\"/images/2021/12/gnsp/casingdig2.png\" alt=\"\"></p>\n<p>And again done on the model swivel shape:</p>\n<p><img src=\"/images/2021/12/gnsp/swiveldig.png\" alt=\"\"></p>\n<p><strong>but for the swivel, it is done with a &quot;smoothing difference&quot;</strong>, which creates the nice rounded effect in the hole:</p>\n<p><img src=\"/images/2021/12/gnsp/swiveldigresult.png\" alt=\"\"></p>\n<p>Here is the code that do this:</p>\n<pre><code class=\"language-glsl\">opSmoothSubtraction(\n  sdCylinder(p.xzy, vec3(-0.4, 0.0, 0.08)), // the carving shape is a cylinder\n  min(\n    sdCappedCylinder(vec3(p.y, z, x - 0.4), swivel_radius, swivel_metal_width), // circle of the swivel\n    sdBox(vec3(x - 0.41 + w, p.y, z), vec3(w, swivel_radius, swivel_metal_width)) // long rectangle metal part\n  )-rounding, // add a bit of rounding (bevel)\n  0.04\n)\n</code></pre>\n<p>and if we tweak that 0.04 value between 0.0 and 0.1, we obtain this interesting range of smoothing subtraction:</p>\n<p><video muted loop autoplay controls src=\"/images/2021/12/gnsp/smoothdiff.mp4\" width=\"50%\"></video><video muted loop autoplay controls src=\"/images/2021/12/gnsp/smoothdiff2.mp4\" width=\"50%\"></video></p>\n<p>There would be so much to improve in the modelization. For instance, I couldn&#39;t figure out a simple way to make the smooth corner of the swivel metal, so I end up with this simplification which isn&#39;t perfect:</p>\n<p><img src=\"/images/2021/12/gnsp/modelsimpl.png\" alt=\"\"></p>\n<pre><code class=\"language-glsl\">// metal to close the swivel end\nswivel = fOpUnionRound(swivel,\n  sdBox(vec3(x + 0.135 + w, p.y, p.z), vec3(swivel_metal_width, swivel_radius, 0.123))\n,0.01);\n</code></pre>\n<p>Distance function can always be optimized and details can always be added, possibilities are infinite it&#39;s only a matter of how much hours do you want to spend on. And on my case, it was basically a weekend.</p>\n<h2 id=\"lighting-and-material\">Lighting and material</h2>\n<p>There would be a lot to write about the accumulation of techniques used for the lightning. Basically there are 2-3 lights in the scene and some are casting some shadows using raymarching as well.</p>\n<p><video muted loop autoplay controls src=\"/images/2021/12/gnsp/material.mp4\" width=\"100%\"></video></p>\n<p><em>That video looks surprisingly so professional, I love it!</em> The scene is just this code:</p>\n<pre><code class=\"language-glsl\">HIT map (vec3 p) {\n  HIT s = HIT(10. - length(p), 0.);\n  s = opU(s, HIT(length(p)-0.5, 2.05)); // sphere distance is just length(p)-radius\n  return s;\n}\n</code></pre>\n<p>It shows the rendering of a sphere on the plastic material. Before I talk about the materials, let&#39;s focus on the lighting.</p>\n<h3 id=\"the-lighting\">The lighting</h3>\n<p>The general code that renders the scene is pretty straightforward:</p>\n<pre><code class=\"language-glsl\">vec3 scene(vec2 uv) {\n  vec3 c = vec3(0.); // color of the pixel to set\n  vec3 p = cameraP;\n  vec3 dir = normalize(vec3(uv - .5, 1.)); // perspective camera\n  dir = lookAt(cameraP, focusP) * dir; // camera focus on a point\n  HIT hit = marcher(p, dir); // this throw camera ray and tells what points it hits (material and distance)\n  vec3 n = normal(p); // this calculates the NORMAL VECTOR on the surface of the hit object\n  c += lighting(hit, p, n, dir); // &lt;= THIS IS WHERE LIGHTING IS CALCULATED\n  c = mix(c, sceneBgColor, pow(smoothstep(4., 10., length(p-cameraP)), .5)); // mist on far away objects\n  return c;\n}\n</code></pre>\n<p>Ok, so as you can see on the previous video, we have essentially 2 lights in the scene, one blueish and one redish. They spread differently in the material to simulate a bit their different size. We however can see the user of a THIRD light, which is more in the back and will be useful to simulate the fact the background is emitting its color. This was very useful for strong background colors like orange:</p>\n<p><video muted loop autoplay controls src=\"/images/2021/12/gnsp/100.mp4\" width=\"100%\"></video></p>\n<p>This is what lighting is implementing:</p>\n<pre><code class=\"language-glsl\">vec3 lighting (HIT hit, vec3 p, vec3 n, vec3 dir) { // (code is a bit simplified from original)\n  vec3 l, ldir;\n  vec3 c = vec3(0.);\n  l = vec3(lightPos, 1.5, -3.4);\n  vec3 obj = shade(hit, p);\n  ldir = normalize(l - p);\n  c +=\n  0.92 * vec3(0.9, 0.7, 0.6) * (\n    // ambient\n    0.1\n    // diffuse\n    + obj\n      * (.5 + .5 * diffuse(p, n, l)) // half lambert\n      * (0.5 + 0.5 * softshadow(p, ldir, 0.05, 5., 8.))\n    + specular(n, p, hit.y, ldir, dir, 10.)\n  );\n  l = vec3(-lightPos, 5., -2.);\n  ldir = normalize(l - p);\n  c +=\n  0.92 * vec3(0.3, 0.5, 0.6) * (\n  // ambient\n  0.1\n  // diffuse\n  + obj\n    * (.5 + .5 * diffuse(p, n, l)) // half lambert\n  + specular(n, p, hit.y, ldir, dir, 20.)\n  );\n\n  l = vec3(0., 2., 8.);\n  ldir = normalize(l - p);\n  c += bgLightColor * (\n    obj\n    * diffuse(p, n, l)\n    + specular(n, p, hit.y, ldir, dir, 20.)\n  );\n  return c;\n}\n</code></pre>\n<p>You can see the first thing done here is:</p>\n<pre><code>  vec3 obj = shade(hit, p);\n</code></pre>\n<p>It is a very important step that ask the hit object material &quot;give me your color&quot;. I will cover it in the Material section.</p>\n<p>Then for each light I want to apply, you can see the same pattern:</p>\n<p>First of all, we will put the light at a specific position in the space. For instance:</p>\n<pre><code class=\"language-glsl\">l = vec3(lightPos, 1.5, -3.4);\n</code></pre>\n<p>we calculate the actual light direction with <code>p</code> which is the point of interest to color.</p>\n<pre><code class=\"language-glsl\">ldir = normalize(l - p);\n</code></pre>\n<p>And then we can finally add to the object its emitted color:</p>\n<pre><code class=\"language-glsl\">  c +=\n  0.92 * vec3(0.9, 0.7, 0.6) * (\n    // ambient\n    0.1\n    // diffuse\n    + obj\n      * (.5 + .5 * diffuse(p, n, l)) // half lambert\n      * (0.5 + 0.5 * softshadow(p, ldir, 0.05, 5., 8.))\n    + specular(n, p, hit.y, ldir, dir, 10.)\n  );\n</code></pre>\n<p>and there are a few components that is very inspired by the classical &quot;ambient diffuse specular&quot; paradigm: <a href=\"https://learnopengl.com/Lighting/Basic-Lighting\">https://learnopengl.com/Lighting/Basic-Lighting</a> which I recommend you to read if you want to dive more into this part.</p>\n<p>In my case, I use half lambert technique which I find really interesting for a cartoon-ish effect <a href=\"https://developer.valvesoftware.com/wiki/Half_Lambert\">https://developer.valvesoftware.com/wiki/Half_Lambert</a> and because i don&#39;t use expensive ambient occlusion.</p>\n<p>I also, in this light case, will use <code>softshadow</code> that cast a shadow toward the light direction.</p>\n<p><strong>specular</strong> function is an important utility that have this implementation:</p>\n<pre><code class=\"language-glsl\">float specular (vec3 n, vec3 pos, float m, vec3 ldir, vec3 dir, float p) {\n  return specularStrength(m, n, pos) * pow(max(dot(dir, reflect(ldir, n)), 0.0), p);\n}\n</code></pre>\n<p>note that we can have different &quot;specular strength&quot; for each material or even depending on the position.</p>\n<h3 id=\"the-material-specularstrength\">The material <code>specularStrength()</code></h3>\n<p><video muted loop autoplay controls src=\"/images/2021/12/gnsp/material.mp4\" width=\"100%\"></video></p>\n<p>As we can see in this material, the plastic has been added some texturing.</p>\n<p>This is implemented with a fbm noise and it is contained in the material value.</p>\n<p>Then I had two possible ways to make it visible: either I change the color of the material OR I change the way it reflect lights in <code>specularStrength</code>. I&#39;ve used the second option for the plastic case:</p>\n<pre><code class=\"language-glsl\">float noiseMetal;\nfloat specularStrength (float m, vec3 n, vec3 p) {\n  if (m &lt; 2.1) {\n      float v =\n        n.z * fbm(600. * p.xy) +\n        n.x * fbm(600. * p.yz) +\n        n.y * fbm(600. * p.xz);\n      return 0.4 + 0.3 * v;\n  }\n  if (m &lt; 2.2) {\n    return 2.0;\n  }\n  if (m &lt; 4.) {\n    return 0.6 - 0.5 * noiseMetal + 1. * ceil(m-2.21);\n  }\n  return 0.4;\n}\n</code></pre>\n<p>So pretty basic stuff, I use <code>m</code> material value, which is a one dimension value to express all materials in. in plastic case, we are in the <code>m &lt; 2.1</code> case which have a strong noise frequency.</p>\n<p>On the same principle, we can see it is also done for the swivel metal.</p>\n<p>I used some trickery here because, as the swivel is moving, I had to use a global variable to set the noise value because I don&#39;t have the &quot;local position&quot;, only the global position.</p>\n<p>The <code>noiseMetal</code> is set directly from the <code>sdLedgerNanoSPlus</code> function with this:</p>\n<pre><code class=\"language-glsl\">noiseMetal = fbm(vec2(40.0, 1000.) * p.xy);\n</code></pre>\n<p>where <code>p</code> is a local position of the swivel, contextual to the rotation applied to it.</p>\n<p>The 40/1000 implements a stretched fbm noise which nicely recreates the effect:</p>\n<p><img src=\"/images/2021/12/gnsp/metaltexture.jpg\" alt=\"\"></p>\n<h3 id=\"the-material-shade\">The material <code>shade()</code></h3>\n<p><code>shade(hit,p)</code> is essentially the material coloring function. It tells what color does the object reflect at a given hit position.</p>\n<p>Here is its implementation for the whole scene (I have omitted some part that will be covered in other articles):</p>\n<pre><code class=\"language-glsl\">vec3 shade (HIT hit, vec3 p) {\n  if (hit.y &lt; 2.0) return sceneBgColor;\n  if (hit.y &lt; 4.0) {\n    if (hit.y &lt; 2.1) {\n        return plasticColor;\n    }\n    if (hit.y &lt; 2.2) {\n      return ...SCREEN RENDERING HERE...;\n    }\n    // swivel metal\n    return vec3(0.7 - 0.1 * noiseMetal - 0.2 * (hit.y - 2.2));\n  }\n  if (hit.y &lt; 5.0) {\n    return stickerColor;\n  }\n  return vec3(0.0);\n}\n</code></pre>\n<p>So it&#39;s a simple, &quot;give me the color of the material id number&quot;. The only trick for the noise metal was to make it a bit darker on some part to accentuate the metal effect.</p>\n<p><strong>The next article is going to dive into what this <code>...SCREEN RENDERING HERE...</code> part is doing, and more generally how I managed to also make the screen display text from inside a shader!</strong></p>\n","data":{"title":"GNSP â€“ the 3D distance to a Nano S Plus","thumbnail":"/images/2021/12/gnsp/glitch.png","description":"This second article (in a series of 7 articles) reveals the technique used to 3D render the Generative Nano S Plus collection: using a GLSL fragment shader, without any 3D model, but with raymarching distance function technique.","tags":["NFT"]}},"__N_SSG":true}