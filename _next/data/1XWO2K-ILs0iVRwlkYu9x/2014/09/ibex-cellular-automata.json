{"pageProps":{"id":"2014-09-22-ibex-cellular-automata","year":"2014","month":"09","day":"22","slug":"ibex-cellular-automata","content":"<a href=\"/2014/09/ibex\">\n  <img src=\"/images/2014/09/ibex-2.png\" alt=\"\" class=\"thumbnail-right\" />\n</a>\n\n<p>Last week I finished my <a href=\"/2014/09/ibex\">JS13K game called &quot;IBEX&quot;</a>,\nan apocalyptic game where you have to help some wild ibex to escape from the inferno.</p>\n<blockquote>\n<p>IBEX received the 16th place (out of 129 games) from the <a href=\"http://js13kgames.com/\">js13kgames</a> jury.</p>\n</blockquote>\n<p>This article is a technical post-mortem about the development of this game in JavaScript / WebGL\nand how the world is just <strong>ruled with <a href=\"http://en.wikipedia.org/wiki/Cellular_automaton\">cellular automata</a></strong>\nand computed efficiently in a GLSL shader.</p>\n<iframe width=\"50%\" height=\"220\" src=\"//www.youtube.com/embed/nqD2qIy4auU\" frameborder=\"0\" allowfullscreen></iframe>\n\n<!--more-->\n\n<h2 id=\"cellular-automata-ruled-world\">Cellular automata ruled world</h2>\n<p>A <strong>Cellular Automaton</strong> (plurial Cellular Automata) is an <strong>automaton</strong> <em>(in other words, a state machine)</em>\nbased on <strong>a grid (an array) of cells</strong>.\nIt has been discovered years ago and popularized by <a href=\"http://en.wikipedia.org/wiki/Stephen_Wolfram\">Stephen Wolfram</a>\nin his interesting book <a href=\"https://www.wolframscience.com/\">A new Kind of Science</a>.</p>\n<figure class=\"thumbnail-right\">\n  <img src=\"/images/2014/09/elementary-automaton.png\" />\n  <figcaption>\n    <a href=\"http://mathworld.wolfram.com/ElementaryCellularAutomaton.html\">\n      elementary automata.\n    </a>\n  </figcaption>\n</figure>\n\n<p>The simplest possible cellular automaton is the one where, at each generation,\nthe cell value is determined from the <strong>previous and the 2 adjacent cells</strong> (left and right)\nvalue and where the value can only be <strong>0 or 1</strong> (white or black / true or false).\nThe way the cell value is determined is through a set of rules.</p>\n<blockquote>\n<p>In an elementary cellular automaton, there is a total of 8 rules, which means 256 possible cellular automata.</p>\n</blockquote>\n<h3 id=\"2d-cellular-automaton\">2D cellular automaton</h3>\n<figure class=\"thumbnail-left\">\n  <img src=\"/images/2014/09/Gospers_glider_gun.gif\" />\n  <figcaption>\n    <a href=\"http://en.wikipedia.org/wiki/Conway's_Game_of_Life\">Conway's Game of Life</a>,\n    a well known 2D cellular automaton.\n  </figcaption>\n</figure>\n\n<p>The kind of Cellular Automaton I focused on for my game is <strong>2D cellular automaton</strong>:\nAt each generation, the cell value is determined from <strong>the previous value and the 8 adjacent cells</strong>\nusing a finite set of rules.</p>\n<p>It is important to understand that these rules are applied in parallel for <strong>all</strong> cells of the world.</p>\n<br />\n\n<figure class=\"thumbnail-right\">\n  <img src=\"/images/2014/09/ibex-experiment2.png\" />\n  <figcaption>\n    Early version with 4 elements and simple rules:\n    Water falls in Air, Fire grows in Air, Water extinguishes Fire, Earth drops Water + creates Fire\n  </figcaption>\n</figure>\n\n<p><strong>A 2D cellular automaton rule:</strong></p>\n<p><img src=\"/images/2014/09/ibex-rule-2d.png\" alt=\"\"></p>\n<p>What I&#39;ve found is that\n<strong>the WebGL and the GLSL language works well to implement a cellular automaton</strong>.</p>\n<p>The GLSL paradigm is what I like to call <a href=\"/2013/11/functional-rendering/\">functional rendering</a>:\nIt is, to simplify, a function <strong><code>(x,y) =&gt; (r,g,b,a)</code></strong>:\nYou fundamentally have to implement this function which <strong>gives a color for a given viewport position</strong>,\nand you implement it in a dedicated language which compiles to the GPU.</p>\n<p>So we can implement a 2D cellular automaton where each cell is a real (x,y) position in the Texture\nand where the (r,g,b,a) color is used to encode your possible cell states, and that&#39;s a lot of possible encoding!</p>\n<p>In my game, i&#39;ve chosen to only use the <code>&quot;r&quot;</code> component to implement the cell state.\nBut imagine all the possibilities of encoding more data per cell (like the velocity, the amount of particle in the cells,...).</p>\n<p><strong>Here is a boilerplate of making a Cellular Automaton in GLSL:</strong></p>\n<pre><code class=\"language-glsl\">uniform sampler2D state; // the previous world state texture.\nuniform vec2 size; // The world size (state texture width and height)\n\n/*\n The decode / encode functions provide an example of encoding\n an integer state in the &quot;r&quot; component over possible 16 values.\n You can definitely implement your own. Also &quot;int&quot; could be something more complex\n */\nint decode (vec4 color) {\n  return int(floor(.5 + 16.0 * texture2D(state, uv).r));\n}\nvec4 encode (int value) {\n  return vec4(float(r) / 16.0,  0.0, 0.0, 1.0);\n}\n\n/*\n  get(x,y) is doing a lookup in the state texture to get the (previous) state value of a position.\n */\nint get (int x, int y) {\n  vec2 uv = (gl_FragCoord.xy + vec2(x, y)) / size;\n  return (uv.x &lt; 0.0 || uv.x &gt;= 1.0 || uv.y &lt; 0.0 || uv.y &gt;= 1.0) ? 0 :\n    decode(texture2D(state, uv).r);\n}\n\nvoid main () {\n  // We get all neighbors cell values from previous state\n  int NW = get(-1, 1);\n  int NN = get( 0, 1);\n  int NE = get( 1, 1);\n  int WW = get(-1, 0);\n  int CC = get( 0, 0);\n  int EE = get( 1, 0);\n  int SW = get(-1,-1);\n  int SS = get( 0,-1);\n  int SE = get( 1,-1);\n\n  int r; // r (for result) is the new cell value.\n\n  ////////////////////////////\n  // NOW HERE IS THE COOL PART\n  // where you implement all your rules (from the 9 state values)\n  // and give a value to r.\n  ////////////////////////////\n\n  gl_FragColor = encode(r);\n}\n</code></pre>\n<blockquote>\n<p><strong>The complete game rules are all implemented in a GLSL fragment shader:\n<a href=\"https://github.com/gre/js13k-2014/blob/master/src/shaders/logic.frag\">logic.frag</a></strong>.\nIt is important to understand that this fragment shader takes in input\nthe previous world state (as an uniform texture)\nand computes a new state by applying the rules.</p>\n</blockquote>\n<p>On the JavaScript side, you need to <strong>give an initial state to the texture</strong>\n(so you need to also encode data the same way it is done in the shader).\nAlternatively you can also make a shader to do this job\n<em>(generating the terrain can be intense to do in JavaScript, like it is the case for my game...)</em>.</p>\n<p>Also if you want to <strong>query the world from JavaScript</strong>,\n<em>(e.g. you want to do physics or collision detection like it is also the case for my game)</em>,\nyou need to use <code>gl.readPixels</code> and then decode data in JavaScript.</p>\n<p>I&#39;ll explain this a bit later in another article.\nLet&#39;s now go back to the Cellular Automaton used in IBEX.</p>\n<figure>\n  <img src=\"/images/2014/09/ibex-screenshot1.png\" />\n  <figcaption>\n    The different elements gameplay.\n  </figcaption>\n</figure>\n\n<h3 id=\"the-elements\">The elements</h3>\n<p>The game theme was &quot;Four Elements: <strong>Water, Air, Earth, Fire</strong>&quot;, so I&#39;ve used\nthese 4 elements as primary elements of the cellular automaton.</p>\n<p>Each elements also have secondary elements that can be created from each other interactions:\n<strong>Source, Volcano, Grass, WindLeft, WindRight</strong>.</p>\n<ul>\n<li>The <strong>Volcano</strong> is lava growing in the Earth. It creates Fire (when there is Air).</li>\n<li>The <strong>Source</strong> is water infiltrating in the Earth. It drops Water (when there is Air).</li>\n<li>The <strong>Grass</strong> (or Forest) grows on Earth with Water. It is a speed bonus for ibex but it propagates fire very fast. It also stop the water from flowing.</li>\n<li>The <strong>Wind</strong> (left or right wind) is created randomly in Air. It have effects on Water and Fire propagation and also on ibex speed.</li>\n</ul>\n<p><strong>Some constants...</strong></p>\n<pre><code class=\"language-glsl\">// Elements\nint A  = 0; // Air\nint E  = 1; // Earth\nint F  = 2; // Fire\nint W  = 3; // Water\nint V  = 4; // Volcano\nint S  = 5; // Source\nint Al = 6; // Air Left (wind)\nint Ar = 7; // Air Right (wind)\nint G  = 8; // Grass (forest)\n</code></pre>\n<figure class=\"thumbnail-right\">\n  <img src=\"/images/2014/09/ibex-experiment1.png\" />\n  <figcaption>\n    Fun and experimental result accidentally produced in an early development of the rules.\n  </figcaption>\n</figure>\n\n<p>To summary, there is 9 possible elements,\nand rules are determined from the 9 previous cells:\nThis makes a LOT of possible rules.\nHowever, the rules involved here remain simple and with just a few rules.</p>\n<blockquote>\n<p>That is the big thing about cellular automata:\nvery simple rules produce an incredible variety of results.</p>\n</blockquote>\n<p>In general, we can classify my game rules into 2 kind of rules:\n&quot;interaction&quot; rules and &quot;propagation&quot; rules.\nThe first kind describes how two (or more!) elements interact each other.\nThe second kind describes the way an element evolve.\nSome rules will also mix them both.</p>\n<h3 id=\"some-simple-propagation-rule\">Some simple &quot;propagation rule&quot;</h3>\n<p><strong>Earth stays:</strong>\nan Earth is returned if there was an Earth before.</p>\n<p><img src=\"/images/2014/09/ibex-rule-earth.png\" alt=\"\"></p>\n<p><strong>Water falls in Air:</strong>\na Water is created if there was a Water on top.</p>\n<p><img src=\"/images/2014/09/ibex-rule-water1.png\" alt=\"\"></p>\n<p><strong>Fire grows in Air:</strong>\na Fire is created if there was a Fire on bottom.</p>\n<p><img src=\"/images/2014/09/ibex-rule-fire1.png\" alt=\"\"></p>\n<p>These rules produce very elementary result, we will now see how we can improve them.</p>\n<h3 id=\"weights-in-rules\">Weights in rules</h3>\n<p><strong>More powerful rules can also be reached by using weights</strong>:\nyou can affect a weight for each neighbor cell to give more or less importance to them.</p>\n<p>Let&#39;s take a look at a simple example:</p>\n<p><img src=\"/images/2014/09/ibex-rule-gencave-example.png\" alt=\"\"></p>\n<blockquote>\n<p>N.B.: only the &quot;sum&quot; is considered in the rule:\nif an element matches, we sum the weight of the cell, otherwise &quot;zero&quot;.</p>\n</blockquote>\n<p><strong>This example is actually a weighted version of <a href=\"http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels\">the cave rule you can find here</a>:</strong></p>\n<figure>\n  <figcaption>\n    Result of the rule, with (Air or Earth) random pick for each  initial cell value.\n  </figcaption>\n  <img src=\"/images/2014/09/ibex-gencaveresult.png\" />\n</figure>\n\n<h3 id=\"randomness-in-rules\">Randomness in rules</h3>\n<p><strong>Combine Randomness and Weights and you get a very powerful simulation.</strong></p>\n<p>To avoid seeing some (well known) patterns in the simulation I added some randomness in my rules.\n<strong>With randomness, the results are incredibly powerful.</strong></p>\n<p>In the following video, notice how cool the fire propagation can result\nby varying the propagation randomness factor.</p>\n<iframe width=\"100%\" height=\"420\" src=\"//www.youtube.com/embed/mF-MNHk7u4s\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n<p><strong>The code:</strong></p>\n<pre><code class=\"language-glsl\">#define AnyADJ(e) (NW==e||SE==e||NE==e||SW==e||NN==e||SS==e||EE==e||WW==e)\n// ^^^^^^^^ MACRO !\nif (\n  CC == G &amp;&amp;\n  RAND &lt; firePropagation &amp;&amp;\n  ( AnyADJ(F) || AnyADJ(V) )) {\n  r = F;\n}\n</code></pre>\n<h4 id=\"randomness-in-glsl-\">Randomness in GLSL ???</h4>\n<p>GLSL is fully stateless and there is <strong>NO WAY</strong> to have a <code>random()</code> function in the GPU.\nThe trick to do randomness in GLSL is by invoking some math black magic:</p>\n<pre><code class=\"language-glsl\">float rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n</code></pre>\n<p><strong><code>rand</code></strong> is a <a href=\"http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\">popular</a>\nfunction which returns a pseudo-random value (from 0.0 to 1.0) for a given position.</p>\n<p>My personal <strong>black magic</strong> was to define a convenient macro to have a &quot;RAND&quot; word which would get me\na new random number.</p>\n<pre><code class=\"language-glsl\">#define RAND (S_=vec2(rand(S_), rand(S_+9.))).x\n</code></pre>\n<p><code>S_</code> is a seed which is accumulated when calling this <code>RAND</code>.\nBecause this macro will be inlined in the code, <code>S_</code> must be defined in a local variable\n(so in summary, <code>RAND</code> is doing local side-effect).</p>\n<pre><code class=\"language-glsl\">vec2 p = gl_FragCoord.xy;\nvec2 S_ = p + 0.001 * time;\n</code></pre>\n<p>Note that <strong>the current pixel position</strong> itself AND <strong>the time</strong> are both used for initializing the seed.\nIt produces <strong>variable randomness over time and for each pixel</strong>.</p>\n<p>Let&#39;s now see other examples where randomness can be very powerful.</p>\n<h3 id=\"the-water-and-fire-interactions\">The Water and Fire interactions</h3>\n<p><strong>Fire grows and diverges</strong>:</p>\n<p><img src=\"/images/2014/09/ibex-rule-fire2.png\" alt=\"\"></p>\n<ul>\n<li>the &quot;left&quot; and the &quot;right&quot; columns in this rule allows <strong>divergence</strong> in the way fire grows:\nInstead of growing straight up, <strong>the fire can also move a bit left or a bit right</strong>.\nA lower weight for these side columns make the fire diverge a bit less than a &quot;triangle&quot; propagation.</li>\n</ul>\n<p>Here is the GLSL code:</p>\n<pre><code class=\"language-glsl\">// Fire grow / Fire + Water\nif (\n  -0.05 * float(NW==W) + -0.40 * float(NN==W) + -0.05 * float(NE==W) + // If water drop...\n  -0.50 * float(WW==W) + -0.50 * float(CC==W) + -0.50 * float(EE==W) + // ...or water nearby.\n   0.35 * float(SW==F) +  0.90 * float(SS==F) +  0.35 * float(SE==F)   // Fire will move up and expand a bit.\n &gt;= 0.9 - 0.6 * RAND // The sum of matched weights must be enough important, also with some randomness\n) {\n  r = F;\n}\n</code></pre>\n<p><strong>Water falls, diverges and creates holes</strong>:</p>\n<p><img src=\"/images/2014/09/ibex-rule-water2.png\" alt=\"\"></p>\n<figure class=\"thumbnail-right\">\n  <img src=\"/images/2014/09/ibex-rain.png\"/>\n  <figcaption>The rain in IBEX. Notice how Water diverges a bit and creates holes.</figcaption>\n</figure>\n\n<ul>\n<li>Same as the fire rule, we also have <strong>divergence</strong> in the water.</li>\n<li>However there is one more important thing in the rule:\nthanks to the <strong>double inequality</strong>,\nWater is created only if there is not already too much Water:\nit <strong>results of creating Air between the Water particules</strong>.\nThis make Water elements to be less compact than Fire elements,\nthe water does not visually &quot;expand&quot; contrary to the fire.</li>\n<li>The <strong>randomness</strong> helps a lot here to give <strong>no visible patterns</strong> in this job.</li>\n</ul>\n<br />\n\n<p>Here are all rules which creates Water:\nin this rules you can also notice how <strong>the Water flows on Earth</strong> and how\nthe <strong>occasional rain</strong> is implemented.</p>\n<pre><code class=\"language-glsl\">if (\n// Water drop / Water + Fire\n  between(\n    0.3 * float(NW==W) +  0.9 * float(NN==W) +  0.3 * float(NE==W) +\n    0.1 * float(WW==W) + -0.3 * float(CC==F) +  0.1 * float(EE==W) +\n                         -0.3 * float(SS==F)  \n    ,\n    0.9 - 0.6 * RAND,\n    1.4 + 0.3 * RAND\n  )\n\n  || // Water flow on earth rules\n\n  !prevIsSolid &amp;&amp;\n  RAND &lt; 0.98 &amp;&amp;\n  ( (WW==W||NW==W) &amp;&amp; SW==E || (EE==W||NE==W) &amp;&amp; SE==E )\n\n  || // Occasional rain\n  !prevIsSolid &amp;&amp;\n  p.y &gt;= SZ.y-1.0 &amp;&amp;\n  rainRelativeTime &lt; 100.0 &amp;&amp;\n  between(\n    p.x -\n    (rand(vec2(SD*0.7 + TI - rainRelativeTime)) * SZ.x) // Rain Start\n    ,\n    0.0,\n    100.0 * rand(vec2(SD + TI - rainRelativeTime)) // Rain Length\n  )\n\n  || // Source creates water\n  !prevIsSolid &amp;&amp; (\n    0.9 * float(NW==S) +  1.0 * float(NN==S) +  0.9 * float(NE==S) +\n    0.7 * float(WW==S) +                        0.7 * float(EE==S)\n    &gt;= 1.0 - 0.3 * RAND\n  )\n) {\n  r = W;\n}\n</code></pre>\n<p><strong>Source rules</strong></p>\n<p>The Source can be created in the Earth by two rules:\nEither there is enough water around,\nOr there is source on top.</p>\n<p>Note the important usage of randomness.</p>\n<p><img src=\"/images/2014/09/ibex-rule-source.png\" alt=\"\"></p>\n<h3 id=\"the-grass-propagation-limiting-the-forest-height\">The grass propagation, Limiting the forest height</h3>\n<p>To finish, the grass needed a special extension to the so-far-used 2D cellular automaton,\nthe grass cell value is not only being determined from the 8 adjacent cells:</p>\n<p>To have more complex structure, <strong>the grass is determined\nfrom the previous cell at position <code>(x, y-N)</code></strong>,\nwhere x and y is the cell position and N is a variable value (random but constant per cell position).\nIn other word, a forest can grow if the cell at N step under it is not a forest.\nThis extra rule just adds a constraint on the max height that a forest can have.</p>\n<figure>\n  <figcaption>A Grass can be created if the (x,y-N) cell is not a Grass.</figcaption>\n  <img src=\"/images/2014/09/ibex-rule-forest-specific.png\" />\n</figure>\n\n\n<p>Here is a demo showing the forest propagation randomness:</p>\n<iframe width=\"100%\" height=\"480\" src=\"//www.youtube.com/embed/V_enCKx8XHA\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"></iframe>\n\n\n<h3 id=\"drawing-into-the-world\">Drawing into the world</h3>\n<p><strong>Drawing into the world is also done in GLSL: through uniforms.</strong>\nAnother alternative way to do that would have be to use <code>gl.readPixels</code> to extract it out in JavaScript,\nto write into the Array and inject it back to the shader...\nbut this solution is not optimal because <code>readPixels</code> is blocking and costy (CPU time).</p>\n<pre><code class=\"language-glsl\">uniform bool draw; // if true, we must draw for this tick.\nuniform ivec2 drawPosition; // The position of the drawing brush\nuniform float drawRadius; // The radius of the drawing brush\nuniform int drawObject; // The element to draw\n\n\nvoid main (void) {\n  ...\n  bool prevIsSolid = CC==E||CC==G||CC==V||CC==S;\n\n  if (draw) {\n    vec2 pos = floor(p);\n    if (distance(pos, vec2(drawPosition)) &lt;= drawRadius) {\n    // Inside the brush disc\n      if (drawObject == W) {\n        // Draw Water\n        if (prevIsSolid &amp;&amp; CC!=G) {\n          // Source is drawn instead if there was a solid cell\n          r = S;\n        }\n        else if (!prevIsSolid &amp;&amp; mod(pos.x + pos.y, 2.0)==0.0) {\n          // We draw Water half of the time because Water is destroyed when surrounded by Water\n          r = W;\n        }\n      }\n      else if (drawObject == F) {\n        // Draw fire or volcano if solid cell.\n        r = prevIsSolid ? V : F;\n      }\n      else {\n        // Draw any other element\n        r = drawObject;\n      }\n    }\n  }\n\n  ...\n}\n</code></pre>\n<h2 id=\"world-generation-is-also-a-cellular-automaton\">World generation is also a Cellular automaton!</h2>\n<p>The world is generated on the fly when the ibex progress to the right. This is done chunk by chunk.</p>\n<blockquote>\n<p>More precisely, the world height is 256 pixels and a new part of the world is discovered each 128 pixels â€“\nIn other words, the generation is divided into world chunks of <code>(128 x 256)</code> pixels.</p>\n</blockquote>\n<p>Each world chunk is generated using a cellular automaton (different from the simulation one).</p>\n<p>As shown in a previous example,\nwe can easily generate &quot;cave like maps&quot; from <a href=\"http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels\">this technique</a>.\nI&#39;ve added to this a <a href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L842\">few improvments</a>:</p>\n<ul>\n<li>The <a href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L881\">initial random conditions</a> ensure\nthat <strong>the bottom of the world is Earth</strong> and that <strong>the top of the world is Air</strong>.</li>\n</ul>\n<p><em>(that with gradients of randomness)</em></p>\n<ul>\n<li><a href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L896-L906\">Randomness</a>\nhas been added to the rules to make the terrain evolving a bit more</li>\n</ul>\n<p><em>(otherwise it creates stable but small caves)</em>.</p>\n<ul>\n<li>The number of generation step is set to 26. the randomness of the rules is decreasing through steps to produce stable results.</li>\n<li>In an attempt to create <strong>seamless maps</strong>,\nthe initial random state for x=0 is set to the values of x=127 of the previous world chunk.\n<a href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L878\">(code here)</a>\nIt isn&#39;t perfect because you can still notice some edges.</li>\n<li>For <strong>more diversity in generated chunks</strong>, here are the parameters that can <a href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L845-L848\">randomly vary</a>:<ul>\n<li>The <strong>amount of Earth</strong> (can create dense areas VS floating platform areas)</li>\n<li>The <strong>chance of Water Source</strong> in the Earth (will creates a lot of forest)</li>\n<li>The <strong>chance of Volcano</strong> in the Earth (dangerous world chunk)</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/2014/09/ibex-gen-variety.png\" alt=\"\"></p>\n<h2 id=\"more-articles-to-come\">More articles to come</h2>\n<p>Did you like this article?</p>\n<p>I&#39;ll try to write more about these subjects:</p>\n<ul>\n<li>The <strong>&quot;Pixels paradigm&quot;</strong>, Pixel as first class citizen: How to query and analyze the pixels world. How to do simple bitmap collision detection.</li>\n<li>The <strong>game rendering performed in a GLSL shader</strong> and all the graphics details I&#39;ve spent hours on.</li>\n<li><strong>things I&#39;ve learned from WebGL</strong>, how to solve the bad approaches I&#39;ve taken,\nand how I could have made a much more efficient game.</li>\n<li><strong>what could have made this game even more interesting</strong>,\nand some ideas that was not reachable in a 2 weeks deadline.</li>\n</ul>\n","data":{"title":"Cellular Automata in IBEX","description":"IBEX is my game made for js13kgames. This article explains how the game has been implemented with GLSL and cellular automata.","thumbnail":"/images/2014/09/ibex-2.png","author":"Gaetan","layout":"post","tags":["gamedev","js13k","GLSL"]}},"__N_SSG":true}