{"pageProps":{"id":"2016-12-03-gl-react-v3","year":"2016","month":"12","day":"03","slug":"gl-react-v3","content":"<h1 id=\"happy-to-release-httpsgl-react-cookbooksurgesh-containing-43-unique-examples-and-api-documentation\">Happy to release <strong><a href=\"https://gl-react-cookbook.surge.sh\">https://gl-react-cookbook.surge.sh</a></strong> containing 43 unique examples and API documentation!</h1>\n<p><a href=\"https://gl-react-cookbook.surge.sh\"><img src=\"/images/2016/12/gl-react-v3.gif\" alt=\"\"></a></p>\n<blockquote>\n<p>If you don&#39;t want to be &quot;spoiled&quot; by this article, go through <a href=\"https://gl-react-cookbook.surge.sh\">the cookbook examples</a>. This article will explore some of them.</p>\n</blockquote>\n<!--more-->\n\n<h2 id=\"gl-react-has-been-rewritten-from-scratch\">gl-react has been rewritten from scratch</h2>\n<p><strong>gl-react v3 is a complete rewrite of the v2 implementation for better performance and compatibility with React paradigm.</strong></p>\n<p>This is not yet published on NPM as it&#39;s <a href=\"https://github.com/gre/gl-react\">still in development</a> (the Web version is pretty ready, React Native version is not implemented).</p>\n<p>Most features provided by gl-react v2 are preserved (API haven&#39;t changed, <a href=\"https://gl-react-cookbook.surge.sh/hellogl\">see how similar is the HelloGL example</a>), but v3 fixes most Github issues accumulated for a year.</p>\n<h3 id=\"the-biggest-mistake-of-the-previous-implementation\">The biggest mistake of the previous implementation</h3>\n<p>If there is one lesson learned from previous gl-react implementation: <strong>&quot;unfolding&quot; / consuming the <code>children</code> prop by yourself is (probably) wrong, let React solve this job!</strong> Using React, you can benefit <a href=\"https://facebook.github.io/react/docs/reconciliation.html\">React reconciliation and diff algorithm</a>.\nIn other words, always prefer to keep users&#39; VDOM tree rather than consuming it with <code>React.Children.*</code> functions.</p>\n<p>I feel dumb not having discovered this before, but if you are not actually rendering DOM it&#39;s an easy path for a library to just map, traverse, consume the children tree and just render what you needs (like just a <code>&lt;canvas/&gt;</code>). But this is probably a mistake! First, this makes it impossible to use React Devtools and see the original tree, but more importantly, it breaks interoperability with other libraries (e.g. don&#39;t forbid someone to use <a href=\"https://github.com/chenglou/react-motion\">react-motion</a> or <a href=\"https://github.com/ReactTraining/react-router\">React Router</a> in the middle of your components!).</p>\n<p>A better idea is to preserve the user <code>children</code>. Keep your logic in each Component and use the React lifecycle to create and destroy things, and <strong>use <a href=\"https://facebook.github.io/react/docs/context.html\">React context</a> to connect children to parent</strong>.</p>\n<blockquote>\n<p>You should better keep user <code>children</code>, even if it means rendering it in an empty <code>&lt;span&gt;</code>, <em>current workaround of <code>gl-react</code>, looking forward to hearing from you, idea inspired from the great <a href=\"https://github.com/FormidableLabs/react-music\">react-music</a></em></p>\n</blockquote>\n<h3 id=\"what-it-means-for-gl-react\">What it means for gl-react</h3>\n<p>The gl-react v3 implementation truly uses React lifecycle: <strong>a React Component update triggers a GL redraw</strong>. That way, <code>shouldComponentUpdate</code> allows to do partial GL re-rendering. Each Node holds a <a href=\"https://www.opengl.org/wiki/Framebuffer_Object\">framebuffer object</a> (created on mount, destroyed on unmount) that only get redrawn when component updates and schedules a Surface reflow.</p>\n<p><code>&lt;Node&gt;</code> receives the <code>gl: WebGLRenderingContext</code> from the ancestor <code>&lt;Surface&gt;</code> thanks to <a href=\"https://facebook.github.io/react/docs/context.html\">React context</a>. There is also a <code>glParent</code> context (a Surface or another Node) that is used to make GL components discoverable each other so we can build a dependency graph. This dependency graph allows to implement the correct <code>draw</code> pipeline (and it&#39;s pretty trivial, see <a href=\"#under_the_hook_redraw\"><em>Section &quot;under the hood of Surface and Node redraw&quot;</em></a>).</p>\n<h2 id=\"bus-a-better-way-to-share-computation\"><code>&lt;Bus&gt;</code>, a better way to share computation</h2>\n<p><a href=\"http://greweb.me/2016/06/glreactconf/\">gl-react used to automatically factorize the duplicates elements of the GL tree</a> but <strong>it has been decided to remove this feature</strong>: <em>This was actually a complex mechanism (a bit too &quot;magic&quot;), hard to implement and a premature optimization that can have slower performance.</em></p>\n<p>The new gl-react embraces the React paradigm: The new way to express a Graph (and share computation) is <strong>using a <a href=\"https://gl-react-cookbook.surge.sh/api#bus\"><code>&lt;Bus&gt;</code></a></strong>...</p>\n<h3 id=\"the-ref-pattern\">The <code>`()=&gt;ref`</code> pattern</h3>\n<p>The problem we want to solve is to <strong>express a graph with React</strong>, which, at first glance, only allow to represent trees, not graphs!</p>\n<p>The way we can solve this is by using refs and a &quot;ref getter function&quot;:</p>\n<ol>\n<li><strong>a Bus with a ref:</strong> <code>&lt;Bus ref=&quot;myBus&quot;&gt;{content to inject}&lt;/Bus&gt;</code>.</li>\n<li><strong>pass a function that resolves the ref</strong> to pipe Bus into another Node. e.g: <code>()=&gt;this.refs.myBus</code>.</li>\n</ol>\n<p><a href=\"https://gl-react-cookbook.surge.sh/blurmapdyn\">blurmapdyn example <img src=\"/images/2016/12/blurmapdyn.gif\" alt=\"\"></a>\na single ConicalGradient should be used for all blur pass:\n<img src=\"/images/2016/12/blurmapdynschema.png\" alt=\"\"></p>\n<p>There are a few other good examples of ref usages:</p>\n<ul>\n<li><a href=\"https://gl-react-cookbook.surge.sh/blurmapmouse\">blurmapmouse</a></li>\n<li><a href=\"https://gl-react-cookbook.surge.sh/blurimgtitle\">blurimgtitle</a> (same example that was features in 2016 React conf!)</li>\n<li><a href=\"https://gl-react-cookbook.surge.sh/behindasteroids\">behindasteroids</a>, crazy port of a game I made for js13k.</li>\n</ul>\n<blockquote>\n<p>The <code>()=&gt;ref</code> pattern works only if you call the function after component did update (refs are set at this time).</p>\n</blockquote>\n<h2 id=\"the-good-ol-children-function\">The good ol&#39; children function</h2>\n<p>There is another pattern for more specific needs: instead of composing by giving an element, you can also compose by giving a <strong>Function that returns an element</strong>. Why that? Because, it&#39;s a way to nicely give you the redraw function: <code>redraw =&gt; &lt;Video onFrame={redraw} /&gt;</code>:</p>\n<p><a href=\"https://gl-react-cookbook.surge.sh/video?menu=true\">Checkout video example <img src=\"/images/2016/12/videoredraw.png\" alt=\"\"></a></p>\n<blockquote>\n<p>We really just want to redraw if there is a new video frame.</p>\n</blockquote>\n<p>We have merged the 2 patterns into one: if you provide a function, it&#39;s just called with <code>redraw</code>, and the returned value is used as a texture. We have a few cases to detect what kind of texture it is (and also an <a href=\"https://gl-react-cookbook.surge.sh/api#textureloaders\">extensible mechanism</a> used by implementations to load platform specific objects).\n<a href=\"https://github.com/gre/gl-react/blob/a33e6aa685479d588646b20dd62e1e25a64a5a47/packages/gl-react/src/Node.js#L704-L783\">(checkout this if you want to see the code)</a></p>\n<h2 id=\"node-backbuffering--backbuffer-symbol\">Node backbuffering &amp; Backbuffer symbol</h2>\n<p>A new feature allows to inject the previous Node state as a texture. This is called backbuffering. One simple usecase is to implement Motion Blur persistence (like the GIF on top of this article).</p>\n<p>We can also accumulate a state, for instance, to implement Game of Life!</p>\n<p><a href=\"https://gl-react-cookbook.surge.sh/golglider\">Game of life glider example <img src=\"/images/2016/12/gol.gif\" alt=\"\"></a></p>\n<p>And the whole idea of gl-react (and React) is about composition. For instance, doing a rotating effect of that Game of Life is basically just <code>&lt;Rotate&gt; &lt;GameOfLife /&gt; &lt;/Rotate&gt;</code>.</p>\n<p>An interesting part is that you can update the GameOfLife at a rate that is independent from the <strong>Rotate</strong> rendering: just by making GameOfLife a pure component that receives a tick, or implementing shouldComponentUpdate update (you have as many choices as React have to <a href=\"https://facebook.github.io/react/docs/react-api.html#react.purecomponent\">shortcut the rendering</a>).</p>\n<p><a href=\"https://gl-react-cookbook.surge.sh/golrotscu\">golrotscu example<img src=\"/images/2016/12/golrot.gif\" alt=\"\"></a></p>\n<blockquote>\n<p>See the counters that indicate the number of redraw. (the capture preview in the Box only get snapshot each 100ms, but in the real canvas, it runs at 60 FPS)</p>\n</blockquote>\n<p>Finally, please checkout <a href=\"https://gl-react-cookbook.surge.sh/ibex\">ibex example</a> (extracted from another JS13K game! xD).</p>\n<blockquote>\n<p>You can&#39;t leave this article before seeing <a href=\"https://gl-react-cookbook.surge.sh/ibex\">ibex example</a>! I&#39;m serious, this is probably the most accomplished code I ever wrote! xD</p>\n</blockquote>\n<h2 id=\"-under-the-hood-of-surface-and-node-redraw\"><a name=\"under_the_hook_redraw\"></a> under the hood of Surface and Node redraw</h2>\n<p>In order to make redraw efficient, <code>gl-react</code> have 2 phases: the <code>redraw()</code> phase and the <code>flush()</code> phase (reflecting the respective methods available both on <code>Surface</code> and <code>Node</code>). This is a bit like a rendering engine:</p>\n<ul>\n<li><strong><code>redraw()</code> phase</strong> sets a dirty flag to a Node and all its &quot;dependents&quot; (other nodes, buses, surface). <em>redraws happen generally bottom-up to the Surface.</em></li>\n<li><strong><code>flush()</code> phase</strong> draws all nodes that have the redraw flag. <em>draws happens top-down from the Surface.</em></li>\n</ul>\n<p><code>redraw()</code> is directly hooked to React update lifecycle (re-rendering a Node will calls <code>redraw()</code> for you).\nTo make this system efficient, <strong>the flush() is by default asynchronous</strong>, i.e. <code>redraw()</code> means scheduling a new gl draw.\nSurface have a main loop that runs at 60 fps and call <code>flush()</code>. This is very efficient because if Surface does not have the redraw flag, <code>flush()</code> does nothing.</p>\n<blockquote>\n<p>In gl-react inspector, clicking on the redraw count will call <code>redraw()</code> on the node / bus. We can illustrate that only &quot;dependents&quot; get redrawn using the advanced <a href=\"https://gl-react-cookbook.surge.sh/blurimgtitle\">blurimgtitle example</a>:</p>\n</blockquote>\n<p><a href=\"https://gl-react-cookbook.surge.sh/blurimgtitle\">only &quot;dependents&quot; get redrawn <img src=\"/images/2016/12/blurimgtitle-redraw.gif\" alt=\"\"></a></p>\n<p>This redraw/flush phases allow to prevent and skip rendering multiple times a Node. In some cases, we still want to redraw synchronously: with <code>&lt;Node/&gt;</code> <code>sync</code> prop. For instance, in Game of Life, we don&#39;t want to skip an update (the initial update set the initial GoL state, if it was async it might get skipped).</p>\n<h2 id=\"bonus\">Bonus</h2>\n<h3 id=\"flow-types\">Flow types</h3>\n<p>Flow types has been used for more robust code and better user experience. BTW, <a href=\"https://github.com/facebook/flow/pull/2764\">WebGLRenderingContext will soon be released in flow</a>.</p>\n<h3 id=\"atom-highlighting\">Atom highlighting</h3>\n<p>If you are using Atom Editor, you can have JS inlined GLSL syntax highlighted.</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/211411/20623048/0527cce2-b306-11e6-85ee-5020be994c10.png\" alt=\"\"></p>\n<p><em>To configure this:</em></p>\n<ul>\n<li>add <code>language-babel</code> package.</li>\n<li>Configure <code>language-babel</code> to add <code>GLSL:source.glsl</code> in settings &quot;<em>JavaScript Tagged Template Literal Grammar Extensions</em>&quot;.</li>\n<li>(Bonus) Add this CSS to your <em>Atom &gt; Stylesheet</em>:</li>\n</ul>\n<pre><code class=\"language-css\">/* language-babel blocks */\natom-text-editor::shadow .line .ttl-grammar {\n  /* NB: designed for dark theme. can be customized */\n  background-color: rgba(0, 0, 0, 0.3);\n}\natom-text-editor::shadow .line .ttl-grammar:first-child:last-child {\n  display: block; /* force background to take full width only if ttl-grammar is alone in the line. */\n}\n</code></pre>\n<h3 id=\"tests-almost-100-coverage\">Tests: almost 100% coverage!</h3>\n<p>The library is tested directly on the command line, thanks to <a href=\"https://github.com/facebook/jest\">Jest</a> and <a href=\"https://github.com/stackgl/headless-gl\">headless-gl</a> <em>(Big up to <a href=\"https://github.com/mikolalysenko\">mikolalysenko</a> for <a href=\"https://github.com/stackgl/headless-gl\">headless-gl</a>!)</em>.\n<strong>gl-react have 2000 line of tests, involving a lot of gl calls, and readPixels, and it runs... in a few seconds!</strong> <em>(to Jest devs: you are wizards!)</em></p>\n<pre><code>\n PASS  ./all.test.js\n  ✓ renders a red shader (75ms)\n  ✓ renders HelloGL (15ms)\n  ✓ ndarray texture (27ms)\n  ✓ renders a color uniform (18ms)\n  ✓ composes color uniform with LinearCopy (21ms)\n  ✓ no needs to flush if use of sync (24ms)\n  ✓ Node can have a different size and be scaled up (18ms)\n  ✓ Surface can be resized (32ms)\n  ✓ bus uniform code style (17ms)\n  ✓ bus example 1 (17ms)\n  ✓ bus example 2 (18ms)\n  ✓ bus example 3 (17ms)\n  ✓ bus example 4 (22ms)\n  ✓ bus example 5 (14ms)\n  ✓ bus example 6 (24ms)\n  ✓ bus: same texture used in multiple sampler2D is fine (14ms)\n  ✓ a surface can be captured and resized (16ms)\n  ✓ a node can be captured and resized (17ms)\n  ✓ Uniform children redraw=&gt;el function (22ms)\n  ✓ Bus redraw=&gt;el function (16ms)\n  ✓ many Surface updates don&#39;t result of many redraws (18ms)\n  ✓ many Surface flush() don&#39;t result of extra redraws (10ms)\n  ✓ GL Components that implement shouldComponentUpdate shortcut Surface redraws (27ms)\n  ✓ nested GL Component update will re-draw the Surface (24ms)\n  ✓ Node `clear` and discard; (24ms)\n  ✓ Node `backbuffering` (32ms)\n  ✓ Node `backbuffering` in `sync` (36ms)\n  ✓ texture can be null (12ms)\n  ✓ array of textures (22ms)\n  ✓ Node uniformsOptions texture interpolation (17ms)\n  ✓ can be extended with addTextureLoaderClass (70ms)\n  ✓ Surface `preload` prevent to draw anything (59ms)\n  ✓ Surface `preload` that fails will trigger onLoadError (59ms)\n  ✓ renders a shader inline in the Node (15ms)\n  ✓ testing connectSize() feature (17ms)\n  ✓ handle context lost nicely (43ms)\n  ✓ Bus#uniform and Bus#index (25ms)\n  ✓ VisitorLogger + bunch of funky extreme tests (140ms)\n\n-------------------------------|----------|----------|----------|----------|----------------|\nFile                           |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n-------------------------------|----------|----------|----------|----------|----------------|\nAll files                      |    97.85 |     88.8 |    95.96 |    99.35 |                |\n src                           |    97.82 |    88.95 |     95.9 |    99.35 |                |\n  Backbuffer.js                |      100 |      100 |      100 |      100 |                |\n  Bus.js                       |    96.15 |    74.29 |      100 |      100 |                |\n  GLSL.js                      |      100 |       50 |      100 |      100 |                |\n  LinearCopy.js                |      100 |      100 |      100 |      100 |                |\n  NearestCopy.js               |      100 |      100 |      100 |      100 |                |\n  Node.js                      |    97.65 |    92.71 |    97.01 |    99.01 |    214,216,358 |\n  Shaders.js                   |      100 |    76.92 |      100 |      100 |                |\n  Texture2DLoader.js           |      100 |      100 |      100 |      100 |                |\n  TextureLoader.js             |      100 |      100 |      100 |      100 |                |\n  TextureLoaderNDArray.js      |      100 |      100 |      100 |      100 |                |\n  TextureLoaders.js            |      100 |      100 |      100 |      100 |                |\n  Visitor.js                   |      100 |      100 |       75 |      100 |                |\n  VisitorLogger.js             |      100 |    92.59 |      100 |      100 |                |\n  Visitors.js                  |      100 |      100 |      100 |      100 |                |\n  connectSize.js               |      100 |    85.71 |      100 |      100 |                |\n  copyShader.js                |      100 |      100 |      100 |      100 |                |\n  createSurface.js             |    97.09 |    83.61 |    94.55 |    99.32 |            361 |\n  genId.js                     |      100 |      100 |      100 |      100 |                |\n  index.js                     |      100 |      100 |      100 |      100 |                |\n src/helpers                   |      100 |       75 |      100 |      100 |                |\n  disposable.js                |      100 |       50 |      100 |      100 |                |\n  invariantNoDependentsLoop.js |      100 |      100 |      100 |      100 |                |\n-------------------------------|----------|----------|----------|----------|----------------|\nTest Suites: 1 passed, 1 total\nTests:       38 passed, 38 total\nSnapshots:   4 passed, 4 total\nTime:        2.655s\nRan all test suites.\n</code></pre>\n<p>One limitation is that all tests need to be in a single file. <a href=\"https://github.com/facebook/jest/issues/2029\">I created an issue here</a>. I think it&#39;s either an issue in <a href=\"https://github.com/facebook/jest\">Jest</a> or in <a href=\"https://github.com/stackgl/headless-gl\">headless-gl</a>.</p>\n<h2 id=\"tradeoffs-and-remaining-work\">Tradeoffs and remaining work</h2>\n<p>The library tradeoffs are written in <a href=\"https://github.com/gre/gl-react/blob/master/TRADEOFFS.md\">TRADEOFFS.md</a>. We might cover some unexplored direction in a near future and solve some of them.</p>\n<p>v3 is still in development, the main unfinished part is the React Native implementation which is now the main priority of the library.\nIt will probably rely on an awesome initiative: a React Native WebGL implementation started in Exponent by <a href=\"https://github.com/nikki93\">@nikki</a>!</p>\n<p>For more information, see <a href=\"https://github.com/gre/gl-react#v3-alpha-development-in-progress\">v3 alpha: development in progress</a>.</p>\n","data":{"title":"gl-react v3","thumbnail":"/images/2016/12/thumbnail.png","description":"gl-react has been reimplemented from scratch, feedback from previous mistake and overview of new features.","author":"Gaetan","layout":"post","tags":["react","gl-react","webgl"]}},"__N_SSG":true}