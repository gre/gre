{"pageProps":{"id":"2016-09-19-relay-scrolling-connections","year":"2016","month":"09","day":"19","slug":"relay-scrolling-connections","content":"<p><a href=\"https://github.com/facebook/relay\">Relay</a> doesn&#39;t solve for you how you should render your components. Relay is &quot;universal&quot; and doesn&#39;t even assume it will be running in a browser context. It focuses only on providing an abstraction to work with GraphQL â€“ the same way React focuses only on rendering. Each library solves one single problem at a time <em>(and hell, both are complex enough problem to solve already)</em>.</p>\n<p>Because these libraries are very generic, it&#39;s now up to the community to solve the &quot;more specific&quot; parts. Just search on NPM and you can find tons of React libraries already, some might help you to solve part of the problem you want to solve.</p>\n<p>This article demonstrates one use-case: <strong>implementing a component handling the scroll of a list to pull more data</strong> of a GraphQL connection with Relay.</p>\n<!--more-->\n\n<h2 id=\"usage\">Usage</h2>\n<p>In React you should think in term of components that subdivide individual task to solve. To solve scrolling a connection you should just need this:</p>\n<pre><code class=\"language-js\">&lt;InfiniteScrollable relay={relay}&gt;\n  ...\n&lt;/InfiniteScrollable&gt;\n</code></pre>\n<p>Here is a real use-case we have at <a href=\"https://projectseptember.com\">projectseptember</a>.</p>\n<pre><code class=\"language-js\">import React, {\n  Component,\n  PropTypes,\n} from &quot;react&quot;;\nimport Relay from &quot;react-relay&quot;;\nimport List from &quot;material-ui/List&quot;;\nimport Content from &quot;./Content&quot;;\n\nclass ContentStream extends Component {\n  static propTypes = {\n    relay: PropTypes.object.isRequired,\n    user: PropTypes.object,\n  };\n  render () {\n    const { user, relay } = this.props;\n    return (\n      &lt;InfiniteScrollable relay={relay}&gt;\n        &lt;List&gt;\n          {user.stream.edges.map(e =&gt;\n            &lt;Content content={e.node} key={e.cursor} /&gt;\n          )}\n        &lt;/List&gt;\n      &lt;/InfiniteScrollable&gt;\n    );\n  }\n}\n\nexport default Relay.createContainer(ContentStream, {\n  initialVariables: {\n    first: 50,\n  },\n  fragments: {\n    user: () =&gt; Relay.QL`\nfragment on User {\n  stream (first:$first) {\n    edges {\n      cursor\n      node {\n        ${Content.getFragment(&quot;content&quot;)}\n      }\n    }\n  }\n}\n    `\n  }\n});\n</code></pre>\n<p>We don&#39;t have to express how to &quot;pull for more data&quot; in that code. In fact, this is delegated to <code>InfiniteScrollable</code> and we never have to think again about it.</p>\n<h2 id=\"infinitescrollable-implementation\">InfiniteScrollable implementation</h2>\n<p>Relay enforces to implement <a href=\"https://facebook.github.io/relay/docs/graphql-relay-specification.html#content\">a subset of GraphQL spec</a>, like the Connection API. It&#39;s a good thing because we can also rely on this fact, and what we only need is the <code>relay</code> object to implement a generic pull-on-scroll.</p>\n<pre><code class=\"language-js\">import {\n  Component,\n  PropTypes,\n} from &quot;react&quot;;\nimport {findDOMNode} from &quot;react-dom&quot;;\n\nconst regex = /(auto|scroll)/;\n\nconst style = (node, prop) =&gt;\n  getComputedStyle(node, null).getPropertyValue(prop);\n\nconst scroll = (node) =&gt;\n  regex.test(\n    style(node, &quot;overflow&quot;) +\n    style(node, &quot;overflow-y&quot;) +\n    style(node, &quot;overflow-x&quot;));\n\nconst scrollparent = (node) =&gt;\n  !node || node===document.body\n  ? document.body\n  : scroll(node)\n    ? node\n    : scrollparent(node.parentNode);\n\nconst resizeEventOn = n =&gt; n===document.body ? window : n;\n\nexport default class InfiniteScrollable extends Component {\n  static propTypes = {\n    children: PropTypes.any.isRequired,\n    relay: PropTypes.object,\n    style: PropTypes.object,\n    loadPixelsInAdvance: PropTypes.number,\n    relayVariable: PropTypes.string,\n    chunkSize: PropTypes.number,\n    // loadMore could even be generalize, this component works if you provide loadMore instead of relay\n    loadMore: PropTypes.func, // (can) returns a promise\n  };\n  static defaultProps = {\n    loadPixelsInAdvance: 1000,\n    relayVariable: &quot;first&quot;,\n    chunkSize: 50,\n  };\n\n  state = { loading: false };\n\n  resizeBoundOnDom = null;\n\n  componentDidMount () {\n    this.syncScrollBodyListener(this.props);\n    this.checkScroll();\n  }\n\n  componentWillUnmount () {\n    this.unbindResizeEvent();\n  }\n\n  componentDidUpdate () {\n    this.syncScrollBodyListener();\n  }\n\n  unbindResizeEvent () {\n    if (this.resizeBoundOnDom) {\n      this.resizeBoundOnDom.removeEventListener(&quot;scroll&quot;, this.checkScroll);\n      this.resizeBoundOnDom = null;\n    }\n  }\n\n  getScrollParent () {\n    return scrollparent(findDOMNode(this));\n  }\n\n  syncScrollBodyListener = () =&gt; {\n    const resizeBoundOnDom = resizeEventOn(this.getScrollParent());\n    if (resizeBoundOnDom !== this.resizeBoundOnDom) {\n      this.unbindResizeEvent();\n      resizeBoundOnDom.addEventListener(&quot;scroll&quot;, this.checkScroll);\n    }\n  };\n\n  loadMoreUsingRelay = () =&gt; {\n    const { relay, relayVariable, chunkSize } = this.props;\n    return new Promise((resolve, reject) =&gt;\n     relay.setVariables({\n       [relayVariable]: relay.variables[relayVariable] + chunkSize\n     }, readyState =&gt; {\n       if (readyState.error) reject(readyState.error);\n       if (readyState.done) resolve();\n     }));\n  };\n\n  checkScroll = () =&gt; {\n    if (this.state.loading) return;\n    const container = this.getScrollParent();\n    if (!container) return;\n    const { height } = container.getBoundingClientRect();\n    const { scrollHeight, scrollTop } = container;\n    const bottom = scrollTop + height;\n    const { loadPixelsInAdvance } = this.props;\n    const advance = bottom - scrollHeight + loadPixelsInAdvance;\n    if (advance &gt; 0) {\n      this.setState({ loading: true }, () =&gt;\n        Promise.resolve({ advance, bottom, scrollHeight, height, scrollTop, loadPixelsInAdvance })\n        .then(this.props.loadMore || this.loadMoreUsingRelay)\n        .then(\n          () =&gt; this.setState({ loading: false }), // technically could recall checkScroll here. in second callback of setState. fork it, try it, adapt it !\n          e =&gt; (console.warn(e), this.setState({ loading: false }))\n        ));\n    }\n  };\n\n  render () {\n    // you might want to render a spinner?\n    // children might be a function?\n    // etc..\n    // these are some variations we could have from this starting point\n    return this.props.children;\n  }\n}\n</code></pre>\n<p>This is a <strong>possible implementation</strong> of this problem. You might want to add more things based on your needs. For instance you could automatically render a loading spinner... or a million other things! Please try it, fork it, give feedback :)</p>\n<p>It is also possible to implement it as a High Order Component (HOC): <a href=\"https://github.com/facebook/relay/issues/1377\">https://github.com/facebook/relay/issues/1377</a>.</p>\n","data":{"title":"Relay, scrolling connections","description":"implement a component handling the scroll of a list to pull more data of a Graphql Connection with Relay","author":"Gaetan","layout":"post","tags":["react","relay"]}},"__N_SSG":true}