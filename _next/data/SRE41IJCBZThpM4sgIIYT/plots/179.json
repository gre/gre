{"pageProps":{"n":"179","plot":{"n":"179","key":"./179/README.md","rustFile":"179/main.rs","content":"<p>Packing rotated squares in a square. Black fountain pens on Bristol. Interestingly one square didn&#39;t draw due to ink issues. It makes the final art pretty unique!</p>\n<h2 id=\"technical-notes\">Technical notes</h2>\n<p>The algorithm brute-forces with 1 million iterations to find square location, for each iteration it will then search for the biggest square that can fit in the location space. I didn&#39;t even implemented dichotomic search for finding the square scale (it&#39;s a simple loop) but the overall script runs relatively fast in Rustlang (less than 10 seconds).</p>\n<p><strong>main loop</strong></p>\n<pre><code class=\"language-rust\">let mut polys = Vec::new();\nlet mut rng = rng_from_seed(opts.seed);\nfor i in 0..1000000 {\n    let x: f64 = rng.gen_range(bounds.0, bounds.2);\n    let y: f64 = rng.gen_range(bounds.1, bounds.3);\n    let a: f64 = rng.gen_range(0.0, 8.0);\n    if let Some(size) = poly_square_scaling_search(bounds, &amp;polys, x, y, a, min_threshold) {\n        let poly = rotated_square_as_polygon(x, y, size - pad, a);\n        polys.push(poly);\n    }\n    if polys.len() &gt; desired_count {\n        break;\n    }\n}\n</code></pre>\n<p><strong>search</strong></p>\n<pre><code class=\"language-rust\">fn poly_square_scaling_search(\n    boundaries: (f64, f64, f64, f64),\n    polys: &amp;Vec&lt;Polygon&lt;f64&gt;&gt;,\n    x: f64,\n    y: f64,\n    angle: f64,\n    min_threshold: f64\n) -&gt; Option&lt;f64&gt; {\n    let mut size = 0.1;\n    let dsize = 0.1;\n    // TODO dichotomic search could help perf here...\n    loop {\n        let poly = rotated_square_as_polygon(x, y, size, angle);\n        let bounds = poly.bounding_rect().unwrap();\n        let topleft: Point&lt;f64&gt; = bounds.min().into();\n        let bottomright: Point&lt;f64&gt; = topleft + point!(\n            x: bounds.width(),\n            y: bounds.height()\n        );\n        if out_of_boundaries(topleft.x_y(), boundaries) || out_of_boundaries(bottomright.x_y(), boundaries) {\n            break;\n        }\n        if poly_collides_in_polys(polys, &amp;poly) {\n            break;\n        }\n        size += dsize;\n    }\n    if size &lt; min_threshold {\n        return None;\n    }\n    return Some(size);\n}\n</code></pre>\n","data":{"title":"squares packing 001","thumbnail":"/images/plots/179.jpg","description":"Packing rotated squares in a square. Black fountain pens on Bristol.","tags":["shape-packing"]}},"prev":{"n":"178","key":"./178/README.md","rustFile":"178/main.rs","content":"<p>@greweb&#39;s #9 plot loop. The 1920p animation is the main digital art. NFT is available in 6 editions, one per frame. First buyer of each edition can collect related frame to acquire the physical art (selected by buy order. PM @greweb, ship anywhere in the world). Secondary market is digital only. plotted on Bristol paper with black fountain pen. See greweb.me/plots/178</p>\n<p>plotloop, physical, phygital, plot, loop, fountainpen</p>\n<p>Here is &quot;Shell&quot; my 9th <a href=\"https://greweb.me/2021/05/plot-loops\">&quot;plot loop&quot; (see article)</a>. The main digital art is a 1920p video loop of 6 frames available as a <a href=\"https://www.hicetnunc.xyz/objkt/154538\">Tezos hicetnunc NFT</a>. The physical art is 6 frames of A4 size, plotted with a black fountain pen on Bristol paper, and offered when <a href=\"https://www.hicetnunc.xyz/objkt/154538\">buying the NFT</a> (6 editions, assigned in buy order).</p>\n<img src=\"/images/plots/178zoom1.jpg\" width=\"100%\">\n\n<h3 id=\"making-of\">Making of</h3>\n<p>I&#39;ve rebooted one of my plot code (one from 100th&#39;s celebration) and animated it by rotating the center gravity. One of the usual challenge I had to face is the fact many strokes were placed at the same area and had risk to dig into the paper. I&#39;ve used my usual &#39;grid counter&#39; technique but this time pushed it to extreme in that it started making &quot;dots&quot; a bit like in the stippling technique. Dots are aligned to the grid that is used by the algorithm.</p>\n<img src=\"/images/plots/178plotting0.gif\" width=\"100%\">\n\n<p>I then met one of the biggest difficulty of my plot: the fact the paper will start waving a bit with the humidity of the ink. It creates two problem: imprecision and unplanned strokes (lines when the robot move it).</p>\n<p>I countered this problem by reversing my plot and starting from the center:</p>\n<img src=\"/images/plots/178plotting1.gif\" width=\"100%\">\n\n<p>Some of the plots have small remaining imperfection that I judged being part of the art.</p>\n","data":{"title":"Shell (6 frames)","thumbnail":"/images/plots/178.gif","tags":["plotloop"],"objkts":[154538]}},"next":{"n":"180","key":"./180/README.md","rustFile":"180/main.rs","content":"<p>Continuation of <a href=\"/plots/179\">plot#179</a>.</p>\n<p>Second iteration on packing rotated squares in a square. Black fountain pens on a 300g/m paper. It&#39;s interesting how the paper makes the ink having different shade of greys.</p>\n<p>This time, the rotations are less random and aligned on 10 possible angles. (but these are squares so not it repeats)</p>\n<p>There is also two concentric squares drawn each time.</p>\n<h2 id=\"technical-notes\">Technical notes</h2>\n<p>This is also a continuation of the code of <a href=\"/plots/179\">plot#179</a>.</p>\n<p>I did an improvement of the search algorithm using a dichotomic search:</p>\n<p><strong>search</strong></p>\n<pre><code class=\"language-rust\">fn poly_square_scaling_search(\n    boundaries: (f64, f64, f64, f64),\n    polys: &amp;Vec&lt;Polygon&lt;f64&gt;&gt;,\n    x: f64,\n    y: f64,\n    angle: f64,\n    min_scale: f64,\n    max_scale: f64,\n) -&gt; Option&lt;f64&gt; {\n    let overlaps = |size| {\n        let poly = rotated_square_as_polygon(x, y, size, angle);\n        let bounds = poly.bounding_rect().unwrap();\n        let topleft: Point&lt;f64&gt; = bounds.min().into();\n        let bottomright: Point&lt;f64&gt; = topleft + point!(\n            x: bounds.width(),\n            y: bounds.height()\n        );\n        out_of_boundaries(topleft.x_y(), boundaries)\n        || out_of_boundaries(bottomright.x_y(), boundaries)\n        || poly_collides_in_polys(polys, &amp;poly)\n    };\n\n    let mut from = min_scale;\n    let mut to = max_scale;\n    loop {\n        if overlaps(from) {\n            return None;\n        }\n        if to - from &lt; 0.1 {\n            return Some(from);\n        }\n        let middle = (to + from) / 2.0;\n        if overlaps(middle) {\n            to = middle;\n        }\n        else {\n            from = middle;\n        }\n    }\n}\n</code></pre>\n","data":{"title":"squares packing 002","thumbnail":"/images/plots/180.jpg","description":"Second iteration on packing rotated squares in a square. Black fountain pens on 300g/m paper.","tags":["shape-packing"]}}},"__N_SSG":true}