{"pageProps":{"n":"180","plot":{"n":"180","key":"./180/README.md","rustFile":"180/main.rs","content":"<p>Continuation of <a href=\"/plots/179\">plot#179</a>.</p>\n<p>Second iteration on packing rotated squares in a square. Black fountain pens on a 300g/m paper. It&#39;s interesting how the paper makes the ink having different shade of greys.</p>\n<p>This time, the rotations are less random and aligned on 10 possible angles. (but these are squares so not it repeats)</p>\n<p>There is also two concentric squares drawn each time.</p>\n<h2 id=\"technical-notes\">Technical notes</h2>\n<p>This is also a continuation of the code of <a href=\"/plots/179\">plot#179</a>.</p>\n<p>I did an improvement of the search algorithm using a dichotomic search:</p>\n<p><strong>search</strong></p>\n<pre><code class=\"language-rust\">fn poly_square_scaling_search(\n    boundaries: (f64, f64, f64, f64),\n    polys: &amp;Vec&lt;Polygon&lt;f64&gt;&gt;,\n    x: f64,\n    y: f64,\n    angle: f64,\n    min_scale: f64,\n    max_scale: f64,\n) -&gt; Option&lt;f64&gt; {\n    let overlaps = |size| {\n        let poly = rotated_square_as_polygon(x, y, size, angle);\n        let bounds = poly.bounding_rect().unwrap();\n        let topleft: Point&lt;f64&gt; = bounds.min().into();\n        let bottomright: Point&lt;f64&gt; = topleft + point!(\n            x: bounds.width(),\n            y: bounds.height()\n        );\n        out_of_boundaries(topleft.x_y(), boundaries)\n        || out_of_boundaries(bottomright.x_y(), boundaries)\n        || poly_collides_in_polys(polys, &amp;poly)\n    };\n\n    let mut from = min_scale;\n    let mut to = max_scale;\n    loop {\n        if overlaps(from) {\n            return None;\n        }\n        if to - from &lt; 0.1 {\n            return Some(from);\n        }\n        let middle = (to + from) / 2.0;\n        if overlaps(middle) {\n            to = middle;\n        }\n        else {\n            from = middle;\n        }\n    }\n}\n</code></pre>\n","data":{"title":"squares packing 002","thumbnail":"/images/plots/180.jpg","description":"Second iteration on packing rotated squares in a square. Black fountain pens on 300g/m paper.","tags":["shape-packing"]}},"prev":{"n":"179","key":"./179/README.md","rustFile":"179/main.rs","content":"<p>Packing rotated squares in a square. Black fountain pens on Bristol. Interestingly one square didn&#39;t draw due to ink issues. It makes the final art pretty unique!</p>\n<h2 id=\"technical-notes\">Technical notes</h2>\n<p>The algorithm brute-forces with 1 million iterations to find square location, for each iteration it will then search for the biggest square that can fit in the location space. I didn&#39;t even implemented dichotomic search for finding the square scale (it&#39;s a simple loop) but the overall script runs relatively fast in Rustlang (less than 10 seconds).</p>\n<p><strong>main loop</strong></p>\n<pre><code class=\"language-rust\">let mut polys = Vec::new();\nlet mut rng = rng_from_seed(opts.seed);\nfor i in 0..1000000 {\n    let x: f64 = rng.gen_range(bounds.0, bounds.2);\n    let y: f64 = rng.gen_range(bounds.1, bounds.3);\n    let a: f64 = rng.gen_range(0.0, 8.0);\n    if let Some(size) = poly_square_scaling_search(bounds, &amp;polys, x, y, a, min_threshold) {\n        let poly = rotated_square_as_polygon(x, y, size - pad, a);\n        polys.push(poly);\n    }\n    if polys.len() &gt; desired_count {\n        break;\n    }\n}\n</code></pre>\n<p><strong>search</strong></p>\n<pre><code class=\"language-rust\">fn poly_square_scaling_search(\n    boundaries: (f64, f64, f64, f64),\n    polys: &amp;Vec&lt;Polygon&lt;f64&gt;&gt;,\n    x: f64,\n    y: f64,\n    angle: f64,\n    min_threshold: f64\n) -&gt; Option&lt;f64&gt; {\n    let mut size = 0.1;\n    let dsize = 0.1;\n    // TODO dichotomic search could help perf here...\n    loop {\n        let poly = rotated_square_as_polygon(x, y, size, angle);\n        let bounds = poly.bounding_rect().unwrap();\n        let topleft: Point&lt;f64&gt; = bounds.min().into();\n        let bottomright: Point&lt;f64&gt; = topleft + point!(\n            x: bounds.width(),\n            y: bounds.height()\n        );\n        if out_of_boundaries(topleft.x_y(), boundaries) || out_of_boundaries(bottomright.x_y(), boundaries) {\n            break;\n        }\n        if poly_collides_in_polys(polys, &amp;poly) {\n            break;\n        }\n        size += dsize;\n    }\n    if size &lt; min_threshold {\n        return None;\n    }\n    return Some(size);\n}\n</code></pre>\n","data":{"title":"squares packing 001","thumbnail":"/images/plots/179.jpg","description":"Packing rotated squares in a square. Black fountain pens on Bristol.","tags":["shape-packing"]}},"next":{"n":"181","key":"./181/README.md","rustFile":"181/main.rs","content":"<p>Continuation of <a href=\"/plots/180\">plot#180</a>.</p>\n<p>Third iteration on packing iso triangles in a square. two fountain pens on 300g/m paper.</p>\n","data":{"title":"triangle packing","thumbnail":"/images/plots/181.jpg","description":"Third iteration on packing iso triangles in a square. two fountain pens on 300g/m paper.","tags":["shape-packing"]}}},"__N_SSG":true}