<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="author" content="GaÃ«tan Renaudeau"/><meta name="description" content="IBEX is my game made for js13kgames. This article explains how the game has been implemented with GLSL and cellular automata."/><meta name="keywords" content="gamedev, js13k, GLSL"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@greweb"/><meta name="twitter:title" content="Cellular Automata in IBEX"/><meta name="og:title" content="Cellular Automata in IBEX"/><meta name="twitter:description" content="IBEX is my game made for js13kgames. This article explains how the game has been implemented with GLSL and cellular automata."/><meta name="twitter:creator" content="@greweb"/><meta name="og:image" content="http://greweb.me//images/2014/09/ibex-2.png"/><meta name="twitter:image" content="http://greweb.me//images/2014/09/ibex-2.png"/><link rel="image_src" href="http://greweb.me//images/2014/09/ibex-2.png"/><title>@greweb - Cellular Automata in IBEX</title><link href="http://fonts.googleapis.com/css?family=Fredericka+the+Great|Arapey|Roboto:400,700,400italic" rel="stylesheet" type="text/css"/><link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/styles/default.min.css"/><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/highlight.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/javascript.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/cpp.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/glsl.min.js"></script><link rel="stylesheet" href="/style/main.css"/><meta name="next-head-count" content="25"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-682ed58dee9e3e5c50ef.js" defer=""></script><script src="/_next/static/chunks/framework-c93ed74a065331c4bd75.js" defer=""></script><script src="/_next/static/chunks/main-005750ed97c879f2d59b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-092526a60f8cb7d1b3d6.js" defer=""></script><script src="/_next/static/chunks/988-83f401159b53b3fa4628.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-0f67605ef98ac8184736.js" defer=""></script><script src="/_next/static/LosrF7D2QgrTQNT6AA4MI/_buildManifest.js" defer=""></script><script src="/_next/static/LosrF7D2QgrTQNT6AA4MI/_ssgManifest.js" defer=""></script><style id="__jsx-2519965637">.block.jsx-2519965637{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.block.jsx-2519965637 .right.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637{margin-top:10px;}.block.jsx-2519965637 .social.jsx-2519965637 a.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637 img.jsx-2519965637{height:20px;}</style><style id="__jsx-3621368397">.container.jsx-3621368397{min-height:100vh;padding:0 0.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><style id="__jsx-3469673304">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto, Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue, sans-serif;}*{box-sizing:border-box;}a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a:hover,a:active{-webkit-text-decoration:underline;text-decoration:underline;}</style></head><body><div id="__next"><div class="jsx-3621368397 container"><div id="container"><div id="main"><div id="content"><article><header><h1><a href="/">Cellular Automata in IBEX</a></h1><time class="date" dateTime="2014-09-22">2014-09-22</time><span class="tags"><a class="tag">gamedev</a><a class="tag">js13k</a><a class="tag">GLSL</a></span></header><div class="entry-content"><a href="/2014/09/ibex">
  <img src="/images/2014/09/ibex-2.png" alt="" class="thumbnail-right" />
</a>

<p>Last week I finished my <a href="/2014/09/ibex">JS13K game called &quot;IBEX&quot;</a>,
an apocalyptic game where you have to help some wild ibex to escape from the inferno.</p>
<blockquote>
<p>IBEX received the 16th place (out of 129 games) from the <a href="http://js13kgames.com/">js13kgames</a> jury.</p>
</blockquote>
<p>This article is a technical post-mortem about the development of this game in JavaScript / WebGL
and how the world is just <strong>ruled with <a href="http://en.wikipedia.org/wiki/Cellular_automaton">cellular automata</a></strong>
and computed efficiently in a GLSL shader.</p>
<iframe width="50%" height="220" src="//www.youtube.com/embed/nqD2qIy4auU" frameborder="0" allowfullscreen></iframe>

<!--more-->

<h2 id="cellular-automata-ruled-world">Cellular automata ruled world</h2>
<p>A <strong>Cellular Automaton</strong> (plurial Cellular Automata) is an <strong>automaton</strong> <em>(in other words, a state machine)</em>
based on <strong>a grid (an array) of cells</strong>.
It has been discovered years ago and popularized by <a href="http://en.wikipedia.org/wiki/Stephen_Wolfram">Stephen Wolfram</a>
in his interesting book <a href="https://www.wolframscience.com/">A new Kind of Science</a>.</p>
<figure class="thumbnail-right">
  <img src="/images/2014/09/elementary-automaton.png" />
  <figcaption>
    <a href="http://mathworld.wolfram.com/ElementaryCellularAutomaton.html">
      elementary automata.
    </a>
  </figcaption>
</figure>

<p>The simplest possible cellular automaton is the one where, at each generation,
the cell value is determined from the <strong>previous and the 2 adjacent cells</strong> (left and right)
value and where the value can only be <strong>0 or 1</strong> (white or black / true or false).
The way the cell value is determined is through a set of rules.</p>
<blockquote>
<p>In an elementary cellular automaton, there is a total of 8 rules, which means 256 possible cellular automata.</p>
</blockquote>
<h3 id="2d-cellular-automaton">2D cellular automaton</h3>
<figure class="thumbnail-left">
  <img src="/images/2014/09/Gospers_glider_gun.gif" />
  <figcaption>
    <a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">Conway's Game of Life</a>,
    a well known 2D cellular automaton.
  </figcaption>
</figure>

<p>The kind of Cellular Automaton I focused on for my game is <strong>2D cellular automaton</strong>:
At each generation, the cell value is determined from <strong>the previous value and the 8 adjacent cells</strong>
using a finite set of rules.</p>
<p>It is important to understand that these rules are applied in parallel for <strong>all</strong> cells of the world.</p>
<br />

<figure class="thumbnail-right">
  <img src="/images/2014/09/ibex-experiment2.png" />
  <figcaption>
    Early version with 4 elements and simple rules:
    Water falls in Air, Fire grows in Air, Water extinguishes Fire, Earth drops Water + creates Fire
  </figcaption>
</figure>

<p><strong>A 2D cellular automaton rule:</strong></p>
<p><img src="/images/2014/09/ibex-rule-2d.png" alt=""></p>
<p>What I&#39;ve found is that
<strong>the WebGL and the GLSL language works well to implement a cellular automaton</strong>.</p>
<p>The GLSL paradigm is what I like to call <a href="/2013/11/functional-rendering/">functional rendering</a>:
It is, to simplify, a function <strong><code>(x,y) =&gt; (r,g,b,a)</code></strong>:
You fundamentally have to implement this function which <strong>gives a color for a given viewport position</strong>,
and you implement it in a dedicated language which compiles to the GPU.</p>
<p>So we can implement a 2D cellular automaton where each cell is a real (x,y) position in the Texture
and where the (r,g,b,a) color is used to encode your possible cell states, and that&#39;s a lot of possible encoding!</p>
<p>In my game, i&#39;ve chosen to only use the <code>&quot;r&quot;</code> component to implement the cell state.
But imagine all the possibilities of encoding more data per cell (like the velocity, the amount of particle in the cells,...).</p>
<p><strong>Here is a boilerplate of making a Cellular Automaton in GLSL:</strong></p>
<pre><code class="language-glsl">uniform sampler2D state; // the previous world state texture.
uniform vec2 size; // The world size (state texture width and height)

/*
 The decode / encode functions provide an example of encoding
 an integer state in the &quot;r&quot; component over possible 16 values.
 You can definitely implement your own. Also &quot;int&quot; could be something more complex
 */
int decode (vec4 color) {
  return int(floor(.5 + 16.0 * texture2D(state, uv).r));
}
vec4 encode (int value) {
  return vec4(float(r) / 16.0,  0.0, 0.0, 1.0);
}

/*
  get(x,y) is doing a lookup in the state texture to get the (previous) state value of a position.
 */
int get (int x, int y) {
  vec2 uv = (gl_FragCoord.xy + vec2(x, y)) / size;
  return (uv.x &lt; 0.0 || uv.x &gt;= 1.0 || uv.y &lt; 0.0 || uv.y &gt;= 1.0) ? 0 :
    decode(texture2D(state, uv).r);
}

void main () {
  // We get all neighbors cell values from previous state
  int NW = get(-1, 1);
  int NN = get( 0, 1);
  int NE = get( 1, 1);
  int WW = get(-1, 0);
  int CC = get( 0, 0);
  int EE = get( 1, 0);
  int SW = get(-1,-1);
  int SS = get( 0,-1);
  int SE = get( 1,-1);

  int r; // r (for result) is the new cell value.

  ////////////////////////////
  // NOW HERE IS THE COOL PART
  // where you implement all your rules (from the 9 state values)
  // and give a value to r.
  ////////////////////////////

  gl_FragColor = encode(r);
}
</code></pre>
<blockquote>
<p><strong>The complete game rules are all implemented in a GLSL fragment shader:
<a href="https://github.com/gre/js13k-2014/blob/master/src/shaders/logic.frag">logic.frag</a></strong>.
It is important to understand that this fragment shader takes in input
the previous world state (as an uniform texture)
and computes a new state by applying the rules.</p>
</blockquote>
<p>On the JavaScript side, you need to <strong>give an initial state to the texture</strong>
(so you need to also encode data the same way it is done in the shader).
Alternatively you can also make a shader to do this job
<em>(generating the terrain can be intense to do in JavaScript, like it is the case for my game...)</em>.</p>
<p>Also if you want to <strong>query the world from JavaScript</strong>,
<em>(e.g. you want to do physics or collision detection like it is also the case for my game)</em>,
you need to use <code>gl.readPixels</code> and then decode data in JavaScript.</p>
<p>I&#39;ll explain this a bit later in another article.
Let&#39;s now go back to the Cellular Automaton used in IBEX.</p>
<figure>
  <img src="/images/2014/09/ibex-screenshot1.png" />
  <figcaption>
    The different elements gameplay.
  </figcaption>
</figure>

<h3 id="the-elements">The elements</h3>
<p>The game theme was &quot;Four Elements: <strong>Water, Air, Earth, Fire</strong>&quot;, so I&#39;ve used
these 4 elements as primary elements of the cellular automaton.</p>
<p>Each elements also have secondary elements that can be created from each other interactions:
<strong>Source, Volcano, Grass, WindLeft, WindRight</strong>.</p>
<ul>
<li>The <strong>Volcano</strong> is lava growing in the Earth. It creates Fire (when there is Air).</li>
<li>The <strong>Source</strong> is water infiltrating in the Earth. It drops Water (when there is Air).</li>
<li>The <strong>Grass</strong> (or Forest) grows on Earth with Water. It is a speed bonus for ibex but it propagates fire very fast. It also stop the water from flowing.</li>
<li>The <strong>Wind</strong> (left or right wind) is created randomly in Air. It have effects on Water and Fire propagation and also on ibex speed.</li>
</ul>
<p><strong>Some constants...</strong></p>
<pre><code class="language-glsl">// Elements
int A  = 0; // Air
int E  = 1; // Earth
int F  = 2; // Fire
int W  = 3; // Water
int V  = 4; // Volcano
int S  = 5; // Source
int Al = 6; // Air Left (wind)
int Ar = 7; // Air Right (wind)
int G  = 8; // Grass (forest)
</code></pre>
<figure class="thumbnail-right">
  <img src="/images/2014/09/ibex-experiment1.png" />
  <figcaption>
    Fun and experimental result accidentally produced in an early development of the rules.
  </figcaption>
</figure>

<p>To summary, there is 9 possible elements,
and rules are determined from the 9 previous cells:
This makes a LOT of possible rules.
However, the rules involved here remain simple and with just a few rules.</p>
<blockquote>
<p>That is the big thing about cellular automata:
very simple rules produce an incredible variety of results.</p>
</blockquote>
<p>In general, we can classify my game rules into 2 kind of rules:
&quot;interaction&quot; rules and &quot;propagation&quot; rules.
The first kind describes how two (or more!) elements interact each other.
The second kind describes the way an element evolve.
Some rules will also mix them both.</p>
<h3 id="some-simple-propagation-rule">Some simple &quot;propagation rule&quot;</h3>
<p><strong>Earth stays:</strong>
an Earth is returned if there was an Earth before.</p>
<p><img src="/images/2014/09/ibex-rule-earth.png" alt=""></p>
<p><strong>Water falls in Air:</strong>
a Water is created if there was a Water on top.</p>
<p><img src="/images/2014/09/ibex-rule-water1.png" alt=""></p>
<p><strong>Fire grows in Air:</strong>
a Fire is created if there was a Fire on bottom.</p>
<p><img src="/images/2014/09/ibex-rule-fire1.png" alt=""></p>
<p>These rules produce very elementary result, we will now see how we can improve them.</p>
<h3 id="weights-in-rules">Weights in rules</h3>
<p><strong>More powerful rules can also be reached by using weights</strong>:
you can affect a weight for each neighbor cell to give more or less importance to them.</p>
<p>Let&#39;s take a look at a simple example:</p>
<p><img src="/images/2014/09/ibex-rule-gencave-example.png" alt=""></p>
<blockquote>
<p>N.B.: only the &quot;sum&quot; is considered in the rule:
if an element matches, we sum the weight of the cell, otherwise &quot;zero&quot;.</p>
</blockquote>
<p><strong>This example is actually a weighted version of <a href="http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels">the cave rule you can find here</a>:</strong></p>
<figure>
  <figcaption>
    Result of the rule, with (Air or Earth) random pick for each  initial cell value.
  </figcaption>
  <img src="/images/2014/09/ibex-gencaveresult.png" />
</figure>

<h3 id="randomness-in-rules">Randomness in rules</h3>
<p><strong>Combine Randomness and Weights and you get a very powerful simulation.</strong></p>
<p>To avoid seeing some (well known) patterns in the simulation I added some randomness in my rules.
<strong>With randomness, the results are incredibly powerful.</strong></p>
<p>In the following video, notice how cool the fire propagation can result
by varying the propagation randomness factor.</p>
<iframe width="100%" height="420" src="//www.youtube.com/embed/mF-MNHk7u4s" frameborder="0" allowfullscreen="allowfullscreen"></iframe>

<p><strong>The code:</strong></p>
<pre><code class="language-glsl">#define AnyADJ(e) (NW==e||SE==e||NE==e||SW==e||NN==e||SS==e||EE==e||WW==e)
// ^^^^^^^^ MACRO !
if (
  CC == G &amp;&amp;
  RAND &lt; firePropagation &amp;&amp;
  ( AnyADJ(F) || AnyADJ(V) )) {
  r = F;
}
</code></pre>
<h4 id="randomness-in-glsl-">Randomness in GLSL ???</h4>
<p>GLSL is fully stateless and there is <strong>NO WAY</strong> to have a <code>random()</code> function in the GPU.
The trick to do randomness in GLSL is by invoking some math black magic:</p>
<pre><code class="language-glsl">float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
</code></pre>
<p><strong><code>rand</code></strong> is a <a href="http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl">popular</a>
function which returns a pseudo-random value (from 0.0 to 1.0) for a given position.</p>
<p>My personal <strong>black magic</strong> was to define a convenient macro to have a &quot;RAND&quot; word which would get me
a new random number.</p>
<pre><code class="language-glsl">#define RAND (S_=vec2(rand(S_), rand(S_+9.))).x
</code></pre>
<p><code>S_</code> is a seed which is accumulated when calling this <code>RAND</code>.
Because this macro will be inlined in the code, <code>S_</code> must be defined in a local variable
(so in summary, <code>RAND</code> is doing local side-effect).</p>
<pre><code class="language-glsl">vec2 p = gl_FragCoord.xy;
vec2 S_ = p + 0.001 * time;
</code></pre>
<p>Note that <strong>the current pixel position</strong> itself AND <strong>the time</strong> are both used for initializing the seed.
It produces <strong>variable randomness over time and for each pixel</strong>.</p>
<p>Let&#39;s now see other examples where randomness can be very powerful.</p>
<h3 id="the-water-and-fire-interactions">The Water and Fire interactions</h3>
<p><strong>Fire grows and diverges</strong>:</p>
<p><img src="/images/2014/09/ibex-rule-fire2.png" alt=""></p>
<ul>
<li>the &quot;left&quot; and the &quot;right&quot; columns in this rule allows <strong>divergence</strong> in the way fire grows:
Instead of growing straight up, <strong>the fire can also move a bit left or a bit right</strong>.
A lower weight for these side columns make the fire diverge a bit less than a &quot;triangle&quot; propagation.</li>
</ul>
<p>Here is the GLSL code:</p>
<pre><code class="language-glsl">// Fire grow / Fire + Water
if (
  -0.05 * float(NW==W) + -0.40 * float(NN==W) + -0.05 * float(NE==W) + // If water drop...
  -0.50 * float(WW==W) + -0.50 * float(CC==W) + -0.50 * float(EE==W) + // ...or water nearby.
   0.35 * float(SW==F) +  0.90 * float(SS==F) +  0.35 * float(SE==F)   // Fire will move up and expand a bit.
 &gt;= 0.9 - 0.6 * RAND // The sum of matched weights must be enough important, also with some randomness
) {
  r = F;
}
</code></pre>
<p><strong>Water falls, diverges and creates holes</strong>:</p>
<p><img src="/images/2014/09/ibex-rule-water2.png" alt=""></p>
<figure class="thumbnail-right">
  <img src="/images/2014/09/ibex-rain.png"/>
  <figcaption>The rain in IBEX. Notice how Water diverges a bit and creates holes.</figcaption>
</figure>

<ul>
<li>Same as the fire rule, we also have <strong>divergence</strong> in the water.</li>
<li>However there is one more important thing in the rule:
thanks to the <strong>double inequality</strong>,
Water is created only if there is not already too much Water:
it <strong>results of creating Air between the Water particules</strong>.
This make Water elements to be less compact than Fire elements,
the water does not visually &quot;expand&quot; contrary to the fire.</li>
<li>The <strong>randomness</strong> helps a lot here to give <strong>no visible patterns</strong> in this job.</li>
</ul>
<br />

<p>Here are all rules which creates Water:
in this rules you can also notice how <strong>the Water flows on Earth</strong> and how
the <strong>occasional rain</strong> is implemented.</p>
<pre><code class="language-glsl">if (
// Water drop / Water + Fire
  between(
    0.3 * float(NW==W) +  0.9 * float(NN==W) +  0.3 * float(NE==W) +
    0.1 * float(WW==W) + -0.3 * float(CC==F) +  0.1 * float(EE==W) +
                         -0.3 * float(SS==F)  
    ,
    0.9 - 0.6 * RAND,
    1.4 + 0.3 * RAND
  )

  || // Water flow on earth rules

  !prevIsSolid &amp;&amp;
  RAND &lt; 0.98 &amp;&amp;
  ( (WW==W||NW==W) &amp;&amp; SW==E || (EE==W||NE==W) &amp;&amp; SE==E )

  || // Occasional rain
  !prevIsSolid &amp;&amp;
  p.y &gt;= SZ.y-1.0 &amp;&amp;
  rainRelativeTime &lt; 100.0 &amp;&amp;
  between(
    p.x -
    (rand(vec2(SD*0.7 + TI - rainRelativeTime)) * SZ.x) // Rain Start
    ,
    0.0,
    100.0 * rand(vec2(SD + TI - rainRelativeTime)) // Rain Length
  )

  || // Source creates water
  !prevIsSolid &amp;&amp; (
    0.9 * float(NW==S) +  1.0 * float(NN==S) +  0.9 * float(NE==S) +
    0.7 * float(WW==S) +                        0.7 * float(EE==S)
    &gt;= 1.0 - 0.3 * RAND
  )
) {
  r = W;
}
</code></pre>
<p><strong>Source rules</strong></p>
<p>The Source can be created in the Earth by two rules:
Either there is enough water around,
Or there is source on top.</p>
<p>Note the important usage of randomness.</p>
<p><img src="/images/2014/09/ibex-rule-source.png" alt=""></p>
<h3 id="the-grass-propagation-limiting-the-forest-height">The grass propagation, Limiting the forest height</h3>
<p>To finish, the grass needed a special extension to the so-far-used 2D cellular automaton,
the grass cell value is not only being determined from the 8 adjacent cells:</p>
<p>To have more complex structure, <strong>the grass is determined
from the previous cell at position <code>(x, y-N)</code></strong>,
where x and y is the cell position and N is a variable value (random but constant per cell position).
In other word, a forest can grow if the cell at N step under it is not a forest.
This extra rule just adds a constraint on the max height that a forest can have.</p>
<figure>
  <figcaption>A Grass can be created if the (x,y-N) cell is not a Grass.</figcaption>
  <img src="/images/2014/09/ibex-rule-forest-specific.png" />
</figure>


<p>Here is a demo showing the forest propagation randomness:</p>
<iframe width="100%" height="480" src="//www.youtube.com/embed/V_enCKx8XHA" frameborder="0" allowfullscreen="allowfullscreen"></iframe>


<h3 id="drawing-into-the-world">Drawing into the world</h3>
<p><strong>Drawing into the world is also done in GLSL: through uniforms.</strong>
Another alternative way to do that would have be to use <code>gl.readPixels</code> to extract it out in JavaScript,
to write into the Array and inject it back to the shader...
but this solution is not optimal because <code>readPixels</code> is blocking and costy (CPU time).</p>
<pre><code class="language-glsl">uniform bool draw; // if true, we must draw for this tick.
uniform ivec2 drawPosition; // The position of the drawing brush
uniform float drawRadius; // The radius of the drawing brush
uniform int drawObject; // The element to draw


void main (void) {
  ...
  bool prevIsSolid = CC==E||CC==G||CC==V||CC==S;

  if (draw) {
    vec2 pos = floor(p);
    if (distance(pos, vec2(drawPosition)) &lt;= drawRadius) {
    // Inside the brush disc
      if (drawObject == W) {
        // Draw Water
        if (prevIsSolid &amp;&amp; CC!=G) {
          // Source is drawn instead if there was a solid cell
          r = S;
        }
        else if (!prevIsSolid &amp;&amp; mod(pos.x + pos.y, 2.0)==0.0) {
          // We draw Water half of the time because Water is destroyed when surrounded by Water
          r = W;
        }
      }
      else if (drawObject == F) {
        // Draw fire or volcano if solid cell.
        r = prevIsSolid ? V : F;
      }
      else {
        // Draw any other element
        r = drawObject;
      }
    }
  }

  ...
}
</code></pre>
<h2 id="world-generation-is-also-a-cellular-automaton">World generation is also a Cellular automaton!</h2>
<p>The world is generated on the fly when the ibex progress to the right. This is done chunk by chunk.</p>
<blockquote>
<p>More precisely, the world height is 256 pixels and a new part of the world is discovered each 128 pixels â
In other words, the generation is divided into world chunks of <code>(128 x 256)</code> pixels.</p>
</blockquote>
<p>Each world chunk is generated using a cellular automaton (different from the simulation one).</p>
<p>As shown in a previous example,
we can easily generate &quot;cave like maps&quot; from <a href="http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels">this technique</a>.
I&#39;ve added to this a <a href="https://github.com/gre/js13k-2014/blob/master/src/index.js#L842">few improvments</a>:</p>
<ul>
<li>The <a href="https://github.com/gre/js13k-2014/blob/master/src/index.js#L881">initial random conditions</a> ensure
that <strong>the bottom of the world is Earth</strong> and that <strong>the top of the world is Air</strong>.</li>
</ul>
<p><em>(that with gradients of randomness)</em></p>
<ul>
<li><a href="https://github.com/gre/js13k-2014/blob/master/src/index.js#L896-L906">Randomness</a>
has been added to the rules to make the terrain evolving a bit more</li>
</ul>
<p><em>(otherwise it creates stable but small caves)</em>.</p>
<ul>
<li>The number of generation step is set to 26. the randomness of the rules is decreasing through steps to produce stable results.</li>
<li>In an attempt to create <strong>seamless maps</strong>,
the initial random state for x=0 is set to the values of x=127 of the previous world chunk.
<a href="https://github.com/gre/js13k-2014/blob/master/src/index.js#L878">(code here)</a>
It isn&#39;t perfect because you can still notice some edges.</li>
<li>For <strong>more diversity in generated chunks</strong>, here are the parameters that can <a href="https://github.com/gre/js13k-2014/blob/master/src/index.js#L845-L848">randomly vary</a>:<ul>
<li>The <strong>amount of Earth</strong> (can create dense areas VS floating platform areas)</li>
<li>The <strong>chance of Water Source</strong> in the Earth (will creates a lot of forest)</li>
<li>The <strong>chance of Volcano</strong> in the Earth (dangerous world chunk)</li>
</ul>
</li>
</ul>
<p><img src="/images/2014/09/ibex-gen-variety.png" alt=""></p>
<h2 id="more-articles-to-come">More articles to come</h2>
<p>Did you like this article?</p>
<p>I&#39;ll try to write more about these subjects:</p>
<ul>
<li>The <strong>&quot;Pixels paradigm&quot;</strong>, Pixel as first class citizen: How to query and analyze the pixels world. How to do simple bitmap collision detection.</li>
<li>The <strong>game rendering performed in a GLSL shader</strong> and all the graphics details I&#39;ve spent hours on.</li>
<li><strong>things I&#39;ve learned from WebGL</strong>, how to solve the bad approaches I&#39;ve taken,
and how I could have made a much more efficient game.</li>
<li><strong>what could have made this game even more interesting</strong>,
and some ideas that was not reachable in a 2 weeks deadline.</li>
</ul>
</div><footer><div class="jsx-2519965637 block"><img src="http://greweb.me/profile.jpg" width="100" class="jsx-2519965637"/><div class="jsx-2519965637 right"><div class="jsx-2519965637 description">creative coder experimenting with GLSL shaders, Rust, and fountain pens robot plots. infinite noise explorer.</div><div class="jsx-2519965637 social"><a href="https://twitter.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitter.svg" class="jsx-2519965637"/></a><a href="https://instagram.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/instagram.svg" class="jsx-2519965637"/></a><a href="https://github.com/gre" class="jsx-2519965637"><img alt="" src="/icons/github.svg" class="jsx-2519965637"/></a><a href="https://twitch.tv/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitch.svg" class="jsx-2519965637"/></a><a href="https://greweb.itch.io" class="jsx-2519965637"><img alt="" src="/icons/iconmonstr-gamepad-3.svg" class="jsx-2519965637"/></a><a href="https://hic.link/greweb" class="jsx-2519965637"><img alt="" src="/icons/hic.svg" class="jsx-2519965637"/></a></div></div></div></footer></article></div></div></div><script>hljs.highlightAll();</script></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"2014-09-22-ibex-cellular-automata","year":"2014","month":"09","day":"22","slug":"ibex-cellular-automata","content":"\u003ca href=\"/2014/09/ibex\"\u003e\n  \u003cimg src=\"/images/2014/09/ibex-2.png\" alt=\"\" class=\"thumbnail-right\" /\u003e\n\u003c/a\u003e\n\n\u003cp\u003eLast week I finished my \u003ca href=\"/2014/09/ibex\"\u003eJS13K game called \u0026quot;IBEX\u0026quot;\u003c/a\u003e,\nan apocalyptic game where you have to help some wild ibex to escape from the inferno.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIBEX received the 16th place (out of 129 games) from the \u003ca href=\"http://js13kgames.com/\"\u003ejs13kgames\u003c/a\u003e jury.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis article is a technical post-mortem about the development of this game in JavaScript / WebGL\nand how the world is just \u003cstrong\u003eruled with \u003ca href=\"http://en.wikipedia.org/wiki/Cellular_automaton\"\u003ecellular automata\u003c/a\u003e\u003c/strong\u003e\nand computed efficiently in a GLSL shader.\u003c/p\u003e\n\u003ciframe width=\"50%\" height=\"220\" src=\"//www.youtube.com/embed/nqD2qIy4auU\" frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e\n\n\u003c!--more--\u003e\n\n\u003ch2 id=\"cellular-automata-ruled-world\"\u003eCellular automata ruled world\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003eCellular Automaton\u003c/strong\u003e (plurial Cellular Automata) is an \u003cstrong\u003eautomaton\u003c/strong\u003e \u003cem\u003e(in other words, a state machine)\u003c/em\u003e\nbased on \u003cstrong\u003ea grid (an array) of cells\u003c/strong\u003e.\nIt has been discovered years ago and popularized by \u003ca href=\"http://en.wikipedia.org/wiki/Stephen_Wolfram\"\u003eStephen Wolfram\u003c/a\u003e\nin his interesting book \u003ca href=\"https://www.wolframscience.com/\"\u003eA new Kind of Science\u003c/a\u003e.\u003c/p\u003e\n\u003cfigure class=\"thumbnail-right\"\u003e\n  \u003cimg src=\"/images/2014/09/elementary-automaton.png\" /\u003e\n  \u003cfigcaption\u003e\n    \u003ca href=\"http://mathworld.wolfram.com/ElementaryCellularAutomaton.html\"\u003e\n      elementary automata.\n    \u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eThe simplest possible cellular automaton is the one where, at each generation,\nthe cell value is determined from the \u003cstrong\u003eprevious and the 2 adjacent cells\u003c/strong\u003e (left and right)\nvalue and where the value can only be \u003cstrong\u003e0 or 1\u003c/strong\u003e (white or black / true or false).\nThe way the cell value is determined is through a set of rules.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn an elementary cellular automaton, there is a total of 8 rules, which means 256 possible cellular automata.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"2d-cellular-automaton\"\u003e2D cellular automaton\u003c/h3\u003e\n\u003cfigure class=\"thumbnail-left\"\u003e\n  \u003cimg src=\"/images/2014/09/Gospers_glider_gun.gif\" /\u003e\n  \u003cfigcaption\u003e\n    \u003ca href=\"http://en.wikipedia.org/wiki/Conway's_Game_of_Life\"\u003eConway's Game of Life\u003c/a\u003e,\n    a well known 2D cellular automaton.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eThe kind of Cellular Automaton I focused on for my game is \u003cstrong\u003e2D cellular automaton\u003c/strong\u003e:\nAt each generation, the cell value is determined from \u003cstrong\u003ethe previous value and the 8 adjacent cells\u003c/strong\u003e\nusing a finite set of rules.\u003c/p\u003e\n\u003cp\u003eIt is important to understand that these rules are applied in parallel for \u003cstrong\u003eall\u003c/strong\u003e cells of the world.\u003c/p\u003e\n\u003cbr /\u003e\n\n\u003cfigure class=\"thumbnail-right\"\u003e\n  \u003cimg src=\"/images/2014/09/ibex-experiment2.png\" /\u003e\n  \u003cfigcaption\u003e\n    Early version with 4 elements and simple rules:\n    Water falls in Air, Fire grows in Air, Water extinguishes Fire, Earth drops Water + creates Fire\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003e\u003cstrong\u003eA 2D cellular automaton rule:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/09/ibex-rule-2d.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eWhat I\u0026#39;ve found is that\n\u003cstrong\u003ethe WebGL and the GLSL language works well to implement a cellular automaton\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eThe GLSL paradigm is what I like to call \u003ca href=\"/2013/11/functional-rendering/\"\u003efunctional rendering\u003c/a\u003e:\nIt is, to simplify, a function \u003cstrong\u003e\u003ccode\u003e(x,y) =\u0026gt; (r,g,b,a)\u003c/code\u003e\u003c/strong\u003e:\nYou fundamentally have to implement this function which \u003cstrong\u003egives a color for a given viewport position\u003c/strong\u003e,\nand you implement it in a dedicated language which compiles to the GPU.\u003c/p\u003e\n\u003cp\u003eSo we can implement a 2D cellular automaton where each cell is a real (x,y) position in the Texture\nand where the (r,g,b,a) color is used to encode your possible cell states, and that\u0026#39;s a lot of possible encoding!\u003c/p\u003e\n\u003cp\u003eIn my game, i\u0026#39;ve chosen to only use the \u003ccode\u003e\u0026quot;r\u0026quot;\u003c/code\u003e component to implement the cell state.\nBut imagine all the possibilities of encoding more data per cell (like the velocity, the amount of particle in the cells,...).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHere is a boilerplate of making a Cellular Automaton in GLSL:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003euniform sampler2D state; // the previous world state texture.\nuniform vec2 size; // The world size (state texture width and height)\n\n/*\n The decode / encode functions provide an example of encoding\n an integer state in the \u0026quot;r\u0026quot; component over possible 16 values.\n You can definitely implement your own. Also \u0026quot;int\u0026quot; could be something more complex\n */\nint decode (vec4 color) {\n  return int(floor(.5 + 16.0 * texture2D(state, uv).r));\n}\nvec4 encode (int value) {\n  return vec4(float(r) / 16.0,  0.0, 0.0, 1.0);\n}\n\n/*\n  get(x,y) is doing a lookup in the state texture to get the (previous) state value of a position.\n */\nint get (int x, int y) {\n  vec2 uv = (gl_FragCoord.xy + vec2(x, y)) / size;\n  return (uv.x \u0026lt; 0.0 || uv.x \u0026gt;= 1.0 || uv.y \u0026lt; 0.0 || uv.y \u0026gt;= 1.0) ? 0 :\n    decode(texture2D(state, uv).r);\n}\n\nvoid main () {\n  // We get all neighbors cell values from previous state\n  int NW = get(-1, 1);\n  int NN = get( 0, 1);\n  int NE = get( 1, 1);\n  int WW = get(-1, 0);\n  int CC = get( 0, 0);\n  int EE = get( 1, 0);\n  int SW = get(-1,-1);\n  int SS = get( 0,-1);\n  int SE = get( 1,-1);\n\n  int r; // r (for result) is the new cell value.\n\n  ////////////////////////////\n  // NOW HERE IS THE COOL PART\n  // where you implement all your rules (from the 9 state values)\n  // and give a value to r.\n  ////////////////////////////\n\n  gl_FragColor = encode(r);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eThe complete game rules are all implemented in a GLSL fragment shader:\n\u003ca href=\"https://github.com/gre/js13k-2014/blob/master/src/shaders/logic.frag\"\u003elogic.frag\u003c/a\u003e\u003c/strong\u003e.\nIt is important to understand that this fragment shader takes in input\nthe previous world state (as an uniform texture)\nand computes a new state by applying the rules.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOn the JavaScript side, you need to \u003cstrong\u003egive an initial state to the texture\u003c/strong\u003e\n(so you need to also encode data the same way it is done in the shader).\nAlternatively you can also make a shader to do this job\n\u003cem\u003e(generating the terrain can be intense to do in JavaScript, like it is the case for my game...)\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAlso if you want to \u003cstrong\u003equery the world from JavaScript\u003c/strong\u003e,\n\u003cem\u003e(e.g. you want to do physics or collision detection like it is also the case for my game)\u003c/em\u003e,\nyou need to use \u003ccode\u003egl.readPixels\u003c/code\u003e and then decode data in JavaScript.\u003c/p\u003e\n\u003cp\u003eI\u0026#39;ll explain this a bit later in another article.\nLet\u0026#39;s now go back to the Cellular Automaton used in IBEX.\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/images/2014/09/ibex-screenshot1.png\" /\u003e\n  \u003cfigcaption\u003e\n    The different elements gameplay.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003ch3 id=\"the-elements\"\u003eThe elements\u003c/h3\u003e\n\u003cp\u003eThe game theme was \u0026quot;Four Elements: \u003cstrong\u003eWater, Air, Earth, Fire\u003c/strong\u003e\u0026quot;, so I\u0026#39;ve used\nthese 4 elements as primary elements of the cellular automaton.\u003c/p\u003e\n\u003cp\u003eEach elements also have secondary elements that can be created from each other interactions:\n\u003cstrong\u003eSource, Volcano, Grass, WindLeft, WindRight\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003cstrong\u003eVolcano\u003c/strong\u003e is lava growing in the Earth. It creates Fire (when there is Air).\u003c/li\u003e\n\u003cli\u003eThe \u003cstrong\u003eSource\u003c/strong\u003e is water infiltrating in the Earth. It drops Water (when there is Air).\u003c/li\u003e\n\u003cli\u003eThe \u003cstrong\u003eGrass\u003c/strong\u003e (or Forest) grows on Earth with Water. It is a speed bonus for ibex but it propagates fire very fast. It also stop the water from flowing.\u003c/li\u003e\n\u003cli\u003eThe \u003cstrong\u003eWind\u003c/strong\u003e (left or right wind) is created randomly in Air. It have effects on Water and Fire propagation and also on ibex speed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSome constants...\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003e// Elements\nint A  = 0; // Air\nint E  = 1; // Earth\nint F  = 2; // Fire\nint W  = 3; // Water\nint V  = 4; // Volcano\nint S  = 5; // Source\nint Al = 6; // Air Left (wind)\nint Ar = 7; // Air Right (wind)\nint G  = 8; // Grass (forest)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cfigure class=\"thumbnail-right\"\u003e\n  \u003cimg src=\"/images/2014/09/ibex-experiment1.png\" /\u003e\n  \u003cfigcaption\u003e\n    Fun and experimental result accidentally produced in an early development of the rules.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cp\u003eTo summary, there is 9 possible elements,\nand rules are determined from the 9 previous cells:\nThis makes a LOT of possible rules.\nHowever, the rules involved here remain simple and with just a few rules.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThat is the big thing about cellular automata:\nvery simple rules produce an incredible variety of results.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn general, we can classify my game rules into 2 kind of rules:\n\u0026quot;interaction\u0026quot; rules and \u0026quot;propagation\u0026quot; rules.\nThe first kind describes how two (or more!) elements interact each other.\nThe second kind describes the way an element evolve.\nSome rules will also mix them both.\u003c/p\u003e\n\u003ch3 id=\"some-simple-propagation-rule\"\u003eSome simple \u0026quot;propagation rule\u0026quot;\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eEarth stays:\u003c/strong\u003e\nan Earth is returned if there was an Earth before.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/09/ibex-rule-earth.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWater falls in Air:\u003c/strong\u003e\na Water is created if there was a Water on top.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/09/ibex-rule-water1.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFire grows in Air:\u003c/strong\u003e\na Fire is created if there was a Fire on bottom.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/09/ibex-rule-fire1.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eThese rules produce very elementary result, we will now see how we can improve them.\u003c/p\u003e\n\u003ch3 id=\"weights-in-rules\"\u003eWeights in rules\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eMore powerful rules can also be reached by using weights\u003c/strong\u003e:\nyou can affect a weight for each neighbor cell to give more or less importance to them.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s take a look at a simple example:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/09/ibex-rule-gencave-example.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eN.B.: only the \u0026quot;sum\u0026quot; is considered in the rule:\nif an element matches, we sum the weight of the cell, otherwise \u0026quot;zero\u0026quot;.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003eThis example is actually a weighted version of \u003ca href=\"http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels\"\u003ethe cave rule you can find here\u003c/a\u003e:\u003c/strong\u003e\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cfigcaption\u003e\n    Result of the rule, with (Air or Earth) random pick for each  initial cell value.\n  \u003c/figcaption\u003e\n  \u003cimg src=\"/images/2014/09/ibex-gencaveresult.png\" /\u003e\n\u003c/figure\u003e\n\n\u003ch3 id=\"randomness-in-rules\"\u003eRandomness in rules\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCombine Randomness and Weights and you get a very powerful simulation.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo avoid seeing some (well known) patterns in the simulation I added some randomness in my rules.\n\u003cstrong\u003eWith randomness, the results are incredibly powerful.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn the following video, notice how cool the fire propagation can result\nby varying the propagation randomness factor.\u003c/p\u003e\n\u003ciframe width=\"100%\" height=\"420\" src=\"//www.youtube.com/embed/mF-MNHk7u4s\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"\u003e\u003c/iframe\u003e\n\n\u003cp\u003e\u003cstrong\u003eThe code:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003e#define AnyADJ(e) (NW==e||SE==e||NE==e||SW==e||NN==e||SS==e||EE==e||WW==e)\n// ^^^^^^^^ MACRO !\nif (\n  CC == G \u0026amp;\u0026amp;\n  RAND \u0026lt; firePropagation \u0026amp;\u0026amp;\n  ( AnyADJ(F) || AnyADJ(V) )) {\n  r = F;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"randomness-in-glsl-\"\u003eRandomness in GLSL ???\u003c/h4\u003e\n\u003cp\u003eGLSL is fully stateless and there is \u003cstrong\u003eNO WAY\u003c/strong\u003e to have a \u003ccode\u003erandom()\u003c/code\u003e function in the GPU.\nThe trick to do randomness in GLSL is by invoking some math black magic:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003efloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003erand\u003c/code\u003e\u003c/strong\u003e is a \u003ca href=\"http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\"\u003epopular\u003c/a\u003e\nfunction which returns a pseudo-random value (from 0.0 to 1.0) for a given position.\u003c/p\u003e\n\u003cp\u003eMy personal \u003cstrong\u003eblack magic\u003c/strong\u003e was to define a convenient macro to have a \u0026quot;RAND\u0026quot; word which would get me\na new random number.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003e#define RAND (S_=vec2(rand(S_), rand(S_+9.))).x\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eS_\u003c/code\u003e is a seed which is accumulated when calling this \u003ccode\u003eRAND\u003c/code\u003e.\nBecause this macro will be inlined in the code, \u003ccode\u003eS_\u003c/code\u003e must be defined in a local variable\n(so in summary, \u003ccode\u003eRAND\u003c/code\u003e is doing local side-effect).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003evec2 p = gl_FragCoord.xy;\nvec2 S_ = p + 0.001 * time;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that \u003cstrong\u003ethe current pixel position\u003c/strong\u003e itself AND \u003cstrong\u003ethe time\u003c/strong\u003e are both used for initializing the seed.\nIt produces \u003cstrong\u003evariable randomness over time and for each pixel\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s now see other examples where randomness can be very powerful.\u003c/p\u003e\n\u003ch3 id=\"the-water-and-fire-interactions\"\u003eThe Water and Fire interactions\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eFire grows and diverges\u003c/strong\u003e:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/09/ibex-rule-fire2.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe \u0026quot;left\u0026quot; and the \u0026quot;right\u0026quot; columns in this rule allows \u003cstrong\u003edivergence\u003c/strong\u003e in the way fire grows:\nInstead of growing straight up, \u003cstrong\u003ethe fire can also move a bit left or a bit right\u003c/strong\u003e.\nA lower weight for these side columns make the fire diverge a bit less than a \u0026quot;triangle\u0026quot; propagation.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere is the GLSL code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003e// Fire grow / Fire + Water\nif (\n  -0.05 * float(NW==W) + -0.40 * float(NN==W) + -0.05 * float(NE==W) + // If water drop...\n  -0.50 * float(WW==W) + -0.50 * float(CC==W) + -0.50 * float(EE==W) + // ...or water nearby.\n   0.35 * float(SW==F) +  0.90 * float(SS==F) +  0.35 * float(SE==F)   // Fire will move up and expand a bit.\n \u0026gt;= 0.9 - 0.6 * RAND // The sum of matched weights must be enough important, also with some randomness\n) {\n  r = F;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eWater falls, diverges and creates holes\u003c/strong\u003e:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/09/ibex-rule-water2.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cfigure class=\"thumbnail-right\"\u003e\n  \u003cimg src=\"/images/2014/09/ibex-rain.png\"/\u003e\n  \u003cfigcaption\u003eThe rain in IBEX. Notice how Water diverges a bit and creates holes.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003eSame as the fire rule, we also have \u003cstrong\u003edivergence\u003c/strong\u003e in the water.\u003c/li\u003e\n\u003cli\u003eHowever there is one more important thing in the rule:\nthanks to the \u003cstrong\u003edouble inequality\u003c/strong\u003e,\nWater is created only if there is not already too much Water:\nit \u003cstrong\u003eresults of creating Air between the Water particules\u003c/strong\u003e.\nThis make Water elements to be less compact than Fire elements,\nthe water does not visually \u0026quot;expand\u0026quot; contrary to the fire.\u003c/li\u003e\n\u003cli\u003eThe \u003cstrong\u003erandomness\u003c/strong\u003e helps a lot here to give \u003cstrong\u003eno visible patterns\u003c/strong\u003e in this job.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cbr /\u003e\n\n\u003cp\u003eHere are all rules which creates Water:\nin this rules you can also notice how \u003cstrong\u003ethe Water flows on Earth\u003c/strong\u003e and how\nthe \u003cstrong\u003eoccasional rain\u003c/strong\u003e is implemented.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003eif (\n// Water drop / Water + Fire\n  between(\n    0.3 * float(NW==W) +  0.9 * float(NN==W) +  0.3 * float(NE==W) +\n    0.1 * float(WW==W) + -0.3 * float(CC==F) +  0.1 * float(EE==W) +\n                         -0.3 * float(SS==F)  \n    ,\n    0.9 - 0.6 * RAND,\n    1.4 + 0.3 * RAND\n  )\n\n  || // Water flow on earth rules\n\n  !prevIsSolid \u0026amp;\u0026amp;\n  RAND \u0026lt; 0.98 \u0026amp;\u0026amp;\n  ( (WW==W||NW==W) \u0026amp;\u0026amp; SW==E || (EE==W||NE==W) \u0026amp;\u0026amp; SE==E )\n\n  || // Occasional rain\n  !prevIsSolid \u0026amp;\u0026amp;\n  p.y \u0026gt;= SZ.y-1.0 \u0026amp;\u0026amp;\n  rainRelativeTime \u0026lt; 100.0 \u0026amp;\u0026amp;\n  between(\n    p.x -\n    (rand(vec2(SD*0.7 + TI - rainRelativeTime)) * SZ.x) // Rain Start\n    ,\n    0.0,\n    100.0 * rand(vec2(SD + TI - rainRelativeTime)) // Rain Length\n  )\n\n  || // Source creates water\n  !prevIsSolid \u0026amp;\u0026amp; (\n    0.9 * float(NW==S) +  1.0 * float(NN==S) +  0.9 * float(NE==S) +\n    0.7 * float(WW==S) +                        0.7 * float(EE==S)\n    \u0026gt;= 1.0 - 0.3 * RAND\n  )\n) {\n  r = W;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSource rules\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe Source can be created in the Earth by two rules:\nEither there is enough water around,\nOr there is source on top.\u003c/p\u003e\n\u003cp\u003eNote the important usage of randomness.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/09/ibex-rule-source.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch3 id=\"the-grass-propagation-limiting-the-forest-height\"\u003eThe grass propagation, Limiting the forest height\u003c/h3\u003e\n\u003cp\u003eTo finish, the grass needed a special extension to the so-far-used 2D cellular automaton,\nthe grass cell value is not only being determined from the 8 adjacent cells:\u003c/p\u003e\n\u003cp\u003eTo have more complex structure, \u003cstrong\u003ethe grass is determined\nfrom the previous cell at position \u003ccode\u003e(x, y-N)\u003c/code\u003e\u003c/strong\u003e,\nwhere x and y is the cell position and N is a variable value (random but constant per cell position).\nIn other word, a forest can grow if the cell at N step under it is not a forest.\nThis extra rule just adds a constraint on the max height that a forest can have.\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cfigcaption\u003eA Grass can be created if the (x,y-N) cell is not a Grass.\u003c/figcaption\u003e\n  \u003cimg src=\"/images/2014/09/ibex-rule-forest-specific.png\" /\u003e\n\u003c/figure\u003e\n\n\n\u003cp\u003eHere is a demo showing the forest propagation randomness:\u003c/p\u003e\n\u003ciframe width=\"100%\" height=\"480\" src=\"//www.youtube.com/embed/V_enCKx8XHA\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"\u003e\u003c/iframe\u003e\n\n\n\u003ch3 id=\"drawing-into-the-world\"\u003eDrawing into the world\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eDrawing into the world is also done in GLSL: through uniforms.\u003c/strong\u003e\nAnother alternative way to do that would have be to use \u003ccode\u003egl.readPixels\u003c/code\u003e to extract it out in JavaScript,\nto write into the Array and inject it back to the shader...\nbut this solution is not optimal because \u003ccode\u003ereadPixels\u003c/code\u003e is blocking and costy (CPU time).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003euniform bool draw; // if true, we must draw for this tick.\nuniform ivec2 drawPosition; // The position of the drawing brush\nuniform float drawRadius; // The radius of the drawing brush\nuniform int drawObject; // The element to draw\n\n\nvoid main (void) {\n  ...\n  bool prevIsSolid = CC==E||CC==G||CC==V||CC==S;\n\n  if (draw) {\n    vec2 pos = floor(p);\n    if (distance(pos, vec2(drawPosition)) \u0026lt;= drawRadius) {\n    // Inside the brush disc\n      if (drawObject == W) {\n        // Draw Water\n        if (prevIsSolid \u0026amp;\u0026amp; CC!=G) {\n          // Source is drawn instead if there was a solid cell\n          r = S;\n        }\n        else if (!prevIsSolid \u0026amp;\u0026amp; mod(pos.x + pos.y, 2.0)==0.0) {\n          // We draw Water half of the time because Water is destroyed when surrounded by Water\n          r = W;\n        }\n      }\n      else if (drawObject == F) {\n        // Draw fire or volcano if solid cell.\n        r = prevIsSolid ? V : F;\n      }\n      else {\n        // Draw any other element\n        r = drawObject;\n      }\n    }\n  }\n\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"world-generation-is-also-a-cellular-automaton\"\u003eWorld generation is also a Cellular automaton!\u003c/h2\u003e\n\u003cp\u003eThe world is generated on the fly when the ibex progress to the right. This is done chunk by chunk.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMore precisely, the world height is 256 pixels and a new part of the world is discovered each 128 pixels â\nIn other words, the generation is divided into world chunks of \u003ccode\u003e(128 x 256)\u003c/code\u003e pixels.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eEach world chunk is generated using a cellular automaton (different from the simulation one).\u003c/p\u003e\n\u003cp\u003eAs shown in a previous example,\nwe can easily generate \u0026quot;cave like maps\u0026quot; from \u003ca href=\"http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels\"\u003ethis technique\u003c/a\u003e.\nI\u0026#39;ve added to this a \u003ca href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L842\"\u003efew improvments\u003c/a\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003ca href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L881\"\u003einitial random conditions\u003c/a\u003e ensure\nthat \u003cstrong\u003ethe bottom of the world is Earth\u003c/strong\u003e and that \u003cstrong\u003ethe top of the world is Air\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003e(that with gradients of randomness)\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L896-L906\"\u003eRandomness\u003c/a\u003e\nhas been added to the rules to make the terrain evolving a bit more\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003e(otherwise it creates stable but small caves)\u003c/em\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe number of generation step is set to 26. the randomness of the rules is decreasing through steps to produce stable results.\u003c/li\u003e\n\u003cli\u003eIn an attempt to create \u003cstrong\u003eseamless maps\u003c/strong\u003e,\nthe initial random state for x=0 is set to the values of x=127 of the previous world chunk.\n\u003ca href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L878\"\u003e(code here)\u003c/a\u003e\nIt isn\u0026#39;t perfect because you can still notice some edges.\u003c/li\u003e\n\u003cli\u003eFor \u003cstrong\u003emore diversity in generated chunks\u003c/strong\u003e, here are the parameters that can \u003ca href=\"https://github.com/gre/js13k-2014/blob/master/src/index.js#L845-L848\"\u003erandomly vary\u003c/a\u003e:\u003cul\u003e\n\u003cli\u003eThe \u003cstrong\u003eamount of Earth\u003c/strong\u003e (can create dense areas VS floating platform areas)\u003c/li\u003e\n\u003cli\u003eThe \u003cstrong\u003echance of Water Source\u003c/strong\u003e in the Earth (will creates a lot of forest)\u003c/li\u003e\n\u003cli\u003eThe \u003cstrong\u003echance of Volcano\u003c/strong\u003e in the Earth (dangerous world chunk)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/09/ibex-gen-variety.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"more-articles-to-come\"\u003eMore articles to come\u003c/h2\u003e\n\u003cp\u003eDid you like this article?\u003c/p\u003e\n\u003cp\u003eI\u0026#39;ll try to write more about these subjects:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003cstrong\u003e\u0026quot;Pixels paradigm\u0026quot;\u003c/strong\u003e, Pixel as first class citizen: How to query and analyze the pixels world. How to do simple bitmap collision detection.\u003c/li\u003e\n\u003cli\u003eThe \u003cstrong\u003egame rendering performed in a GLSL shader\u003c/strong\u003e and all the graphics details I\u0026#39;ve spent hours on.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ethings I\u0026#39;ve learned from WebGL\u003c/strong\u003e, how to solve the bad approaches I\u0026#39;ve taken,\nand how I could have made a much more efficient game.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ewhat could have made this game even more interesting\u003c/strong\u003e,\nand some ideas that was not reachable in a 2 weeks deadline.\u003c/li\u003e\n\u003c/ul\u003e\n","data":{"title":"Cellular Automata in IBEX","description":"IBEX is my game made for js13kgames. This article explains how the game has been implemented with GLSL and cellular automata.","thumbnail":"/images/2014/09/ibex-2.png","author":"Gaetan","layout":"post","tags":["gamedev","js13k","GLSL"]}},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2014","month":"09","slug":"ibex-cellular-automata"},"buildId":"LosrF7D2QgrTQNT6AA4MI","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>