<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="author" content="Gaëtan Renaudeau"/><meta name="description" content="implement a component handling the scroll of a list to pull more data of a Graphql Connection with Relay"/><meta name="keywords" content="react, relay"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@greweb"/><meta name="twitter:title" content="Relay, scrolling connections"/><meta name="og:title" content="Relay, scrolling connections"/><meta name="twitter:description" content="implement a component handling the scroll of a list to pull more data of a Graphql Connection with Relay"/><meta name="twitter:creator" content="@greweb"/><title>@greweb - Relay, scrolling connections</title><link href="http://fonts.googleapis.com/css?family=Fredericka+the+Great|Arapey|Roboto:400,700,400italic" rel="stylesheet" type="text/css"/><link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/styles/default.min.css"/><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/highlight.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/javascript.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/cpp.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/glsl.min.js"></script><link rel="stylesheet" href="/style/main.css"/><meta name="next-head-count" content="22"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-381dbb3c33243b4920e6.js"></script><script src="/_next/static/chunks/webpack-17597d20e291f72b2439.js" defer=""></script><script src="/_next/static/chunks/framework-bdc1b4e5e48979e16d36.js" defer=""></script><script src="/_next/static/chunks/main-4ac108dd57980e4159e9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c981e0e3ce59f13eb8d0.js" defer=""></script><script src="/_next/static/chunks/5988-738c1ea5f97353b6463e.js" defer=""></script><script src="/_next/static/chunks/2242-4500be184fa490ea9cf2.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-18d367ef37e4735025ef.js" defer=""></script><script src="/_next/static/ae_DOku0NQLvrO85ufv4R/_buildManifest.js" defer=""></script><script src="/_next/static/ae_DOku0NQLvrO85ufv4R/_ssgManifest.js" defer=""></script><style id="__jsx-2519965637">.block.jsx-2519965637{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.block.jsx-2519965637 .right.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637{margin-top:10px;}.block.jsx-2519965637 .social.jsx-2519965637 a.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637 img.jsx-2519965637{height:20px;}</style><style id="__jsx-3621368397">.container.jsx-3621368397{min-height:100vh;padding:0 0.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><style id="__jsx-3469673304">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto, Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue, sans-serif;}*{box-sizing:border-box;}a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a:hover,a:active{-webkit-text-decoration:underline;text-decoration:underline;}</style></head><body><div id="__next"><div class="jsx-3621368397 container"><div id="container"><div id="main"><div id="content"><article><header><h1><a href="/">Relay, scrolling connections</a></h1><time class="date" dateTime="2016-09-19">2016-09-19</time><span class="tags"><a class="tag">react</a><a class="tag">relay</a></span></header><div class="entry-content"><p><a href="https://github.com/facebook/relay">Relay</a> doesn&#39;t solve for you how you should render your components. Relay is &quot;universal&quot; and doesn&#39;t even assume it will be running in a browser context. It focuses only on providing an abstraction to work with GraphQL – the same way React focuses only on rendering. Each library solves one single problem at a time <em>(and hell, both are complex enough problem to solve already)</em>.</p>
<p>Because these libraries are very generic, it&#39;s now up to the community to solve the &quot;more specific&quot; parts. Just search on NPM and you can find tons of React libraries already, some might help you to solve part of the problem you want to solve.</p>
<p>This article demonstrates one use-case: <strong>implementing a component handling the scroll of a list to pull more data</strong> of a GraphQL connection with Relay.</p>
<!--more-->

<h2 id="usage">Usage</h2>
<p>In React you should think in term of components that subdivide individual task to solve. To solve scrolling a connection you should just need this:</p>
<pre><code class="language-js">&lt;InfiniteScrollable relay={relay}&gt;
  ...
&lt;/InfiniteScrollable&gt;
</code></pre>
<p>Here is a real use-case we have at <a href="https://projectseptember.com">projectseptember</a>.</p>
<pre><code class="language-js">import React, {
  Component,
  PropTypes,
} from &quot;react&quot;;
import Relay from &quot;react-relay&quot;;
import List from &quot;material-ui/List&quot;;
import Content from &quot;./Content&quot;;

class ContentStream extends Component {
  static propTypes = {
    relay: PropTypes.object.isRequired,
    user: PropTypes.object,
  };
  render () {
    const { user, relay } = this.props;
    return (
      &lt;InfiniteScrollable relay={relay}&gt;
        &lt;List&gt;
          {user.stream.edges.map(e =&gt;
            &lt;Content content={e.node} key={e.cursor} /&gt;
          )}
        &lt;/List&gt;
      &lt;/InfiniteScrollable&gt;
    );
  }
}

export default Relay.createContainer(ContentStream, {
  initialVariables: {
    first: 50,
  },
  fragments: {
    user: () =&gt; Relay.QL`
fragment on User {
  stream (first:$first) {
    edges {
      cursor
      node {
        ${Content.getFragment(&quot;content&quot;)}
      }
    }
  }
}
    `
  }
});
</code></pre>
<p>We don&#39;t have to express how to &quot;pull for more data&quot; in that code. In fact, this is delegated to <code>InfiniteScrollable</code> and we never have to think again about it.</p>
<h2 id="infinitescrollable-implementation">InfiniteScrollable implementation</h2>
<p>Relay enforces to implement <a href="https://facebook.github.io/relay/docs/graphql-relay-specification.html#content">a subset of GraphQL spec</a>, like the Connection API. It&#39;s a good thing because we can also rely on this fact, and what we only need is the <code>relay</code> object to implement a generic pull-on-scroll.</p>
<pre><code class="language-js">import {
  Component,
  PropTypes,
} from &quot;react&quot;;
import {findDOMNode} from &quot;react-dom&quot;;

const regex = /(auto|scroll)/;

const style = (node, prop) =&gt;
  getComputedStyle(node, null).getPropertyValue(prop);

const scroll = (node) =&gt;
  regex.test(
    style(node, &quot;overflow&quot;) +
    style(node, &quot;overflow-y&quot;) +
    style(node, &quot;overflow-x&quot;));

const scrollparent = (node) =&gt;
  !node || node===document.body
  ? document.body
  : scroll(node)
    ? node
    : scrollparent(node.parentNode);

const resizeEventOn = n =&gt; n===document.body ? window : n;

export default class InfiniteScrollable extends Component {
  static propTypes = {
    children: PropTypes.any.isRequired,
    relay: PropTypes.object,
    style: PropTypes.object,
    loadPixelsInAdvance: PropTypes.number,
    relayVariable: PropTypes.string,
    chunkSize: PropTypes.number,
    // loadMore could even be generalize, this component works if you provide loadMore instead of relay
    loadMore: PropTypes.func, // (can) returns a promise
  };
  static defaultProps = {
    loadPixelsInAdvance: 1000,
    relayVariable: &quot;first&quot;,
    chunkSize: 50,
  };

  state = { loading: false };

  resizeBoundOnDom = null;

  componentDidMount () {
    this.syncScrollBodyListener(this.props);
    this.checkScroll();
  }

  componentWillUnmount () {
    this.unbindResizeEvent();
  }

  componentDidUpdate () {
    this.syncScrollBodyListener();
  }

  unbindResizeEvent () {
    if (this.resizeBoundOnDom) {
      this.resizeBoundOnDom.removeEventListener(&quot;scroll&quot;, this.checkScroll);
      this.resizeBoundOnDom = null;
    }
  }

  getScrollParent () {
    return scrollparent(findDOMNode(this));
  }

  syncScrollBodyListener = () =&gt; {
    const resizeBoundOnDom = resizeEventOn(this.getScrollParent());
    if (resizeBoundOnDom !== this.resizeBoundOnDom) {
      this.unbindResizeEvent();
      resizeBoundOnDom.addEventListener(&quot;scroll&quot;, this.checkScroll);
    }
  };

  loadMoreUsingRelay = () =&gt; {
    const { relay, relayVariable, chunkSize } = this.props;
    return new Promise((resolve, reject) =&gt;
     relay.setVariables({
       [relayVariable]: relay.variables[relayVariable] + chunkSize
     }, readyState =&gt; {
       if (readyState.error) reject(readyState.error);
       if (readyState.done) resolve();
     }));
  };

  checkScroll = () =&gt; {
    if (this.state.loading) return;
    const container = this.getScrollParent();
    if (!container) return;
    const { height } = container.getBoundingClientRect();
    const { scrollHeight, scrollTop } = container;
    const bottom = scrollTop + height;
    const { loadPixelsInAdvance } = this.props;
    const advance = bottom - scrollHeight + loadPixelsInAdvance;
    if (advance &gt; 0) {
      this.setState({ loading: true }, () =&gt;
        Promise.resolve({ advance, bottom, scrollHeight, height, scrollTop, loadPixelsInAdvance })
        .then(this.props.loadMore || this.loadMoreUsingRelay)
        .then(
          () =&gt; this.setState({ loading: false }), // technically could recall checkScroll here. in second callback of setState. fork it, try it, adapt it !
          e =&gt; (console.warn(e), this.setState({ loading: false }))
        ));
    }
  };

  render () {
    // you might want to render a spinner?
    // children might be a function?
    // etc..
    // these are some variations we could have from this starting point
    return this.props.children;
  }
}
</code></pre>
<p>This is a <strong>possible implementation</strong> of this problem. You might want to add more things based on your needs. For instance you could automatically render a loading spinner... or a million other things! Please try it, fork it, give feedback :)</p>
<p>It is also possible to implement it as a High Order Component (HOC): <a href="https://github.com/facebook/relay/issues/1377">https://github.com/facebook/relay/issues/1377</a>.</p>
</div><footer><div class="jsx-2519965637 block"><img src="http://greweb.me/logo.svg" width="100" class="jsx-2519965637"/><div class="jsx-2519965637 right"><div class="jsx-2519965637 description">generative artist who uses code to make art, explores the frontier of abstract art with algorithms pushing forward to more realistic scenery. Explore physical art via &#x27;Plotting&#x27;, which consist of drawing with fountain pens on robot. I don&#x27;t do prints, I do plots: Every physical outcome is truly unique!</div><div class="jsx-2519965637 social"><a href="https://twitter.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitter.svg" class="jsx-2519965637"/></a><a href="https://instagram.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/instagram.svg" class="jsx-2519965637"/></a><a href="https://twitch.tv/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitch.svg" class="jsx-2519965637"/></a><a href="https://github.com/gre" class="jsx-2519965637"><img alt="" src="/icons/github.svg" class="jsx-2519965637"/></a><a href="https://opensea.io/greweb?tab=created" class="jsx-2519965637"><img alt="" src="/icons/eth.svg" class="jsx-2519965637"/></a><a href="https://objkt.com/profile/tz1cgQAQfECg5bPASYTMyJ9QJQjSUi8rfL67" class="jsx-2519965637"><img alt="" src="/icons/tz.svg" class="jsx-2519965637"/></a><a href="https://fxhash.xyz/u/greweb" class="jsx-2519965637"><img alt="" src="/icons/tz.svg" class="jsx-2519965637"/></a><a href="https://greweb.itch.io" class="jsx-2519965637"><img alt="" src="/icons/iconmonstr-gamepad-3.svg" class="jsx-2519965637"/></a></div></div></div></footer></article></div></div></div><script>hljs.highlightAll();</script></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"2016-09-19-relay-scrolling-connections","year":"2016","month":"09","day":"19","slug":"relay-scrolling-connections","content":"\u003cp\u003e\u003ca href=\"https://github.com/facebook/relay\"\u003eRelay\u003c/a\u003e doesn\u0026#39;t solve for you how you should render your components. Relay is \u0026quot;universal\u0026quot; and doesn\u0026#39;t even assume it will be running in a browser context. It focuses only on providing an abstraction to work with GraphQL – the same way React focuses only on rendering. Each library solves one single problem at a time \u003cem\u003e(and hell, both are complex enough problem to solve already)\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eBecause these libraries are very generic, it\u0026#39;s now up to the community to solve the \u0026quot;more specific\u0026quot; parts. Just search on NPM and you can find tons of React libraries already, some might help you to solve part of the problem you want to solve.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates one use-case: \u003cstrong\u003eimplementing a component handling the scroll of a list to pull more data\u003c/strong\u003e of a GraphQL connection with Relay.\u003c/p\u003e\n\u003c!--more--\u003e\n\n\u003ch2 id=\"usage\"\u003eUsage\u003c/h2\u003e\n\u003cp\u003eIn React you should think in term of components that subdivide individual task to solve. To solve scrolling a connection you should just need this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\u0026lt;InfiniteScrollable relay={relay}\u0026gt;\n  ...\n\u0026lt;/InfiniteScrollable\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is a real use-case we have at \u003ca href=\"https://projectseptember.com\"\u003eprojectseptember\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport React, {\n  Component,\n  PropTypes,\n} from \u0026quot;react\u0026quot;;\nimport Relay from \u0026quot;react-relay\u0026quot;;\nimport List from \u0026quot;material-ui/List\u0026quot;;\nimport Content from \u0026quot;./Content\u0026quot;;\n\nclass ContentStream extends Component {\n  static propTypes = {\n    relay: PropTypes.object.isRequired,\n    user: PropTypes.object,\n  };\n  render () {\n    const { user, relay } = this.props;\n    return (\n      \u0026lt;InfiniteScrollable relay={relay}\u0026gt;\n        \u0026lt;List\u0026gt;\n          {user.stream.edges.map(e =\u0026gt;\n            \u0026lt;Content content={e.node} key={e.cursor} /\u0026gt;\n          )}\n        \u0026lt;/List\u0026gt;\n      \u0026lt;/InfiniteScrollable\u0026gt;\n    );\n  }\n}\n\nexport default Relay.createContainer(ContentStream, {\n  initialVariables: {\n    first: 50,\n  },\n  fragments: {\n    user: () =\u0026gt; Relay.QL`\nfragment on User {\n  stream (first:$first) {\n    edges {\n      cursor\n      node {\n        ${Content.getFragment(\u0026quot;content\u0026quot;)}\n      }\n    }\n  }\n}\n    `\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe don\u0026#39;t have to express how to \u0026quot;pull for more data\u0026quot; in that code. In fact, this is delegated to \u003ccode\u003eInfiniteScrollable\u003c/code\u003e and we never have to think again about it.\u003c/p\u003e\n\u003ch2 id=\"infinitescrollable-implementation\"\u003eInfiniteScrollable implementation\u003c/h2\u003e\n\u003cp\u003eRelay enforces to implement \u003ca href=\"https://facebook.github.io/relay/docs/graphql-relay-specification.html#content\"\u003ea subset of GraphQL spec\u003c/a\u003e, like the Connection API. It\u0026#39;s a good thing because we can also rely on this fact, and what we only need is the \u003ccode\u003erelay\u003c/code\u003e object to implement a generic pull-on-scroll.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport {\n  Component,\n  PropTypes,\n} from \u0026quot;react\u0026quot;;\nimport {findDOMNode} from \u0026quot;react-dom\u0026quot;;\n\nconst regex = /(auto|scroll)/;\n\nconst style = (node, prop) =\u0026gt;\n  getComputedStyle(node, null).getPropertyValue(prop);\n\nconst scroll = (node) =\u0026gt;\n  regex.test(\n    style(node, \u0026quot;overflow\u0026quot;) +\n    style(node, \u0026quot;overflow-y\u0026quot;) +\n    style(node, \u0026quot;overflow-x\u0026quot;));\n\nconst scrollparent = (node) =\u0026gt;\n  !node || node===document.body\n  ? document.body\n  : scroll(node)\n    ? node\n    : scrollparent(node.parentNode);\n\nconst resizeEventOn = n =\u0026gt; n===document.body ? window : n;\n\nexport default class InfiniteScrollable extends Component {\n  static propTypes = {\n    children: PropTypes.any.isRequired,\n    relay: PropTypes.object,\n    style: PropTypes.object,\n    loadPixelsInAdvance: PropTypes.number,\n    relayVariable: PropTypes.string,\n    chunkSize: PropTypes.number,\n    // loadMore could even be generalize, this component works if you provide loadMore instead of relay\n    loadMore: PropTypes.func, // (can) returns a promise\n  };\n  static defaultProps = {\n    loadPixelsInAdvance: 1000,\n    relayVariable: \u0026quot;first\u0026quot;,\n    chunkSize: 50,\n  };\n\n  state = { loading: false };\n\n  resizeBoundOnDom = null;\n\n  componentDidMount () {\n    this.syncScrollBodyListener(this.props);\n    this.checkScroll();\n  }\n\n  componentWillUnmount () {\n    this.unbindResizeEvent();\n  }\n\n  componentDidUpdate () {\n    this.syncScrollBodyListener();\n  }\n\n  unbindResizeEvent () {\n    if (this.resizeBoundOnDom) {\n      this.resizeBoundOnDom.removeEventListener(\u0026quot;scroll\u0026quot;, this.checkScroll);\n      this.resizeBoundOnDom = null;\n    }\n  }\n\n  getScrollParent () {\n    return scrollparent(findDOMNode(this));\n  }\n\n  syncScrollBodyListener = () =\u0026gt; {\n    const resizeBoundOnDom = resizeEventOn(this.getScrollParent());\n    if (resizeBoundOnDom !== this.resizeBoundOnDom) {\n      this.unbindResizeEvent();\n      resizeBoundOnDom.addEventListener(\u0026quot;scroll\u0026quot;, this.checkScroll);\n    }\n  };\n\n  loadMoreUsingRelay = () =\u0026gt; {\n    const { relay, relayVariable, chunkSize } = this.props;\n    return new Promise((resolve, reject) =\u0026gt;\n     relay.setVariables({\n       [relayVariable]: relay.variables[relayVariable] + chunkSize\n     }, readyState =\u0026gt; {\n       if (readyState.error) reject(readyState.error);\n       if (readyState.done) resolve();\n     }));\n  };\n\n  checkScroll = () =\u0026gt; {\n    if (this.state.loading) return;\n    const container = this.getScrollParent();\n    if (!container) return;\n    const { height } = container.getBoundingClientRect();\n    const { scrollHeight, scrollTop } = container;\n    const bottom = scrollTop + height;\n    const { loadPixelsInAdvance } = this.props;\n    const advance = bottom - scrollHeight + loadPixelsInAdvance;\n    if (advance \u0026gt; 0) {\n      this.setState({ loading: true }, () =\u0026gt;\n        Promise.resolve({ advance, bottom, scrollHeight, height, scrollTop, loadPixelsInAdvance })\n        .then(this.props.loadMore || this.loadMoreUsingRelay)\n        .then(\n          () =\u0026gt; this.setState({ loading: false }), // technically could recall checkScroll here. in second callback of setState. fork it, try it, adapt it !\n          e =\u0026gt; (console.warn(e), this.setState({ loading: false }))\n        ));\n    }\n  };\n\n  render () {\n    // you might want to render a spinner?\n    // children might be a function?\n    // etc..\n    // these are some variations we could have from this starting point\n    return this.props.children;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is a \u003cstrong\u003epossible implementation\u003c/strong\u003e of this problem. You might want to add more things based on your needs. For instance you could automatically render a loading spinner... or a million other things! Please try it, fork it, give feedback :)\u003c/p\u003e\n\u003cp\u003eIt is also possible to implement it as a High Order Component (HOC): \u003ca href=\"https://github.com/facebook/relay/issues/1377\"\u003ehttps://github.com/facebook/relay/issues/1377\u003c/a\u003e.\u003c/p\u003e\n","data":{"title":"Relay, scrolling connections","description":"implement a component handling the scroll of a list to pull more data of a Graphql Connection with Relay","author":"Gaetan","layout":"post","tags":["react","relay"]}},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2016","month":"09","slug":"relay-scrolling-connections"},"buildId":"ae_DOku0NQLvrO85ufv4R","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>