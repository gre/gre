<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="author" content="Gaëtan Renaudeau"/><meta name="description"/><meta name="keywords" content="react, webgl, gl-react"/><meta name="HandheldFriendly" content="True"/><meta name="MobileOptimized" content="320"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@greweb"/><meta name="twitter:title" content="Universal GL Effects for Web and Native"/><meta name="og:title" content="Universal GL Effects for Web and Native"/><meta name="twitter:creator" content="@greweb"/><title>@greweb - Universal GL Effects for Web and Native</title><link href="http://fonts.googleapis.com/css?family=Fredericka+the+Great|Arapey|Roboto:400,700,400italic" rel="stylesheet" type="text/css"/><link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/styles/default.min.css"/><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/highlight.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/javascript.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/cpp.min.js"></script><script src="https://unpkg.com/@highlightjs/cdn-assets@10.7.2/languages/glsl.min.js"></script><link rel="stylesheet" href="/style/main.css"/><meta name="next-head-count" content="21"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-381dbb3c33243b4920e6.js"></script><script src="/_next/static/chunks/webpack-17597d20e291f72b2439.js" defer=""></script><script src="/_next/static/chunks/framework-bdc1b4e5e48979e16d36.js" defer=""></script><script src="/_next/static/chunks/main-4ac108dd57980e4159e9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c981e0e3ce59f13eb8d0.js" defer=""></script><script src="/_next/static/chunks/5988-738c1ea5f97353b6463e.js" defer=""></script><script src="/_next/static/chunks/2242-e809902ac2d7a524d02b.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bslug%5D-18d367ef37e4735025ef.js" defer=""></script><script src="/_next/static/cuvbQJX_pqnWZ0CfuPVsq/_buildManifest.js" defer=""></script><script src="/_next/static/cuvbQJX_pqnWZ0CfuPVsq/_ssgManifest.js" defer=""></script><style id="__jsx-2519965637">.block.jsx-2519965637{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.block.jsx-2519965637 .right.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637{margin-top:10px;}.block.jsx-2519965637 .social.jsx-2519965637 a.jsx-2519965637{padding:10px;}.block.jsx-2519965637 .social.jsx-2519965637 img.jsx-2519965637{height:20px;}</style><style id="__jsx-3621368397">.container.jsx-3621368397{min-height:100vh;padding:0 0.5rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><style id="__jsx-3469673304">html,body{padding:0;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto, Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue, sans-serif;}*{box-sizing:border-box;}a{color:inherit;-webkit-text-decoration:none;text-decoration:none;}a:hover,a:active{-webkit-text-decoration:underline;text-decoration:underline;}</style></head><body><div id="__next"><div class="jsx-3621368397 container"><div id="container"><div id="main"><div id="content"><article><header><h1><a href="/">Universal GL Effects for Web and Native</a></h1><time class="date" dateTime="2016-06-19">2016-06-19</time><span class="tags"><a class="tag">react</a><a class="tag">webgl</a><a class="tag">gl-react</a></span></header><div class="entry-content"><script src="http://localhost:35729/"></script>

<p>Last February, I talked about <a href="https://github.com/projectseptemberinc/gl-react"><code>gl-react</code></a> at React.js conference.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Xnqy_zkBAew" frameborder="0" allowfullscreen></iframe>

<blockquote>
<p><a href="https://www.youtube.com/playlist?list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY">Checkout talks</a> of this conference if you are interested by React subject.
I want to thanks the incredible team behind React.js for the awesome conference and giving me the opportunity to come to San Francisco.</p>
</blockquote>
<p><em>This article will cover some more technical detail of <a href="https://github.com/projectseptemberinc/gl-react"><code>gl-react</code></a> that wasn&#39;t explained in the talk.</em></p>
<blockquote>
<p><em>Also, I&#39;ll try to not go TOO MUCH into technical detail neither, because it would take weeks to cover gl-react features and its implementation tricks!</em></p>
</blockquote>
<!--more-->

<hr>
<p>We have developed, at <a href="http://projectseptember.com">Project September</a>, an <a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9">universal</a> OpenGL wrapper for React called <a href="https://github.com/projectseptemberinc/gl-react"><code>gl-react</code></a> working with 2 other libraries: <a href="https://github.com/projectseptemberinc/gl-react-dom"><code>gl-react-dom</code></a> (wraps WebGL) and <a href="https://github.com/projectseptemberinc/gl-react-native"><code>gl-react-native</code></a> (wraps OpenGL).</p>
<p>The library allows to define <strong>advanced effects</strong> on top of <strong>images, videos, texts or any other VDOM Content</strong> (like UI Views).</p>
<p>Checkout the following <code>gl-react</code> demos running with the <strong>same codebase across iOS, Android and the Web !!!</strong></p>
<h2 id="advancedeffects"><a href="http://projectseptemberinc.github.io/gl-react-dom/Examples/AdvancedEffects/"><strong>AdvancedEffects</strong></a></h2>
<p><video src="/images/2016/03/advanced-effects.mp4" width="100%" controls autoplay muted loop></video></p>
<h2 id="githubcomgregl-react-image-effects"><a href="https://github.com/gre/gl-react-image-effects"><strong>github.com/gre/gl-react-image-effects</strong></a></h2>
<p><a href="http://greweb.me/gl-react-image-effects/" style="text-align:center"><video loop autoplay controls src="/images/2016/03/image-effects-ios.mp4" width="33%"></video><img src="/images/2016/03/image-effects-web.png" style="width: 33%;" /><img src="/images/2016/03/image-effects-android.png" style="width: 33%" /></a></p>
<h2 id="adopting-react-paradigm">Adopting React paradigm</h2>
<p>There are a few important points in React that <code>gl-react</code> follows to fit its paradigm.</p>
<h3 id="1-react-is-about-composition">1. React is about composition</h3>
<p><strong>Components are first class citizen</strong> in React.
A Component provides isolation by exposing a simple API (props) and encapsulates internal lifecycle.
One particular prop is the <code>children</code> prop that, by convention, allows to pass-in children components to a component.</p>
<p>For instance, we can define a component called <code>Container</code> taking a <code>children</code> prop and use it like this in JSX:</p>
<pre><code class="language-html">&lt;Container&gt;
  &lt;div&gt;Hello&lt;/div&gt;
&lt;/Container&gt;
</code></pre>
<blockquote>
<p>Note that &quot;JSX&quot; is a syntax sugar that, in this example, transpiles to something like:</p>
</blockquote>
<pre><code class="language-js">React.createElement(Container, {
  children: React.createElement(&quot;div&quot;, { children: &quot;Hello&quot; }),
});
</code></pre>
<blockquote>
<p>There are really no magic here: JSX just tends to be more convenient to write and, most of the time, it would be more annoying to use createElement API.</p>
</blockquote>
<h3 id="2-react-is-about-functional-programming">2. React is about Functional Programming...</h3>
<p>This might not be that obvious at a first glance but React is about FP. In React paradigm, you describe the full rendering of your application <em>(in &quot;Virtual DOM&quot;)</em> for a given application state, and you do this every time something changes in the application. So fundamentally, you just have to implement that <strong>function from State to Virtual DOM</strong> to implement your web application – <em>which is close to render loops in game dev (but it&#39;s another subject^^).</em></p>
<h3 id="and-reconciliation-on-top-of-an-underlying-imperative-api">...and reconciliation on top of an underlying Imperative API</h3>
<p>In React, you don&#39;t go mutating the DOM but you just RENDER EVERYTHING everytime! It&#39;s very simple to reason about, it removes lot of inconsistency bugs and React is here to optimize this with <a href="https://facebook.github.io/react/docs/reconciliation.html">an algorithm called &quot;reconciliation&quot;</a> (or diff/patch).</p>
<blockquote>
<p>Efficiently translating an high level immutable API into a lower level mutable API is the hard work that solves React on top of DOM, as well does gl-react on top of OpenGL.</p>
</blockquote>
<p>The <a href="https://facebook.github.io/react/docs/reconciliation.html">reconciliation</a> work done by React is a complex optimization problem that have trade-offs. This work is all about <strong>translating a imperative API (the DOM) to a functional API (React VDOM)</strong>.</p>
<p>In <a href="https://github.com/projectseptemberinc/gl-react"><code>gl-react</code></a>, we have the <strong>exact same problem to resolve</strong>: <a href="https://github.com/projectseptemberinc/gl-react"><code>gl-react</code></a> exposes a <strong>functional API</strong> and implements for you the complex work over the mutable, stateful and low-level API that is OpenGL / WebGL.</p>
<h3 id="3-react-is-a-thin-wrapper">3. React is a thin wrapper</h3>
<p>One other key point of React is that it&#39;s a <strong>thin wrapper on top of DOM</strong>. React focus on translating <strong>imperative API =&gt; functional API</strong> with the most minimal &amp; generic way, meaning that React won&#39;t hide you what the DOM elements are about <em>(same as React Native tries just to be on top of real Native components)</em>.</p>
<p>We tried to follow this principle as well when wrapping (Open/Web)<strong>GL</strong>:
we want to hide the complex and imperative part of GL but just expose the great functional parts that are the <strong>Fragment Shaders</strong> and the <strong>Framebuffers</strong>.</p>
<h2 id="hardcoding-the-vertex-part-of-the-pipeline">Hardcoding the vertex part of the pipeline</h2>
<p><img src="/images/2016/03/hardcoded_pipeline.png" alt=""></p>
<p><code>gl-react</code> <em>currently</em> focuses on what can be achieved with <strong>composing Fragment Shaders</strong> with multiple <strong>Framebuffers</strong> that define a <strong>graph of effects</strong>. The Vertex Data &amp; Vertex Shaders are currently hardcoded.</p>
<blockquote>
<p><code>gl-react</code> might unlock this hardcoded part in the future – <a href="https://twitter.com/snikhilesh/status/707730742994833408">some recent experiments by @snikhilesh</a> shows a promising overview of what can possibility by done there!</p>
</blockquote>
<p>But for now, we focus on the huge challenge to implement <code>gl-react</code> seamlessly between the Web, Android and iOS implementations and to work on performance <em>(e.g of the content rasterization performance)</em>.</p>
<blockquote class="twitter-tweet" data-lang="fr"><p lang="en" dir="ltr">Notes from <a href="https://twitter.com/greweb">@greweb</a>&#39;s <a href="https://twitter.com/hashtag/reactjsconf?src=hash">#reactjsconf</a> talk Universal GL Effects for Web and Native <a href="https://t.co/JnIOjAQCOK">pic.twitter.com/JnIOjAQCOK</a></p>&mdash; Michael Chan (@chantastic) <a href="https://twitter.com/chantastic/status/702213897520943104">23 février 2016</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="functional-rendering"><em>&quot;Functional Rendering&quot;</em></h2>
<p>We mentioned earlier that <code>gl-react</code> focuses on one important piece of OpenGL that is the fragment shader.</p>
<p><strong>A Fragment Shader is a function</strong> that independently colors each pixel:</p>
<p><img src="/images/2016/03/functional_rendering.png" alt=""></p>
<p><a href="http://greweb.me/2013/11/functional-rendering/">Watch this talk</a> for more detail on what I call <em>Functional Rendering</em>.</p>
<blockquote>
<p>Fragment shaders use a language called GLSL for <em>OpenGL Shading Language</em>. GLSL is a DSL dedicated to the functional rendering paradigm with &quot;graphics-ready&quot; types (vectors, matrix, sampler2D for textures) and built-in functions (like mix, distance, pow, cos,...).
Checkout the <a href="https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">specification</a>.</p>
</blockquote>
<h2 id="gluing-with-react">GL<em>uing</em> with React</h2>
<p><strong><a href="https://github.com/projectseptemberinc/gl-react"><code>gl-react</code></a> is a core library</strong>: it doesn&#39;t provide any built-in effects, users have to provide the shaders to render. Hopefully it&#39;s fairly simple to implement basic effects <em>(like saturation, contrast, brightness, inverse, hue,...)</em> in GLSL language and <em>Functional Rendering</em> paradigm.</p>
<h3 id="hellogl-example">HelloGL example</h3>
<p>Let&#39;s create HelloGL, our first fragment shader:</p>
<pre><code class="language-glsl">precision highp float;
varying vec2 uv; // This variable vary in all pixel position (normalized from vec2(0.0,0.0) to vec2(1.0,1.0))
void main () { // This function is called FOR EACH PIXEL
  gl_FragColor = vec4(uv.x, uv.y, 0.5, 1.0); // red vary over X, green vary over Y, blue is 50%, alpha is 100%.
}
</code></pre>
<p>It&#39;s a <em>Point to Color</em> function:</p>
<ul>
<li><strong>the input comes from <code>varying vec2 uv</code></strong></li>
<li><strong>the output is set in <code>vec4</code> <code>gl_FragColor</code></strong> – <code>main()</code> is called for each pixel with a different <code>uv</code> (it&#39;s <em>varying</em> like the keyword indicates).</li>
</ul>
<p>so this HelloGL glsl code basically do:</p>
<pre><code class="language-js">[ x, y ] =&gt; [ x, y, 0.5, 1.0 ]
</code></pre>
<ul>
<li>The <strong>RED</strong> component increases with the X position of the pixel.</li>
<li>The <strong>GREEN</strong> component increases with the Y position of the pixel.</li>
</ul>
<p>which renders this nice 2D gradient:</p>
<img width="160" src="/images/2016/03/hellogl.png" />

<p>Now, in <code>gl-react</code>, we can define &quot;HelloGL&quot; as a GL Component with:</p>
<pre><code class="language-js">import GL from &quot;gl-react&quot;;
import React from &quot;react&quot;;
const shaders = GL.Shaders.create({
  helloGL: {
    frag: `
precision highp float;
varying vec2 uv;
void main () {
  gl_FragColor = vec4(uv.x, uv.y, 0.5, 1.0);
}`,
  },
});
const HelloGL = GL.createComponent(() =&gt; &lt;GL.Node shader={shaders.helloGL} /&gt;);
</code></pre>
<p>and then use it:</p>
<pre><code class="language-html">&lt;HelloGL /&gt;
</code></pre>
<h3 id="coloreddisc-example">ColoredDisc example</h3>
<p>GL Component can have props in parameter that can be passed-in as GLSL Uniforms.</p>
<img class="thumbnail-right" src="/images/2016/03/colored-disc.png" />

<pre><code class="language-html">&lt;ColoredDisc fromColor=&quot;{[&quot; 1, 0, 1 ]} toColor=&quot;{[&quot; 1, 1, 0 ]} /&gt;
</code></pre>
<br />

<pre><code class="language-js">import GL from &quot;gl-react&quot;;
import React from &quot;react&quot;;
const shaders = GL.Shaders.create({
  ColoredDisc: {
    frag: `
precision highp float;
varying vec2 uv;
uniform vec3 fromColor;
uniform vec3 toColor;
void main () {
  float d = 2.0 * distance(uv, vec2(0.5));
  gl_FragColor = mix(
    vec4(mix(fromColor, toColor, d), 1.0),
    vec4(0.0),
    step(1.0, d)
  );
}`,
  },
});
const ColoredDisc = GL.createComponent(({ fromColor, toColor }) =&gt; (
  &lt;GL.Node shader={shaders.ColoredDisc} uniforms={{ fromColor, toColor }} /&gt;
));
</code></pre>
<h3 id="diamondcrop-example">DiamondCrop example</h3>
<img class="thumbnail-right" src="/images/2016/03/diamond-crop.png" />

<pre><code class="language-html">&lt;DiamondCrop&gt; http://i.imgur.com/rkiglmm.jpg &lt;/DiamondCrop&gt;
</code></pre>
<br />

<pre><code class="language-js">import GL from &quot;gl-react&quot;;
import React from &quot;react&quot;;
const shaders = GL.Shaders.create({
  DiamondCrop: {
    frag: `
precision highp float;
varying vec2 uv;
uniform sampler2D t;
void main () {
  gl_FragColor = mix(
    texture2D(t, uv),
    vec4(0.0),
    step(0.5, abs(uv.x - 0.5) + abs(uv.y - 0.5))
  );
}`,
  },
});
const DiamondCrop = GL.createComponent(({ children: t }) =&gt; (
  &lt;GL.Node shader={shaders.DiamondCrop} uniforms={{ t }} /&gt;
));
</code></pre>
<h2 id="any-content-can-be-used">Any content can be used</h2>
<p>Let&#39;s say we define a Blur effect with <code>gl-react</code>.</p>
<pre><code class="language-js">const Blur = GL.createComponent(({ children, factor }) =&gt; ...);
</code></pre>
<p>Here, we have just defined a GL Component <code>Blur</code> that accept a children as a props.
It also accept a factor prop to define the intensity of that blur.
Therefore we can use <code>Blur</code> using JSX in many ways.</p>
<blockquote>
<p><strong>N.B.</strong> If you want such a Blur, checkout <a href="https://github.com/gre/gl-react-blur">gl-react-blur</a>.</p>
</blockquote>
<p>First of all you can blur an image:</p>
<img class="thumbnail-right" src="/images/2016/03/blur_image.png" />

<pre><code class="language-html">&lt;Blur factor=&quot;{2}&quot;&gt; http://i.imgur.com/rkiglmm.jpg &lt;/Blur&gt;
</code></pre>
<br />

<p>But really anything can be passed-in here. For instance, a video</p>
<pre><code class="language-html">&lt;Blur factor=&quot;{0.6}&quot;&gt;
  &lt;video src=&quot;/video.mpg&quot; /&gt;
&lt;/Blur&gt;
</code></pre>
<p>or a canvas:</p>
<pre><code class="language-html">&lt;Blur factor=&quot;{0.7}&quot;&gt;
  &lt;canvas ... /&gt;
&lt;/Blur&gt;
</code></pre>
<p>and where that canvas can be provided by a library, like react-canvas:</p>
<pre><code class="language-html">&lt;Blur factor=&quot;{0.9}&quot;&gt;
  &lt;ReactCanvas.Surface ...&gt;
    &lt;ReactCanvas.Text ...&gt;Hello World&lt;/ReactCanvas.Text&gt;
  &lt;/ReactCanvas.Surface&gt;
&lt;/Blur&gt;
</code></pre>
<p>In React Native context, we even have support for ANY view.
It can be a simple Text:</p>
<img class="thumbnail-right" src="/images/2016/03/text_blur.png" />

<pre><code class="language-html">&lt;Blur factor=&quot;{0.9}&quot;&gt;
  &lt;Text ...&gt;Hello World&lt;/Text&gt;
&lt;/Blur&gt;
</code></pre>
<br />

<p>or even a native component like a Switch component</p>
<img class="thumbnail-right" src="/images/2016/03/switch_blur.png" />

<pre><code class="language-html">&lt;Blur factor=&quot;{0.9}&quot;&gt;
  &lt;Switch ... /&gt;
&lt;/Blur&gt;
</code></pre>
<br />

<p>The way this is implemented is platform specific. For instance the Web implementation will just render the content into WebGL (so it works with images, videos, canvas, but not any arbitrary DOM element due to Web Security limitations). However, the Native implementation will be able to <strong>rasterize</strong> (almost) any view and inject it as a texture (consider this feature experimental at the moment).</p>
<h2 id="compose-compose-compose">Compose, Compose, Compose</h2>
<p>But <strong>composition</strong> is probably the MOST important part of this:
You can also pass a GL Component in uniforms!</p>
<p>So all possible composition of previous examples will just work</p>
<img class="thumbnail-right" src="/images/2016/03/diamond_hellogl.png" />

<pre><code class="language-html">&lt;DiamondCrop&gt;
  &lt;HelloGL /&gt;
&lt;/DiamondCrop&gt;
</code></pre>
<br />

<img class="thumbnail-right" src="/images/2016/03/blur_diamond_hellogl.png" />

<pre><code class="language-html">&lt;Blur factor=&quot;{4}&quot;&gt;
  &lt;DiamondCrop&gt;
    &lt;HelloGL /&gt;
  &lt;/DiamondCrop&gt;
&lt;/Blur&gt;
</code></pre>
<br />

<p><code>gl-react</code> makes composition efficient using OpenGL Framebuffers.
This approach encourages you to write small and generic shaders (instead of one monolithic and specific shader).</p>
<blockquote>
<p>For this composition to work correctly, the components must be created with <code>GL.createComponent</code> or directly be <code>GL.Node</code> components.</p>
</blockquote>
<h2 id=""><Surface/></h2>
<p>To actually get a rendering with gl-react, <strong>you need to put your GL Component stack into a <Surface/> element</strong>.</p>
<p>For instance, to render HelloGL on a 200x200 canvas:</p>
<img class="thumbnail-right" src="/images/2016/03/hellogl.png" />

<pre><code class="language-html">&lt;Surface width=&quot;{200}&quot; height=&quot;{200}&quot;&gt;
  &lt;HelloGL /&gt;
&lt;/Surface&gt;
</code></pre>
<pre><code class="language-js">import { Surface } from &quot;gl-react-dom&quot;;
import { Surface } from &quot;gl-react-native&quot;;
</code></pre>
<br/>

<p><strong>Surface</strong> implements the rendering in the contextual platform:</p>
<ul>
<li>If you import <code>{Surface}</code> from <code>gl-react-dom</code> it will renders into a <strong>WebGL Canvas</strong> <strong><em>(web)</em></strong>, (it&#39;s backed by great <a href="http://stack.gl/">stack.gl</a> libs)</li>
<li>If, instead, it comes from <code>gl-react-native</code>, <strong>GLKView</strong> <strong><em>(iOS)</em></strong> / <strong>GLSurfaceView</strong> <strong><em>(Android)</em></strong> will be used.</li>
</ul>
<p><strong>Surface</strong> have roughly the same API across these 2 libraries but some props might exist only on one of the implementations.</p>
<h2 id="dynamic-blur-image-title-example">Dynamic Blur Image Title Example</h2>
<p>My talk featured an advanced use-case that we had in my startup, <a href="http://projectseptember.com/">Project September</a>. We are developing a social mobile app with React Native and our designer wanted to have title over image with Blur effects around the title text.</p>
<p><a href="http://greweb.me/reactjsconf2016/"><img src="/images/2016/03/hellosf.jpg" alt=""></a></p>
<p><a href="http://greweb.me/reactjsconf2016/">Open the demo</a> – <a href="https://github.com/gre/reactjsconf2016">See the code</a></p>
<p>This effect is just exposed as a simple <strong>ImageTitle</strong> React component that we can use like this:</p>
<pre><code class="language-html">&lt;ImageTitle text=&quot;Hello San Francisco ☻&quot;&gt;
  http://i.imgur.com/XXXXXX.jpg
&lt;/ImageTitle&gt;
</code></pre>
<p>The point of <code>gl-react</code> is we all know how to compose React components, just put it in a <strong>Surface</strong> and you obtain a title over image effect like on the image above.</p>
<blockquote>
<p>we can even run the effect over a video</p>
</blockquote>
<pre><code class="language-html">&lt;ImageTitle text=&quot;Hello San Francisco ☻&quot;&gt;
  &lt;video src=&quot;video.mp4&quot; /&gt;
&lt;/ImageTitle&gt;
</code></pre>
<p>which is what <a href="http://greweb.me/reactjsconf2016/">our demo</a> does if you enable the video mode.</p>
<h2 id="under-the-hood">Under the hood</h2>
<blockquote>
<p>This section will show <strong>ImageTitle</strong> implementation that will illustrate <code>gl-react</code> optimization techniques.</p>
</blockquote>
<p>Let&#39;s take a quick look at our ImageTitle shader. That shader renders the title text on top of the blurred image. The title text color is chosen based on the average pixel color (if the content is dark, we use a white title, otherwise a black one).</p>
<p>I won&#39;t enter more into implementation detail, but here is the fragment shader:</p>
<p><img src="/images/2016/03/image-title-shader.png" alt=""></p>
<p>Now, let&#39;s focus on our JavaScript gl-react code.</p>
<p><strong>ImageTitle</strong> is a GL Component that takes a few props (basically <code>title</code> and <code>children</code>) and delegates the job using a few other Components: <strong>Title</strong> that renders the text, <strong>TitleBlurMap</strong> that generates a blur map of that text, <strong>BlurV</strong> that apply the blurmap to generate a variable blur over the content (image/video), <strong>AveragePixels</strong> that generate one pixel out of the content.
These 4 elements are then composed into our final ImageTitle shader.</p>
<p><img src="/images/2016/03/image-title-imports.png" alt="">
<img src="/images/2016/03/image-title-component.png" alt=""></p>
<p>Composition is the key point here, we have defined our component with simple code, delegated and composed part of the effect with other component.</p>
<p>And each sub-component is doing more work. For instance <strong>TitleBlurMap</strong> is itself another GL component, which uses composes a component <strong>Blur</strong> and apply a threshold to generate a black and white blur map:</p>
<p><img src="/images/2016/03/titleblurmap_impl.png" alt="">
<img src="/images/2016/03/titleblurmap_node_detail.png" alt=""></p>
<p>And so on! <strong>Blur</strong> is itself another GL component!
And like <strong>BlurV</strong>, it is implementing a 4-pass blur, so it will pipe 4 times a Blur1D component:</p>
<p><img src="/images/2016/03/blurstack.png" alt=""></p>
<p><strong>Blur</strong> simply recursively composes Blur1D:
<img src="/images/2016/03/blur_impl.png" alt=""></p>
<blockquote>
<p>Have I lost you? Don&#39;t worry, we will show in a few section what the big picture scene looks like.</p>
</blockquote>
<h3 id="-how-gl-react-transform-your-surface-and-effects-stack"><a name="dedup"></a> How gl-react transform your Surface and effects stack</h3>
<p>We have just overviewed how deep a GL effects stack can be: going down into each individual component that itself use many other components can ends a with a pretty big tree. That&#39;s true for any React application actually, but React is still performant.</p>
<p><strong>However, we have a fundamental difference between classical React DOM and <code>gl-react</code>: a GL effects stack is just a single Canvas element at the end.</strong></p>
<blockquote>
<p>When you write a tree of GL Components, each component don&#39;t get append into the DOM like would do a stack of Virtual DOM elements. Instead we need at the end to render the full Virtual GL tree into one single <code>&lt;canvas/&gt;</code>.</p>
</blockquote>
<p>Therefore, we don&#39;t treat GL Component the same way React does. <code>gl-react</code> will do internal work to <strong>unfold user&#39;s Virtual GL tree</strong> and convert it into a <strong>&quot;scene&quot; object that contains everything a renderer need to know</strong>. This object is passed as a <code>&quot;data&quot;</code> props to the underlying implementation (that we call internally <strong><em>GLCanvas</em></strong>).</p>
<p>If we inspect with React Dev Tools what our <code>&lt;Surface/&gt;</code> actually gets render into you will see something like this:</p>
<p><img src="/images/2016/03/resolved_rendering.png" alt=""></p>
<p>Actually, the <code>Surface</code> get rendered into a... <code>&lt;div/&gt;</code> <strong>(1)</strong>. We need to do this because we need to not only render the Canvas <strong>(3)</strong> but we also need to render any possible content that was passed-in the stack that would need to get rasterized (in web context, it can be a <strong>video</strong> or another <strong>canvas</strong>). In our case, it&#39;s the <code>&lt;Title/&gt;</code> component, that is backed with <strong>react-canvas</strong> to draw Text using a Canvas (the only simple way to get texts in WebGL). So this is why we need <strong>(2)</strong>, that is a container for the content, that container is moved behind the canvas and is made invisible (unless you enable some hidden secret props! <a href="https://projectseptemberinc.gitbooks.io/gl-react/content/docs/api/Surface.html">read more about advanced props of Surface in the documentation</a>).</p>
<h3 id="how-gl-react-optimizes-the-effects-stack--factorize-computation">How gl-react optimizes the effects stack &amp; factorize computation</h3>
<p>The previous complex example, if implemented naïvely, ends up with this big tree:</p>
<p><strong>1. Before factorization optimization:</strong> <em>(naïve implementation)</em>
<img src="/images/2016/03/reactjs2016_greweb.036.jpeg" alt=""></p>
<p>It contains a lot of duplicates: the Title rendering appears 6 times
and the &quot;Text Blurring 4-Blur stack&quot; also appears 5 times.</p>
<p>This is just computing the same thing multiple times where we should be able to compute it once...</p>
<p>To solve this, we will just use the VDOM <strong>referential transparency</strong>: if 2 VDOM element have the same reference, we can assume it renders the same thing so we can just dedupe to share and render it once.</p>
<blockquote>
<p>This is one of our biggest innovation in <code>gl-react</code>: when you give a stack of effects in Surface, we will dedupe the tree.</p>
</blockquote>
<p>At the end of this process our example results of:</p>
<p><strong>2. After factorization optimization:</strong>
<img src="/images/2016/03/reactjs2016_greweb.041.jpeg" alt=""></p>
<p>We have moved from 38 to 13 nodes and reduce the render speed from 20ms to 4ms.</p>
<h3 id="conclusion">Conclusion</h3>
<p>If you would implement a stack of effects using the imperative OpenGL API, you would obviously write an ordered sequence of effects to do and that would naturally share the computations in temporary buffers for best performance.</p>
<p><strong>The important job of gl-react is to allow you to write descriptive code without losing this advantage of using temporary pixel buffers and keeping a thin layer on top of the underlying OpenGL.</strong></p>
<h2 id="other-side-projects">Other side projects</h2>
<h3 id="gl-react-inspector">gl-react-inspector</h3>
<p>One of the most appreciated part in my talk is the Inspector we specially develop for gl-react.</p>
<p>I initially developed it because I wanted to have charts to show people what gl-react graph looks like and without having to go Inkscape and handcrafting them...
But it ended up behind a useful tool to actually develop with, because you can see what&#39;s going on underneath (at each node step, and what the texture looks at intermediary steps). It also helps seeing investigating on performance.</p>
<p>Our big future challenge with this is to make it work as a standalone devtools (I imagine it could be part of the React devtools, if we could have plugins there).
and to make it work with React Native too.</p>
<h3 id="gl-react-dom-static-container">gl-react-dom-static-container</h3>
<p><a href="https://github.com/gre/gl-react-dom-static-container">https://github.com/gre/gl-react-dom-static-container</a></p>
<h3 id="some-universal-gl-effects">Some universal GL effects</h3>
<ul>
<li><a href="https://github.com/gre/gl-react-blur">gl-react-blur</a></li>
<li><a href="https://github.com/gre/gl-react-negative">gl-react-negative</a></li>
<li><a href="https://github.com/gre/gl-react-constrast-saturation-brightness">gl-react-constrast-saturation-brightness</a></li>
<li><a href="https://github.com/gre/gl-react-hue-rotate">gl-react-hue-rotate</a></li>
<li><a href="https://github.com/gre/gl-react-color-matrix">gl-react-color-matrix</a></li>
</ul>
<h3 id="gl-react-image">gl-react-image</h3>
<p><a href="https://github.com/gre/gl-react-image">gl-react-image</a> is a component that solves preserving ratios of your images (because stretching is the default behavior).</p>
<h2 id="we-need-your-help">We need your help!</h2>
<h3 id="what-should-come-soon">What should come soon</h3>
<ul>
<li>caching framebuffers from one frame to another: allow different interesting things: cache part of the graph (e.g to allow to cache a static intensive part of the graph), cache part of a rendering with <code>discard;</code> (e.g if you make a Paint like) or even more crazy things like being able to inject the previous buffer as a texture to implement things like motion-blur or even <a href="http://mathworld.wolfram.com/CellularAutomaton.html">cellular automata</a>.</li>
</ul>
<h3 id="what-might-come-after-this">What might come after this</h3>
<ul>
<li>react-native-video / react-native-camera</li>
<li>static vertex data as well as static vertex shader is a current and decided (? chosen) limitation of <code>gl-react</code>. We want to focus on the incredible capabilities of fragment shaders and work on all optimization that can be made to improve the performance of working with this subset of OpenGL.</li>
</ul>
<h3 id="other-features">Other features</h3>
<p>This library begin the journey of bringing OpenGL to most people using the React simplicity, hiding some complex parts of OpenGL but allowing to implement the fundamental functional bricks of it.</p>
<p>There are a bunch of other features that would take me weeks to explain, but feel free to <a href="https://projectseptemberinc.gitbooks.io/gl-react/content/">read the documentation to learn more about the other props and features</a>.</p>
</div><footer><div class="jsx-2519965637 block"><img src="http://greweb.me/logo.svg" width="100" class="jsx-2519965637"/><div class="jsx-2519965637 right"><div class="jsx-2519965637 description">As a generative plotter artist, I use code to create art (creative coding), draw with fountain pens on robots (plotting), and explore the boundaries of abstract art using algorithms in pursuit of increasingly realistic imagery. I do not produce prints; instead, I create unique &#x27;plots&#x27; - physical works of art that are truly one-of-a-kind.</div><div class="jsx-2519965637 social"><a href="https://twitter.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitter.svg" class="jsx-2519965637"/></a><a href="https://instagram.com/greweb" class="jsx-2519965637"><img alt="" src="/icons/instagram.svg" class="jsx-2519965637"/></a><a href="https://twitch.tv/greweb" class="jsx-2519965637"><img alt="" src="/icons/twitch.svg" class="jsx-2519965637"/></a><a href="https://github.com/gre" class="jsx-2519965637"><img alt="" src="/icons/github.svg" class="jsx-2519965637"/></a><a href="https://opensea.io/greweb?tab=created" class="jsx-2519965637"><img alt="" src="/icons/eth.svg" class="jsx-2519965637"/></a><a href="https://fxhash.xyz/u/greweb" class="jsx-2519965637"><img alt="" src="/icons/tz.svg" class="jsx-2519965637"/></a><a href="https://greweb.itch.io" class="jsx-2519965637"><img alt="" src="/icons/iconmonstr-gamepad-3.svg" class="jsx-2519965637"/></a></div></div></div></footer></article></div></div></div><script>hljs.highlightAll();</script></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"2016-06-19-glreactconf","year":"2016","month":"06","day":"19","slug":"glreactconf","content":"\u003cscript src=\"http://localhost:35729/\"\u003e\u003c/script\u003e\n\n\u003cp\u003eLast February, I talked about \u003ca href=\"https://github.com/projectseptemberinc/gl-react\"\u003e\u003ccode\u003egl-react\u003c/code\u003e\u003c/a\u003e at React.js conference.\u003c/p\u003e\n\u003ciframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Xnqy_zkBAew\" frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/playlist?list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY\"\u003eCheckout talks\u003c/a\u003e of this conference if you are interested by React subject.\nI want to thanks the incredible team behind React.js for the awesome conference and giving me the opportunity to come to San Francisco.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cem\u003eThis article will cover some more technical detail of \u003ca href=\"https://github.com/projectseptemberinc/gl-react\"\u003e\u003ccode\u003egl-react\u003c/code\u003e\u003c/a\u003e that wasn\u0026#39;t explained in the talk.\u003c/em\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eAlso, I\u0026#39;ll try to not go TOO MUCH into technical detail neither, because it would take weeks to cover gl-react features and its implementation tricks!\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!--more--\u003e\n\n\u003chr\u003e\n\u003cp\u003eWe have developed, at \u003ca href=\"http://projectseptember.com\"\u003eProject September\u003c/a\u003e, an \u003ca href=\"https://medium.com/@mjackson/universal-javascript-4761051b7ae9\"\u003euniversal\u003c/a\u003e OpenGL wrapper for React called \u003ca href=\"https://github.com/projectseptemberinc/gl-react\"\u003e\u003ccode\u003egl-react\u003c/code\u003e\u003c/a\u003e working with 2 other libraries: \u003ca href=\"https://github.com/projectseptemberinc/gl-react-dom\"\u003e\u003ccode\u003egl-react-dom\u003c/code\u003e\u003c/a\u003e (wraps WebGL) and \u003ca href=\"https://github.com/projectseptemberinc/gl-react-native\"\u003e\u003ccode\u003egl-react-native\u003c/code\u003e\u003c/a\u003e (wraps OpenGL).\u003c/p\u003e\n\u003cp\u003eThe library allows to define \u003cstrong\u003eadvanced effects\u003c/strong\u003e on top of \u003cstrong\u003eimages, videos, texts or any other VDOM Content\u003c/strong\u003e (like UI Views).\u003c/p\u003e\n\u003cp\u003eCheckout the following \u003ccode\u003egl-react\u003c/code\u003e demos running with the \u003cstrong\u003esame codebase across iOS, Android and the Web !!!\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"advancedeffects\"\u003e\u003ca href=\"http://projectseptemberinc.github.io/gl-react-dom/Examples/AdvancedEffects/\"\u003e\u003cstrong\u003eAdvancedEffects\u003c/strong\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cvideo src=\"/images/2016/03/advanced-effects.mp4\" width=\"100%\" controls autoplay muted loop\u003e\u003c/video\u003e\u003c/p\u003e\n\u003ch2 id=\"githubcomgregl-react-image-effects\"\u003e\u003ca href=\"https://github.com/gre/gl-react-image-effects\"\u003e\u003cstrong\u003egithub.com/gre/gl-react-image-effects\u003c/strong\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://greweb.me/gl-react-image-effects/\" style=\"text-align:center\"\u003e\u003cvideo loop autoplay controls src=\"/images/2016/03/image-effects-ios.mp4\" width=\"33%\"\u003e\u003c/video\u003e\u003cimg src=\"/images/2016/03/image-effects-web.png\" style=\"width: 33%;\" /\u003e\u003cimg src=\"/images/2016/03/image-effects-android.png\" style=\"width: 33%\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"adopting-react-paradigm\"\u003eAdopting React paradigm\u003c/h2\u003e\n\u003cp\u003eThere are a few important points in React that \u003ccode\u003egl-react\u003c/code\u003e follows to fit its paradigm.\u003c/p\u003e\n\u003ch3 id=\"1-react-is-about-composition\"\u003e1. React is about composition\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eComponents are first class citizen\u003c/strong\u003e in React.\nA Component provides isolation by exposing a simple API (props) and encapsulates internal lifecycle.\nOne particular prop is the \u003ccode\u003echildren\u003c/code\u003e prop that, by convention, allows to pass-in children components to a component.\u003c/p\u003e\n\u003cp\u003eFor instance, we can define a component called \u003ccode\u003eContainer\u003c/code\u003e taking a \u003ccode\u003echildren\u003c/code\u003e prop and use it like this in JSX:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;Container\u0026gt;\n  \u0026lt;div\u0026gt;Hello\u0026lt;/div\u0026gt;\n\u0026lt;/Container\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that \u0026quot;JSX\u0026quot; is a syntax sugar that, in this example, transpiles to something like:\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eReact.createElement(Container, {\n  children: React.createElement(\u0026quot;div\u0026quot;, { children: \u0026quot;Hello\u0026quot; }),\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThere are really no magic here: JSX just tends to be more convenient to write and, most of the time, it would be more annoying to use createElement API.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"2-react-is-about-functional-programming\"\u003e2. React is about Functional Programming...\u003c/h3\u003e\n\u003cp\u003eThis might not be that obvious at a first glance but React is about FP. In React paradigm, you describe the full rendering of your application \u003cem\u003e(in \u0026quot;Virtual DOM\u0026quot;)\u003c/em\u003e for a given application state, and you do this every time something changes in the application. So fundamentally, you just have to implement that \u003cstrong\u003efunction from State to Virtual DOM\u003c/strong\u003e to implement your web application – \u003cem\u003ewhich is close to render loops in game dev (but it\u0026#39;s another subject^^).\u003c/em\u003e\u003c/p\u003e\n\u003ch3 id=\"and-reconciliation-on-top-of-an-underlying-imperative-api\"\u003e...and reconciliation on top of an underlying Imperative API\u003c/h3\u003e\n\u003cp\u003eIn React, you don\u0026#39;t go mutating the DOM but you just RENDER EVERYTHING everytime! It\u0026#39;s very simple to reason about, it removes lot of inconsistency bugs and React is here to optimize this with \u003ca href=\"https://facebook.github.io/react/docs/reconciliation.html\"\u003ean algorithm called \u0026quot;reconciliation\u0026quot;\u003c/a\u003e (or diff/patch).\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eEfficiently translating an high level immutable API into a lower level mutable API is the hard work that solves React on top of DOM, as well does gl-react on top of OpenGL.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe \u003ca href=\"https://facebook.github.io/react/docs/reconciliation.html\"\u003ereconciliation\u003c/a\u003e work done by React is a complex optimization problem that have trade-offs. This work is all about \u003cstrong\u003etranslating a imperative API (the DOM) to a functional API (React VDOM)\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn \u003ca href=\"https://github.com/projectseptemberinc/gl-react\"\u003e\u003ccode\u003egl-react\u003c/code\u003e\u003c/a\u003e, we have the \u003cstrong\u003eexact same problem to resolve\u003c/strong\u003e: \u003ca href=\"https://github.com/projectseptemberinc/gl-react\"\u003e\u003ccode\u003egl-react\u003c/code\u003e\u003c/a\u003e exposes a \u003cstrong\u003efunctional API\u003c/strong\u003e and implements for you the complex work over the mutable, stateful and low-level API that is OpenGL / WebGL.\u003c/p\u003e\n\u003ch3 id=\"3-react-is-a-thin-wrapper\"\u003e3. React is a thin wrapper\u003c/h3\u003e\n\u003cp\u003eOne other key point of React is that it\u0026#39;s a \u003cstrong\u003ethin wrapper on top of DOM\u003c/strong\u003e. React focus on translating \u003cstrong\u003eimperative API =\u0026gt; functional API\u003c/strong\u003e with the most minimal \u0026amp; generic way, meaning that React won\u0026#39;t hide you what the DOM elements are about \u003cem\u003e(same as React Native tries just to be on top of real Native components)\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eWe tried to follow this principle as well when wrapping (Open/Web)\u003cstrong\u003eGL\u003c/strong\u003e:\nwe want to hide the complex and imperative part of GL but just expose the great functional parts that are the \u003cstrong\u003eFragment Shaders\u003c/strong\u003e and the \u003cstrong\u003eFramebuffers\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"hardcoding-the-vertex-part-of-the-pipeline\"\u003eHardcoding the vertex part of the pipeline\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/images/2016/03/hardcoded_pipeline.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egl-react\u003c/code\u003e \u003cem\u003ecurrently\u003c/em\u003e focuses on what can be achieved with \u003cstrong\u003ecomposing Fragment Shaders\u003c/strong\u003e with multiple \u003cstrong\u003eFramebuffers\u003c/strong\u003e that define a \u003cstrong\u003egraph of effects\u003c/strong\u003e. The Vertex Data \u0026amp; Vertex Shaders are currently hardcoded.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003egl-react\u003c/code\u003e might unlock this hardcoded part in the future – \u003ca href=\"https://twitter.com/snikhilesh/status/707730742994833408\"\u003esome recent experiments by @snikhilesh\u003c/a\u003e shows a promising overview of what can possibility by done there!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eBut for now, we focus on the huge challenge to implement \u003ccode\u003egl-react\u003c/code\u003e seamlessly between the Web, Android and iOS implementations and to work on performance \u003cem\u003e(e.g of the content rasterization performance)\u003c/em\u003e.\u003c/p\u003e\n\u003cblockquote class=\"twitter-tweet\" data-lang=\"fr\"\u003e\u003cp lang=\"en\" dir=\"ltr\"\u003eNotes from \u003ca href=\"https://twitter.com/greweb\"\u003e@greweb\u003c/a\u003e\u0026#39;s \u003ca href=\"https://twitter.com/hashtag/reactjsconf?src=hash\"\u003e#reactjsconf\u003c/a\u003e talk Universal GL Effects for Web and Native \u003ca href=\"https://t.co/JnIOjAQCOK\"\u003epic.twitter.com/JnIOjAQCOK\u003c/a\u003e\u003c/p\u003e\u0026mdash; Michael Chan (@chantastic) \u003ca href=\"https://twitter.com/chantastic/status/702213897520943104\"\u003e23 février 2016\u003c/a\u003e\u003c/blockquote\u003e\n\u003cscript async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"\u003e\u003c/script\u003e\n\n\u003ch2 id=\"functional-rendering\"\u003e\u003cem\u003e\u0026quot;Functional Rendering\u0026quot;\u003c/em\u003e\u003c/h2\u003e\n\u003cp\u003eWe mentioned earlier that \u003ccode\u003egl-react\u003c/code\u003e focuses on one important piece of OpenGL that is the fragment shader.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eA Fragment Shader is a function\u003c/strong\u003e that independently colors each pixel:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2016/03/functional_rendering.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://greweb.me/2013/11/functional-rendering/\"\u003eWatch this talk\u003c/a\u003e for more detail on what I call \u003cem\u003eFunctional Rendering\u003c/em\u003e.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFragment shaders use a language called GLSL for \u003cem\u003eOpenGL Shading Language\u003c/em\u003e. GLSL is a DSL dedicated to the functional rendering paradigm with \u0026quot;graphics-ready\u0026quot; types (vectors, matrix, sampler2D for textures) and built-in functions (like mix, distance, pow, cos,...).\nCheckout the \u003ca href=\"https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\"\u003especification\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"gluing-with-react\"\u003eGL\u003cem\u003euing\u003c/em\u003e with React\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/projectseptemberinc/gl-react\"\u003e\u003ccode\u003egl-react\u003c/code\u003e\u003c/a\u003e is a core library\u003c/strong\u003e: it doesn\u0026#39;t provide any built-in effects, users have to provide the shaders to render. Hopefully it\u0026#39;s fairly simple to implement basic effects \u003cem\u003e(like saturation, contrast, brightness, inverse, hue,...)\u003c/em\u003e in GLSL language and \u003cem\u003eFunctional Rendering\u003c/em\u003e paradigm.\u003c/p\u003e\n\u003ch3 id=\"hellogl-example\"\u003eHelloGL example\u003c/h3\u003e\n\u003cp\u003eLet\u0026#39;s create HelloGL, our first fragment shader:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-glsl\"\u003eprecision highp float;\nvarying vec2 uv; // This variable vary in all pixel position (normalized from vec2(0.0,0.0) to vec2(1.0,1.0))\nvoid main () { // This function is called FOR EACH PIXEL\n  gl_FragColor = vec4(uv.x, uv.y, 0.5, 1.0); // red vary over X, green vary over Y, blue is 50%, alpha is 100%.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt\u0026#39;s a \u003cem\u003ePoint to Color\u003c/em\u003e function:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ethe input comes from \u003ccode\u003evarying vec2 uv\u003c/code\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ethe output is set in \u003ccode\u003evec4\u003c/code\u003e \u003ccode\u003egl_FragColor\u003c/code\u003e\u003c/strong\u003e – \u003ccode\u003emain()\u003c/code\u003e is called for each pixel with a different \u003ccode\u003euv\u003c/code\u003e (it\u0026#39;s \u003cem\u003evarying\u003c/em\u003e like the keyword indicates).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eso this HelloGL glsl code basically do:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e[ x, y ] =\u0026gt; [ x, y, 0.5, 1.0 ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003cstrong\u003eRED\u003c/strong\u003e component increases with the X position of the pixel.\u003c/li\u003e\n\u003cli\u003eThe \u003cstrong\u003eGREEN\u003c/strong\u003e component increases with the Y position of the pixel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ewhich renders this nice 2D gradient:\u003c/p\u003e\n\u003cimg width=\"160\" src=\"/images/2016/03/hellogl.png\" /\u003e\n\n\u003cp\u003eNow, in \u003ccode\u003egl-react\u003c/code\u003e, we can define \u0026quot;HelloGL\u0026quot; as a GL Component with:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport GL from \u0026quot;gl-react\u0026quot;;\nimport React from \u0026quot;react\u0026quot;;\nconst shaders = GL.Shaders.create({\n  helloGL: {\n    frag: `\nprecision highp float;\nvarying vec2 uv;\nvoid main () {\n  gl_FragColor = vec4(uv.x, uv.y, 0.5, 1.0);\n}`,\n  },\n});\nconst HelloGL = GL.createComponent(() =\u0026gt; \u0026lt;GL.Node shader={shaders.helloGL} /\u0026gt;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand then use it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;HelloGL /\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"coloreddisc-example\"\u003eColoredDisc example\u003c/h3\u003e\n\u003cp\u003eGL Component can have props in parameter that can be passed-in as GLSL Uniforms.\u003c/p\u003e\n\u003cimg class=\"thumbnail-right\" src=\"/images/2016/03/colored-disc.png\" /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;ColoredDisc fromColor=\u0026quot;{[\u0026quot; 1, 0, 1 ]} toColor=\u0026quot;{[\u0026quot; 1, 1, 0 ]} /\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cbr /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport GL from \u0026quot;gl-react\u0026quot;;\nimport React from \u0026quot;react\u0026quot;;\nconst shaders = GL.Shaders.create({\n  ColoredDisc: {\n    frag: `\nprecision highp float;\nvarying vec2 uv;\nuniform vec3 fromColor;\nuniform vec3 toColor;\nvoid main () {\n  float d = 2.0 * distance(uv, vec2(0.5));\n  gl_FragColor = mix(\n    vec4(mix(fromColor, toColor, d), 1.0),\n    vec4(0.0),\n    step(1.0, d)\n  );\n}`,\n  },\n});\nconst ColoredDisc = GL.createComponent(({ fromColor, toColor }) =\u0026gt; (\n  \u0026lt;GL.Node shader={shaders.ColoredDisc} uniforms={{ fromColor, toColor }} /\u0026gt;\n));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"diamondcrop-example\"\u003eDiamondCrop example\u003c/h3\u003e\n\u003cimg class=\"thumbnail-right\" src=\"/images/2016/03/diamond-crop.png\" /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;DiamondCrop\u0026gt; http://i.imgur.com/rkiglmm.jpg \u0026lt;/DiamondCrop\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cbr /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport GL from \u0026quot;gl-react\u0026quot;;\nimport React from \u0026quot;react\u0026quot;;\nconst shaders = GL.Shaders.create({\n  DiamondCrop: {\n    frag: `\nprecision highp float;\nvarying vec2 uv;\nuniform sampler2D t;\nvoid main () {\n  gl_FragColor = mix(\n    texture2D(t, uv),\n    vec4(0.0),\n    step(0.5, abs(uv.x - 0.5) + abs(uv.y - 0.5))\n  );\n}`,\n  },\n});\nconst DiamondCrop = GL.createComponent(({ children: t }) =\u0026gt; (\n  \u0026lt;GL.Node shader={shaders.DiamondCrop} uniforms={{ t }} /\u0026gt;\n));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"any-content-can-be-used\"\u003eAny content can be used\u003c/h2\u003e\n\u003cp\u003eLet\u0026#39;s say we define a Blur effect with \u003ccode\u003egl-react\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst Blur = GL.createComponent(({ children, factor }) =\u0026gt; ...);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, we have just defined a GL Component \u003ccode\u003eBlur\u003c/code\u003e that accept a children as a props.\nIt also accept a factor prop to define the intensity of that blur.\nTherefore we can use \u003ccode\u003eBlur\u003c/code\u003e using JSX in many ways.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eN.B.\u003c/strong\u003e If you want such a Blur, checkout \u003ca href=\"https://github.com/gre/gl-react-blur\"\u003egl-react-blur\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eFirst of all you can blur an image:\u003c/p\u003e\n\u003cimg class=\"thumbnail-right\" src=\"/images/2016/03/blur_image.png\" /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;Blur factor=\u0026quot;{2}\u0026quot;\u0026gt; http://i.imgur.com/rkiglmm.jpg \u0026lt;/Blur\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cbr /\u003e\n\n\u003cp\u003eBut really anything can be passed-in here. For instance, a video\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;Blur factor=\u0026quot;{0.6}\u0026quot;\u0026gt;\n  \u0026lt;video src=\u0026quot;/video.mpg\u0026quot; /\u0026gt;\n\u0026lt;/Blur\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor a canvas:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;Blur factor=\u0026quot;{0.7}\u0026quot;\u0026gt;\n  \u0026lt;canvas ... /\u0026gt;\n\u0026lt;/Blur\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand where that canvas can be provided by a library, like react-canvas:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;Blur factor=\u0026quot;{0.9}\u0026quot;\u0026gt;\n  \u0026lt;ReactCanvas.Surface ...\u0026gt;\n    \u0026lt;ReactCanvas.Text ...\u0026gt;Hello World\u0026lt;/ReactCanvas.Text\u0026gt;\n  \u0026lt;/ReactCanvas.Surface\u0026gt;\n\u0026lt;/Blur\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn React Native context, we even have support for ANY view.\nIt can be a simple Text:\u003c/p\u003e\n\u003cimg class=\"thumbnail-right\" src=\"/images/2016/03/text_blur.png\" /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;Blur factor=\u0026quot;{0.9}\u0026quot;\u0026gt;\n  \u0026lt;Text ...\u0026gt;Hello World\u0026lt;/Text\u0026gt;\n\u0026lt;/Blur\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cbr /\u003e\n\n\u003cp\u003eor even a native component like a Switch component\u003c/p\u003e\n\u003cimg class=\"thumbnail-right\" src=\"/images/2016/03/switch_blur.png\" /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;Blur factor=\u0026quot;{0.9}\u0026quot;\u0026gt;\n  \u0026lt;Switch ... /\u0026gt;\n\u0026lt;/Blur\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cbr /\u003e\n\n\u003cp\u003eThe way this is implemented is platform specific. For instance the Web implementation will just render the content into WebGL (so it works with images, videos, canvas, but not any arbitrary DOM element due to Web Security limitations). However, the Native implementation will be able to \u003cstrong\u003erasterize\u003c/strong\u003e (almost) any view and inject it as a texture (consider this feature experimental at the moment).\u003c/p\u003e\n\u003ch2 id=\"compose-compose-compose\"\u003eCompose, Compose, Compose\u003c/h2\u003e\n\u003cp\u003eBut \u003cstrong\u003ecomposition\u003c/strong\u003e is probably the MOST important part of this:\nYou can also pass a GL Component in uniforms!\u003c/p\u003e\n\u003cp\u003eSo all possible composition of previous examples will just work\u003c/p\u003e\n\u003cimg class=\"thumbnail-right\" src=\"/images/2016/03/diamond_hellogl.png\" /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;DiamondCrop\u0026gt;\n  \u0026lt;HelloGL /\u0026gt;\n\u0026lt;/DiamondCrop\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cbr /\u003e\n\n\u003cimg class=\"thumbnail-right\" src=\"/images/2016/03/blur_diamond_hellogl.png\" /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;Blur factor=\u0026quot;{4}\u0026quot;\u0026gt;\n  \u0026lt;DiamondCrop\u0026gt;\n    \u0026lt;HelloGL /\u0026gt;\n  \u0026lt;/DiamondCrop\u0026gt;\n\u0026lt;/Blur\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cbr /\u003e\n\n\u003cp\u003e\u003ccode\u003egl-react\u003c/code\u003e makes composition efficient using OpenGL Framebuffers.\nThis approach encourages you to write small and generic shaders (instead of one monolithic and specific shader).\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFor this composition to work correctly, the components must be created with \u003ccode\u003eGL.createComponent\u003c/code\u003e or directly be \u003ccode\u003eGL.Node\u003c/code\u003e components.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"\"\u003e\u003cSurface/\u003e\u003c/h2\u003e\n\u003cp\u003eTo actually get a rendering with gl-react, \u003cstrong\u003eyou need to put your GL Component stack into a \u003cSurface/\u003e element\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor instance, to render HelloGL on a 200x200 canvas:\u003c/p\u003e\n\u003cimg class=\"thumbnail-right\" src=\"/images/2016/03/hellogl.png\" /\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;Surface width=\u0026quot;{200}\u0026quot; height=\u0026quot;{200}\u0026quot;\u0026gt;\n  \u0026lt;HelloGL /\u0026gt;\n\u0026lt;/Surface\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003eimport { Surface } from \u0026quot;gl-react-dom\u0026quot;;\nimport { Surface } from \u0026quot;gl-react-native\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cbr/\u003e\n\n\u003cp\u003e\u003cstrong\u003eSurface\u003c/strong\u003e implements the rendering in the contextual platform:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you import \u003ccode\u003e{Surface}\u003c/code\u003e from \u003ccode\u003egl-react-dom\u003c/code\u003e it will renders into a \u003cstrong\u003eWebGL Canvas\u003c/strong\u003e \u003cstrong\u003e\u003cem\u003e(web)\u003c/em\u003e\u003c/strong\u003e, (it\u0026#39;s backed by great \u003ca href=\"http://stack.gl/\"\u003estack.gl\u003c/a\u003e libs)\u003c/li\u003e\n\u003cli\u003eIf, instead, it comes from \u003ccode\u003egl-react-native\u003c/code\u003e, \u003cstrong\u003eGLKView\u003c/strong\u003e \u003cstrong\u003e\u003cem\u003e(iOS)\u003c/em\u003e\u003c/strong\u003e / \u003cstrong\u003eGLSurfaceView\u003c/strong\u003e \u003cstrong\u003e\u003cem\u003e(Android)\u003c/em\u003e\u003c/strong\u003e will be used.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSurface\u003c/strong\u003e have roughly the same API across these 2 libraries but some props might exist only on one of the implementations.\u003c/p\u003e\n\u003ch2 id=\"dynamic-blur-image-title-example\"\u003eDynamic Blur Image Title Example\u003c/h2\u003e\n\u003cp\u003eMy talk featured an advanced use-case that we had in my startup, \u003ca href=\"http://projectseptember.com/\"\u003eProject September\u003c/a\u003e. We are developing a social mobile app with React Native and our designer wanted to have title over image with Blur effects around the title text.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://greweb.me/reactjsconf2016/\"\u003e\u003cimg src=\"/images/2016/03/hellosf.jpg\" alt=\"\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://greweb.me/reactjsconf2016/\"\u003eOpen the demo\u003c/a\u003e – \u003ca href=\"https://github.com/gre/reactjsconf2016\"\u003eSee the code\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThis effect is just exposed as a simple \u003cstrong\u003eImageTitle\u003c/strong\u003e React component that we can use like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;ImageTitle text=\u0026quot;Hello San Francisco ☻\u0026quot;\u0026gt;\n  http://i.imgur.com/XXXXXX.jpg\n\u0026lt;/ImageTitle\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe point of \u003ccode\u003egl-react\u003c/code\u003e is we all know how to compose React components, just put it in a \u003cstrong\u003eSurface\u003c/strong\u003e and you obtain a title over image effect like on the image above.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ewe can even run the effect over a video\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;ImageTitle text=\u0026quot;Hello San Francisco ☻\u0026quot;\u0026gt;\n  \u0026lt;video src=\u0026quot;video.mp4\u0026quot; /\u0026gt;\n\u0026lt;/ImageTitle\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich is what \u003ca href=\"http://greweb.me/reactjsconf2016/\"\u003eour demo\u003c/a\u003e does if you enable the video mode.\u003c/p\u003e\n\u003ch2 id=\"under-the-hood\"\u003eUnder the hood\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis section will show \u003cstrong\u003eImageTitle\u003c/strong\u003e implementation that will illustrate \u003ccode\u003egl-react\u003c/code\u003e optimization techniques.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eLet\u0026#39;s take a quick look at our ImageTitle shader. That shader renders the title text on top of the blurred image. The title text color is chosen based on the average pixel color (if the content is dark, we use a white title, otherwise a black one).\u003c/p\u003e\n\u003cp\u003eI won\u0026#39;t enter more into implementation detail, but here is the fragment shader:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2016/03/image-title-shader.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eNow, let\u0026#39;s focus on our JavaScript gl-react code.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eImageTitle\u003c/strong\u003e is a GL Component that takes a few props (basically \u003ccode\u003etitle\u003c/code\u003e and \u003ccode\u003echildren\u003c/code\u003e) and delegates the job using a few other Components: \u003cstrong\u003eTitle\u003c/strong\u003e that renders the text, \u003cstrong\u003eTitleBlurMap\u003c/strong\u003e that generates a blur map of that text, \u003cstrong\u003eBlurV\u003c/strong\u003e that apply the blurmap to generate a variable blur over the content (image/video), \u003cstrong\u003eAveragePixels\u003c/strong\u003e that generate one pixel out of the content.\nThese 4 elements are then composed into our final ImageTitle shader.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2016/03/image-title-imports.png\" alt=\"\"\u003e\n\u003cimg src=\"/images/2016/03/image-title-component.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eComposition is the key point here, we have defined our component with simple code, delegated and composed part of the effect with other component.\u003c/p\u003e\n\u003cp\u003eAnd each sub-component is doing more work. For instance \u003cstrong\u003eTitleBlurMap\u003c/strong\u003e is itself another GL component, which uses composes a component \u003cstrong\u003eBlur\u003c/strong\u003e and apply a threshold to generate a black and white blur map:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2016/03/titleblurmap_impl.png\" alt=\"\"\u003e\n\u003cimg src=\"/images/2016/03/titleblurmap_node_detail.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eAnd so on! \u003cstrong\u003eBlur\u003c/strong\u003e is itself another GL component!\nAnd like \u003cstrong\u003eBlurV\u003c/strong\u003e, it is implementing a 4-pass blur, so it will pipe 4 times a Blur1D component:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2016/03/blurstack.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBlur\u003c/strong\u003e simply recursively composes Blur1D:\n\u003cimg src=\"/images/2016/03/blur_impl.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHave I lost you? Don\u0026#39;t worry, we will show in a few section what the big picture scene looks like.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"-how-gl-react-transform-your-surface-and-effects-stack\"\u003e\u003ca name=\"dedup\"\u003e\u003c/a\u003e How gl-react transform your Surface and effects stack\u003c/h3\u003e\n\u003cp\u003eWe have just overviewed how deep a GL effects stack can be: going down into each individual component that itself use many other components can ends a with a pretty big tree. That\u0026#39;s true for any React application actually, but React is still performant.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHowever, we have a fundamental difference between classical React DOM and \u003ccode\u003egl-react\u003c/code\u003e: a GL effects stack is just a single Canvas element at the end.\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWhen you write a tree of GL Components, each component don\u0026#39;t get append into the DOM like would do a stack of Virtual DOM elements. Instead we need at the end to render the full Virtual GL tree into one single \u003ccode\u003e\u0026lt;canvas/\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eTherefore, we don\u0026#39;t treat GL Component the same way React does. \u003ccode\u003egl-react\u003c/code\u003e will do internal work to \u003cstrong\u003eunfold user\u0026#39;s Virtual GL tree\u003c/strong\u003e and convert it into a \u003cstrong\u003e\u0026quot;scene\u0026quot; object that contains everything a renderer need to know\u003c/strong\u003e. This object is passed as a \u003ccode\u003e\u0026quot;data\u0026quot;\u003c/code\u003e props to the underlying implementation (that we call internally \u003cstrong\u003e\u003cem\u003eGLCanvas\u003c/em\u003e\u003c/strong\u003e).\u003c/p\u003e\n\u003cp\u003eIf we inspect with React Dev Tools what our \u003ccode\u003e\u0026lt;Surface/\u0026gt;\u003c/code\u003e actually gets render into you will see something like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2016/03/resolved_rendering.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eActually, the \u003ccode\u003eSurface\u003c/code\u003e get rendered into a... \u003ccode\u003e\u0026lt;div/\u0026gt;\u003c/code\u003e \u003cstrong\u003e(1)\u003c/strong\u003e. We need to do this because we need to not only render the Canvas \u003cstrong\u003e(3)\u003c/strong\u003e but we also need to render any possible content that was passed-in the stack that would need to get rasterized (in web context, it can be a \u003cstrong\u003evideo\u003c/strong\u003e or another \u003cstrong\u003ecanvas\u003c/strong\u003e). In our case, it\u0026#39;s the \u003ccode\u003e\u0026lt;Title/\u0026gt;\u003c/code\u003e component, that is backed with \u003cstrong\u003ereact-canvas\u003c/strong\u003e to draw Text using a Canvas (the only simple way to get texts in WebGL). So this is why we need \u003cstrong\u003e(2)\u003c/strong\u003e, that is a container for the content, that container is moved behind the canvas and is made invisible (unless you enable some hidden secret props! \u003ca href=\"https://projectseptemberinc.gitbooks.io/gl-react/content/docs/api/Surface.html\"\u003eread more about advanced props of Surface in the documentation\u003c/a\u003e).\u003c/p\u003e\n\u003ch3 id=\"how-gl-react-optimizes-the-effects-stack--factorize-computation\"\u003eHow gl-react optimizes the effects stack \u0026amp; factorize computation\u003c/h3\u003e\n\u003cp\u003eThe previous complex example, if implemented naïvely, ends up with this big tree:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Before factorization optimization:\u003c/strong\u003e \u003cem\u003e(naïve implementation)\u003c/em\u003e\n\u003cimg src=\"/images/2016/03/reactjs2016_greweb.036.jpeg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eIt contains a lot of duplicates: the Title rendering appears 6 times\nand the \u0026quot;Text Blurring 4-Blur stack\u0026quot; also appears 5 times.\u003c/p\u003e\n\u003cp\u003eThis is just computing the same thing multiple times where we should be able to compute it once...\u003c/p\u003e\n\u003cp\u003eTo solve this, we will just use the VDOM \u003cstrong\u003ereferential transparency\u003c/strong\u003e: if 2 VDOM element have the same reference, we can assume it renders the same thing so we can just dedupe to share and render it once.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis is one of our biggest innovation in \u003ccode\u003egl-react\u003c/code\u003e: when you give a stack of effects in Surface, we will dedupe the tree.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAt the end of this process our example results of:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. After factorization optimization:\u003c/strong\u003e\n\u003cimg src=\"/images/2016/03/reactjs2016_greweb.041.jpeg\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eWe have moved from 38 to 13 nodes and reduce the render speed from 20ms to 4ms.\u003c/p\u003e\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\u003cp\u003eIf you would implement a stack of effects using the imperative OpenGL API, you would obviously write an ordered sequence of effects to do and that would naturally share the computations in temporary buffers for best performance.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThe important job of gl-react is to allow you to write descriptive code without losing this advantage of using temporary pixel buffers and keeping a thin layer on top of the underlying OpenGL.\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"other-side-projects\"\u003eOther side projects\u003c/h2\u003e\n\u003ch3 id=\"gl-react-inspector\"\u003egl-react-inspector\u003c/h3\u003e\n\u003cp\u003eOne of the most appreciated part in my talk is the Inspector we specially develop for gl-react.\u003c/p\u003e\n\u003cp\u003eI initially developed it because I wanted to have charts to show people what gl-react graph looks like and without having to go Inkscape and handcrafting them...\nBut it ended up behind a useful tool to actually develop with, because you can see what\u0026#39;s going on underneath (at each node step, and what the texture looks at intermediary steps). It also helps seeing investigating on performance.\u003c/p\u003e\n\u003cp\u003eOur big future challenge with this is to make it work as a standalone devtools (I imagine it could be part of the React devtools, if we could have plugins there).\nand to make it work with React Native too.\u003c/p\u003e\n\u003ch3 id=\"gl-react-dom-static-container\"\u003egl-react-dom-static-container\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/gre/gl-react-dom-static-container\"\u003ehttps://github.com/gre/gl-react-dom-static-container\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"some-universal-gl-effects\"\u003eSome universal GL effects\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/gre/gl-react-blur\"\u003egl-react-blur\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/gre/gl-react-negative\"\u003egl-react-negative\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/gre/gl-react-constrast-saturation-brightness\"\u003egl-react-constrast-saturation-brightness\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/gre/gl-react-hue-rotate\"\u003egl-react-hue-rotate\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/gre/gl-react-color-matrix\"\u003egl-react-color-matrix\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"gl-react-image\"\u003egl-react-image\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/gre/gl-react-image\"\u003egl-react-image\u003c/a\u003e is a component that solves preserving ratios of your images (because stretching is the default behavior).\u003c/p\u003e\n\u003ch2 id=\"we-need-your-help\"\u003eWe need your help!\u003c/h2\u003e\n\u003ch3 id=\"what-should-come-soon\"\u003eWhat should come soon\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ecaching framebuffers from one frame to another: allow different interesting things: cache part of the graph (e.g to allow to cache a static intensive part of the graph), cache part of a rendering with \u003ccode\u003ediscard;\u003c/code\u003e (e.g if you make a Paint like) or even more crazy things like being able to inject the previous buffer as a texture to implement things like motion-blur or even \u003ca href=\"http://mathworld.wolfram.com/CellularAutomaton.html\"\u003ecellular automata\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"what-might-come-after-this\"\u003eWhat might come after this\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ereact-native-video / react-native-camera\u003c/li\u003e\n\u003cli\u003estatic vertex data as well as static vertex shader is a current and decided (? chosen) limitation of \u003ccode\u003egl-react\u003c/code\u003e. We want to focus on the incredible capabilities of fragment shaders and work on all optimization that can be made to improve the performance of working with this subset of OpenGL.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"other-features\"\u003eOther features\u003c/h3\u003e\n\u003cp\u003eThis library begin the journey of bringing OpenGL to most people using the React simplicity, hiding some complex parts of OpenGL but allowing to implement the fundamental functional bricks of it.\u003c/p\u003e\n\u003cp\u003eThere are a bunch of other features that would take me weeks to explain, but feel free to \u003ca href=\"https://projectseptemberinc.gitbooks.io/gl-react/content/\"\u003eread the documentation to learn more about the other props and features\u003c/a\u003e.\u003c/p\u003e\n","data":{"title":"Universal GL Effects for Web and Native","author":"Gaetan","layout":"post","tags":["react","webgl","gl-react"]}},"__N_SSG":true},"page":"/[year]/[month]/[slug]","query":{"year":"2016","month":"06","slug":"glreactconf"},"buildId":"cuvbQJX_pqnWZ0CfuPVsq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>